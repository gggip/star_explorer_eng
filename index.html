<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Stellar Explorer - Geometry Learning</title>
    
    <!-- PWA Meta Tags -->
    <meta name="description" content="Connect the stars to master geometry! Race against time in this cosmic adventure learning triangles, squares, and more.">
    <meta name="theme-color" content="#0A0B2F">
    <meta name="background-color" content="#0A0B2F">
    <meta name="display" content="standalone">
    <meta name="orientation" content="portrait">
    <meta name="start_url" content="./">
    >
    <!-- iOS PWA Support --
    <meta name="apple-mobile-web-app-capable" content="yes">
    <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
    <meta name="apple-mobile-web-app-title" content="Stellar Explorer">
    
    <!-- PWA Icons -->
    <!-- PWA Icons -->
    <link rel="icon" type="image/png" sizes="192x192" href="data:image/svg+xml,<svg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 192 192'><defs><radialGradient id='bg' cx='50%25' cy='50%25' r='50%25'><stop offset='0%25' style='stop-color:%23001122;stop-opacity:1' /><stop offset='100%25' style='stop-color:%230A0B2F;stop-opacity:1' /></radialGradient></defs><rect width='192' height='192' fill='url(%23bg)'/><circle cx='96' cy='70' r='3' fill='%23FFD700'/><circle cx='60' cy='90' r='2' fill='%2364FFDA'/><circle cx='130' cy='80' r='2.5' fill='%23FFFFFF'/><circle cx='80' cy='120' r='2' fill='%23FFD700'/><circle cx='120' cy='110' r='2' fill='%2364FFDA'/><polygon points='60,90 80,120 120,110' stroke='%2364FFDA' stroke-width='2' fill='none'/><text x='96' y='150' text-anchor='middle' fill='%2364FFDA' font-family='Arial,sans-serif' font-size='14' font-weight='bold'>STELLAR</text><text x='96' y='170' text-anchor='middle' fill='%23FFD700' font-family='Arial,sans-serif' font-size='12'>EXPLORER</text></svg>">
    <link rel="apple-touch-icon" href="data:image/svg+xml,<svg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 180 180'><defs><radialGradient id='bg2' cx='50%25' cy='50%25' r='50%25'><stop offset='0%25' style='stop-color:%23001122;stop-opacity:1' /><stop offset='100%25' style='stop-color:%230A0B2F;stop-opacity:1' /></radialGradient></defs><rect width='180' height='180' rx='40' fill='url(%23bg2)'/><circle cx='90' cy='65' r='3' fill='%23FFD700'/><circle cx='55' cy='85' r='2' fill='%2364FFDA'/><circle cx='125' cy='75' r='2.5' fill='%23FFFFFF'/><circle cx='75' cy='115' r='2' fill='%23FFD700'/><circle cx='115' cy='105' r='2' fill='%2364FFDA'/><polygon points='55,85 75,115 115,105' stroke='%2364FFDA' stroke-width='2' fill='none'/><text x='90' y='140' text-anchor='middle' fill='%2364FFDA' font-family='Arial,sans-serif' font-size='12' font-weight='bold'>STELLAR</text><text x='90' y='155' text-anchor='middle' fill='%23FFD700' font-family='Arial,sans-serif' font-size='10'>EXPLORER</text></svg>">
    
    <!-- PWA Manifest -->
    <script>
        // Inline Web App Manifest
        const manifestData = {
            "name": "Stellar Explorer - Geometry Learning Game",
            "short_name": "Stellar Explorer",
            "description": "Connect the stars to master geometry! Race against time in this cosmic adventure learning triangles, squares, and more.",
            "start_url": "./",
            "display": "standalone",
            "background_color": "#0A0B2F",
            "theme_color": "#0A0B2F",
            "orientation": "portrait-primary",
            "scope": "./",
            "categories": ["education", "games"],
            "screenshots": [
                {
                    "src": "data:image/svg+xml,<svg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 540 960'><defs><radialGradient id='bg' cx='50%25' cy='50%25' r='50%25'><stop offset='0%25' style='stop-color:%23001122;stop-opacity:1' /><stop offset='100%25' style='stop-color:%230A0B2F;stop-opacity:1' /></radialGradient></defs><rect width='540' height='960' fill='url(%23bg)'/><text x='270' y='100' text-anchor='middle' fill='%2364FFDA' font-family='Arial,sans-serif' font-size='32' font-weight='bold'>Stellar Explorer</text><rect x='45' y='150' width='450' height='450' fill='%23001122' rx='8'/><circle cx='120' cy='250' r='4' fill='%23FFD700'/><circle cx='200' cy='300' r='4' fill='%2364FFDA'/><circle cx='350' cy='280' r='4' fill='%23FFFFFF'/><circle cx='180' cy='400' r='4' fill='%23FFD700'/><circle cx='320' cy='380' r='4' fill='%2364FFDA'/><polygon points='120,250 180,400 320,380' stroke='%2364FFDA' stroke-width='3' fill='none'/><text x='270' y='700' text-anchor='middle' fill='%23FFD700' font-family='Arial,sans-serif' font-size='24'>Connect the Stars!</text><text x='270' y='750' text-anchor='middle' fill='%23FFFFFF' font-family='Arial,sans-serif' font-size='18'>Master Geometry in Space</text></svg>",
                    "sizes": "540x960",
                    "type": "image/svg+xml",
                    "form_factor": "narrow",
                    "label": "Stellar Explorer - Main Game Screen"
                },
                {
                    "src": "data:image/svg+xml,<svg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 960 540'><defs><radialGradient id='bg' cx='50%25' cy='50%25' r='50%25'><stop offset='0%25' style='stop-color:%23001122;stop-opacity:1' /><stop offset='100%25' style='stop-color:%230A0B2F;stop-opacity:1' /></radialGradient></defs><rect width='960' height='540' fill='url(%23bg)'/><text x='480' y='80' text-anchor='middle' fill='%2364FFDA' font-family='Arial,sans-serif' font-size='36' font-weight='bold'>Stellar Explorer - Time Challenge</text><rect x='255' y='120' width='450' height='300' fill='%23001122' rx='8'/><circle cx='330' cy='200' r='4' fill='%23FFD700'/><circle cx='410' cy='250' r='4' fill='%2364FFDA'/><circle cx='560' cy='230' r='4' fill='%23FFFFFF'/><circle cx='390' cy='350' r='4' fill='%23FFD700'/><circle cx='530' cy='330' r='4' fill='%2364FFDA'/><polygon points='330,200 390,350 530,330' stroke='%2364FFDA' stroke-width='3' fill='none'/><text x='480' y='480' text-anchor='middle' fill='%23FFD700' font-family='Arial,sans-serif' font-size='24'>Learn Geometry Through Play</text></svg>",
                    "sizes": "960x540",
                    "type": "image/svg+xml",
                    "form_factor": "wide",
                    "label": "Stellar Explorer - Desktop View"
                }
            ],
            "icons": [
                {
                    "src": "data:image/svg+xml,<svg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 72 72'><defs><radialGradient id='bg' cx='50%25' cy='50%25' r='50%25'><stop offset='0%25' style='stop-color:%23001122;stop-opacity:1' /><stop offset='100%25' style='stop-color:%230A0B2F;stop-opacity:1' /></radialGradient></defs><rect width='72' height='72' rx='16' fill='url(%23bg)'/><circle cx='36' cy='28' r='2' fill='%23FFD700'/><circle cx='26' cy='36' r='1.5' fill='%2364FFDA'/><circle cx='46' cy='32' r='1.5' fill='%23FFFFFF'/><circle cx='32' cy='48' r='1.5' fill='%23FFD700'/><circle cx='44' cy='44' r='1.5' fill='%2364FFDA'/><polygon points='26,36 32,48 44,44' stroke='%2364FFDA' stroke-width='1.5' fill='none'/></svg>",
                    "sizes": "72x72",
                    "type": "image/svg+xml",
                    "purpose": "any"
                },
                {
                    "src": "data:image/svg+xml,<svg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 96 96'><defs><radialGradient id='bg' cx='50%25' cy='50%25' r='50%25'><stop offset='0%25' style='stop-color:%23001122;stop-opacity:1' /><stop offset='100%25' style='stop-color:%230A0B2F;stop-opacity:1' /></radialGradient></defs><rect width='96' height='96' rx='20' fill='url(%23bg)'/><circle cx='48' cy='35' r='2.5' fill='%23FFD700'/><circle cx='35' cy='45' r='2' fill='%2364FFDA'/><circle cx='61' cy='40' r='2' fill='%23FFFFFF'/><circle cx='42' cy='60' r='2' fill='%23FFD700'/><circle cx='58' cy='55' r='2' fill='%2364FFDA'/><polygon points='35,45 42,60 58,55' stroke='%2364FFDA' stroke-width='2' fill='none'/></svg>",
                    "sizes": "96x96",
                    "type": "image/svg+xml",
                    "purpose": "any"
                },
                {
                    "src": "data:image/svg+xml,<svg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 128 128'><defs><radialGradient id='bg' cx='50%25' cy='50%25' r='50%25'><stop offset='0%25' style='stop-color:%23001122;stop-opacity:1' /><stop offset='100%25' style='stop-color:%230A0B2F;stop-opacity:1' /></radialGradient></defs><rect width='128' height='128' rx='28' fill='url(%23bg)'/><circle cx='64' cy='46' r='3' fill='%23FFD700'/><circle cx='46' cy='60' r='2.5' fill='%2364FFDA'/><circle cx='82' cy='53' r='2.5' fill='%23FFFFFF'/><circle cx='56' cy='80' r='2.5' fill='%23FFD700'/><circle cx='78' cy='73' r='2.5' fill='%2364FFDA'/><polygon points='46,60 56,80 78,73' stroke='%2364FFDA' stroke-width='2.5' fill='none'/></svg>",
                    "sizes": "128x128",
                    "type": "image/svg+xml",
                    "purpose": "any"
                },
                {
                    "src": "data:image/svg+xml,<svg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 192 192'><defs><radialGradient id='bg' cx='50%25' cy='50%25' r='50%25'><stop offset='0%25' style='stop-color:%23001122;stop-opacity:1' /><stop offset='100%25' style='stop-color:%230A0B2F;stop-opacity:1' /></radialGradient></defs><rect width='192' height='192' rx='42' fill='url(%23bg)'/><circle cx='96' cy='70' r='4' fill='%23FFD700'/><circle cx='70' cy='90' r='3' fill='%2364FFDA'/><circle cx='122' cy='80' r='3' fill='%23FFFFFF'/><circle cx='84' cy='120' r='3' fill='%23FFD700'/><circle cx='114' cy='110' r='3' fill='%2364FFDA'/><polygon points='70,90 84,120 114,110' stroke='%2364FFDA' stroke-width='3' fill='none'/><text x='96' y='150' text-anchor='middle' fill='%2364FFDA' font-family='Arial,sans-serif' font-size='12' font-weight='bold'>STELLAR</text><text x='96' y='165' text-anchor='middle' fill='%23FFD700' font-family='Arial,sans-serif' font-size='10'>EXPLORER</text></svg>",
                    "sizes": "192x192",
                    "type": "image/svg+xml",
                    "purpose": "any"
                },
                {
                    "src": "data:image/svg+xml,<svg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 512 512'><defs><radialGradient id='bg' cx='50%25' cy='50%25' r='50%25'><stop offset='0%25' style='stop-color:%23001122;stop-opacity:1' /><stop offset='100%25' style='stop-color:%230A0B2F;stop-opacity:1' /></radialGradient></defs><rect width='512' height='512' rx='115' fill='url(%23bg)'/><circle cx='256' cy='180' r='8' fill='%23FFD700'/><circle cx='200' cy='220' r='6' fill='%2364FFDA'/><circle cx='312' cy='200' r='7' fill='%23FFFFFF'/><circle cx='230' cy='300' r='6' fill='%23FFD700'/><circle cx='290' cy='280' r='6' fill='%2364FFDA'/><polygon points='200,220 230,300 290,280' stroke='%2364FFDA' stroke-width='6' fill='none'/><text x='256' y='370' text-anchor='middle' fill='%2364FFDA' font-family='Arial,sans-serif' font-size='32' font-weight='bold'>STELLAR</text><text x='256' y='410' text-anchor='middle' fill='%23FFD700' font-family='Arial,sans-serif' font-size='24'>EXPLORER</text><text x='256' y='450' text-anchor='middle' fill='%23FFFFFF' font-family='Arial,sans-serif' font-size='18'>Geometry Learning</text></svg>",
                    "sizes": "512x512",
                    "type": "image/svg+xml",
                    "purpose": "any maskable"
                }
            ]
        };
        
        // Create and inject manifest
        const manifestBlob = new Blob([JSON.stringify(manifestData)], {type: 'application/json'});
        const manifestURL = URL.createObjectURL(manifestBlob);
        const manifestLink = document.createElement('link');
        manifestLink.rel = 'manifest';
        manifestLink.href = manifestURL;
        document.head.appendChild(manifestLink);
    </script>
    <style>
        body {
            background-color: #0A0B2F;
            color: white;
            font-family: 'Arial', sans-serif;
            text-align: center;
            margin: 0;
            padding: 20px;
            overflow-x: hidden;
        }
        
        .shape-selector {
            margin-bottom: 30px;
            animation: selector-fade-in 1.5s ease-out forwards;
            opacity: 0;
            transform: translateY(30px);
        }
        
        .shape-selector p {
            margin-bottom: 20px;
            font-size: 22px;
            font-weight: bold;
            color: #A0FFE6;
            text-shadow: 0 0 10px rgba(160, 255, 230, 0.4);
        }
        
        .shape-options {
            display: flex;
            flex-direction: column;
            gap: 15px;
            align-items: center;
        }
        
        .shape-option {
            display: flex;
            align-items: center;
            cursor: pointer;
            user-select: none;
            background: linear-gradient(135deg, rgba(93, 92, 222, 0.15), rgba(66, 64, 179, 0.1));
            padding: 12px 25px;
            border-radius: 25px;
            border: 2px solid rgba(100, 255, 218, 0.3);
            transition: all 0.3s ease;
            min-width: 280px;
            justify-content: center;
            backdrop-filter: blur(10px);
            box-shadow: 0 4px 15px rgba(0, 0, 0, 0.2);
        }
        
        .shape-option:hover {
            background: linear-gradient(135deg, rgba(93, 92, 222, 0.25), rgba(66, 64, 179, 0.2));
            border-color: rgba(100, 255, 218, 0.6);
            transform: translateY(-3px) scale(1.02);
            box-shadow: 0 8px 25px rgba(100, 255, 218, 0.3);
        }
        
        .shape-option input {
            margin-right: 12px;
            transform: scale(1.2);
            accent-color: #64FFDA;
        }
        
        .shape-name {
            font-size: 18px;
            font-weight: 600;
            color: rgba(255, 255, 255, 0.9);
            text-shadow: 0 0 5px rgba(255, 255, 255, 0.3);
        }
        
        @keyframes selector-fade-in {
            to {
                opacity: 1;
                transform: translateY(0);
            }
        }
        
        h1 {
            margin-bottom: 20px;
            font-size: 28px;
            text-shadow: 0 0 10px rgba(100, 255, 218, 0.5);
            color: #64FFDA;
        }
        
        #gameCanvas {
            background: linear-gradient(to bottom, #0B0E2E, #1A1B4B);
            border-radius: 8px;
            margin: 0 auto;
            display: block;
            box-shadow: 0 0 20px rgba(0, 0, 0, 0.5);
            border: 1px solid #2A2A6A;
            position: relative;
        }
        
        #controls {
            margin-top: 20px;
            display: flex;
            flex-wrap: wrap;
            justify-content: center;
            gap: 10px;
            align-items: center;
        }
        
        button {
            background: linear-gradient(135deg, #5D5CDE, #4240B3);
            color: white;
            border: none;
            padding: 10px 15px;
            border-radius: 5px;
            cursor: pointer;
            transition: all 0.3s;
            font-size: 0.9rem;
            box-shadow: 0 3px 8px rgba(93, 92, 222, 0.4);
        }
        
        button:hover {
            background: linear-gradient(135deg, #6E6DFF, #5250C4);
            transform: translateY(-3px);
            box-shadow: 0 5px 15px rgba(93, 92, 222, 0.6);
        }
        
        button:active {
            transform: translateY(-1px);
            box-shadow: 0 2px 5px rgba(93, 92, 222, 0.4);
        }
        
        #checkBtn {
            background: linear-gradient(135deg, #64FFDA, #00D0B6);
            color: #0A0B2F;
            font-size: 1.1rem;
            font-weight: bold;
            padding: 12px 25px;
            box-shadow: 0 4px 12px rgba(100, 255, 218, 0.4);
        }
        
        #checkBtn:hover {
            background: linear-gradient(135deg, #7AFFDF, #00E0C6);
            transform: translateY(-3px);
            box-shadow: 0 8px 20px rgba(100, 255, 218, 0.5);
        }
        
        .secondary-btn {
            background: linear-gradient(135deg, rgba(93, 92, 222, 0.7), rgba(66, 64, 179, 0.7));
            font-size: 0.8rem;
            padding: 8px 12px;
        }
        
        #hintVisualBtn {
            background: linear-gradient(135deg, rgba(255, 215, 0, 0.7), rgba(230, 190, 0, 0.7));
            color: #0A0B2F;
        }
        
        #hintVisualBtn:hover {
            background: linear-gradient(135deg, rgba(255, 215, 0, 0.9), rgba(230, 190, 0, 0.9));
        }
        
        #info {
            margin-top: 20px;
            padding: 15px;
            background: linear-gradient(135deg, rgba(93, 92, 222, 0.2), rgba(93, 92, 222, 0.1));
            border-radius: 10px;
            max-width: 400px;
            margin-left: auto;
            margin-right: auto;
            box-shadow: 0 4px 15px rgba(0, 0, 0, 0.2);
            border: 1px solid rgba(93, 92, 222, 0.3);
        }

        #task {
            font-weight: bold;
            color: #64FFDA;
            margin-bottom: 15px;
            line-height: 1.5;
            font-size: 18px;
            text-shadow: 0 0 5px rgba(100, 255, 218, 0.3);
        }

        .tooltip {
            position: absolute;
            background: linear-gradient(135deg, rgba(0, 0, 0, 0.8), rgba(20, 20, 50, 0.8));
            padding: 8px 15px;
            border-radius: 20px;
            pointer-events: none;
            z-index: 100;
            font-size: 14px;
            box-shadow: 0 4px 10px rgba(0, 0, 0, 0.3);
            border: 1px solid rgba(100, 255, 218, 0.3);
            color: #64FFDA;
            display: none;
        }

        #hintBox {
            margin-top: 15px;
            padding: 12px;
            background: linear-gradient(135deg, rgba(100, 255, 218, 0.1), rgba(100, 255, 218, 0.05));
            border-radius: 8px;
            display: none;
            border: 1px solid rgba(100, 255, 218, 0.2);
            box-shadow: 0 0 10px rgba(100, 255, 218, 0.1);
        }
        
        .score-container {
            position: absolute;
            top: 15px;
            right: 15px;
            background: linear-gradient(135deg, rgba(93, 92, 222, 0.7), rgba(66, 64, 179, 0.7));
            padding: 8px 15px;
            border-radius: 20px;
            box-shadow: 0 4px 15px rgba(0, 0, 0, 0.3);
            z-index: 10;
            display: flex;
            flex-direction: column;
            border: 1px solid rgba(255, 255, 255, 0.1);
        }
        
        #scoreDisplay, #streakDisplay, #highScoreDisplay {
            display: block;
            margin: 3px 0;
            font-size: 14px;
            text-shadow: 0 0 5px rgba(255, 255, 255, 0.5);
        }
        
        #streakDisplay {
            color: #FFD700;
        }
        
        .timer-container {
            position: absolute;
            top: 15px;
            left: 15px;
            background: linear-gradient(135deg, rgba(93, 92, 222, 0.7), rgba(66, 64, 179, 0.7));
            padding: 8px 15px;
            border-radius: 20px;
            box-shadow: 0 4px 15px rgba(0, 0, 0, 0.3);
            z-index: 10;
            border: 1px solid rgba(255, 255, 255, 0.1);
        }
        
        #timerDisplay {
            font-size: 20px;
            font-weight: bold;
            color: #FFD700;
            text-shadow: 0 0 8px rgba(255, 215, 0, 0.5);
        }
        
        .pulse-animation {
            animation: pulse-effect 0.5s;
        }
        
        @keyframes pulse-effect {
            0% { transform: scale(1); }
            50% { transform: scale(1.2); }
            100% { transform: scale(1); }
        }
        
        .result-message {
            padding: 12px 20px;
            border-radius: 10px;
            margin-top: 15px;
            display: inline-block;
            font-weight: bold;
            font-size: 16px;
            box-shadow: 0 4px 15px rgba(0, 0, 0, 0.2);
        }
        
        .result-success {
            background: linear-gradient(135deg, rgba(100, 255, 128, 0.2), rgba(80, 235, 108, 0.2));
            color: #64FFDA;
            border: 1px solid rgba(100, 255, 128, 0.3);
            text-shadow: 0 0 5px rgba(100, 255, 218, 0.5);
        }
        
        .result-fail {
            background: linear-gradient(135deg, rgba(255, 100, 100, 0.2), rgba(235, 80, 80, 0.2));
            color: #FF6464;
            border: 1px solid rgba(255, 100, 100, 0.3);
            text-shadow: 0 0 5px rgba(255, 100, 100, 0.5);
        }
        
        #startScreen {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100vh;
            background: 
                radial-gradient(ellipse at top, rgba(30, 40, 100, 0.8) 0%, rgba(10, 15, 40, 0.95) 50%, rgba(5, 8, 25, 0.98) 100%),
                linear-gradient(135deg, rgba(20, 30, 70, 0.3), rgba(40, 20, 80, 0.3));
            display: flex;
            flex-direction: column;
            justify-content: flex-start;
            align-items: center;
            z-index: 100;
            overflow-y: auto;
            overflow-x: hidden;
            animation: cosmic-pulse 8s ease-in-out infinite alternate;
            padding: 20px 0 40px 0;
            box-sizing: border-box;
        }
        
        @keyframes cosmic-pulse {
            0% { background-size: 100% 100%; }
            100% { background-size: 110% 110%; }
        }
        
        #startScreen:before {
            content: '';
            position: absolute;
            width: 300%;
            height: 300%;
            top: -100%;
            left: -100%;
            background-image: 
                radial-gradient(circle at 20% 80%, rgba(100, 255, 218, 0.4) 0%, transparent 50%),
                radial-gradient(circle at 80% 20%, rgba(255, 100, 255, 0.3) 0%, transparent 50%),
                radial-gradient(circle at 40% 40%, rgba(100, 200, 255, 0.2) 0%, transparent 70%),
                radial-gradient(2px 2px, rgba(255, 255, 255, 0.8) 1px, transparent 1px),
                radial-gradient(1px 1px, rgba(100, 255, 218, 0.6) 1px, transparent 1px),
                radial-gradient(1px 1px, rgba(255, 200, 100, 0.4) 1px, transparent 1px);
            background-size: 
                800px 800px, 600px 600px, 400px 400px,
                100px 100px, 150px 150px, 200px 200px;
            background-position: 
                0 0, 400px 400px, 200px 200px,
                0 0, 50px 50px, 100px 100px;
            animation: 
                nebula-drift 30s linear infinite,
                stars-twinkle 20s linear infinite,
                cosmic-rotation 60s linear infinite;
            z-index: -1;
            opacity: 0.8;
        }
        
        #startScreen:after {
            content: '';
            position: absolute;
            width: 100%;
            height: 100%;
            background: 
                radial-gradient(circle at 25% 25%, rgba(100, 255, 218, 0.1) 0%, transparent 25%),
                radial-gradient(circle at 75% 75%, rgba(255, 100, 255, 0.1) 0%, transparent 25%);
            animation: aurora-dance 15s ease-in-out infinite alternate;
            z-index: -1;
        }
        
        @keyframes nebula-drift {
            from { transform: translateX(-20px) translateY(-10px); }
            to { transform: translateX(20px) translateY(10px); }
        }
        
        @keyframes stars-twinkle {
            0%, 100% { opacity: 0.8; }
            50% { opacity: 1; }
        }
        
        @keyframes cosmic-rotation {
            from { transform: rotate(0deg) scale(1); }
            to { transform: rotate(360deg) scale(1.1); }
        }
        
        @keyframes aurora-dance {
            0% { opacity: 0.3; transform: skewX(-5deg); }
            50% { opacity: 0.7; transform: skewX(5deg); }
            100% { opacity: 0.3; transform: skewX(-5deg); }
        }
        
        #startScreen h2 {
            font-size: 48px;
            margin-bottom: 30px;
            color: #64FFDA;
            text-shadow: 
                0 0 10px rgba(100, 255, 218, 0.8),
                0 0 20px rgba(100, 255, 218, 0.6),
                0 0 40px rgba(100, 255, 218, 0.4),
                0 0 80px rgba(100, 255, 218, 0.2);
            font-weight: bold;
            text-align: center;
            animation: title-glow 3s ease-in-out infinite alternate;
            background: linear-gradient(45deg, #64FFDA, #A0FFE6, #64FFDA);
            background-size: 300% 300%;
            -webkit-background-clip: text;
            background-clip: text;
            -webkit-text-fill-color: transparent;
            animation: title-glow 3s ease-in-out infinite alternate, gradient-shift 4s ease-in-out infinite;
        }
        
        @keyframes title-glow {
            0% { 
                text-shadow: 
                    0 0 10px rgba(100, 255, 218, 0.8),
                    0 0 20px rgba(100, 255, 218, 0.6),
                    0 0 40px rgba(100, 255, 218, 0.4);
            }
            100% { 
                text-shadow: 
                    0 0 20px rgba(100, 255, 218, 1),
                    0 0 30px rgba(100, 255, 218, 0.8),
                    0 0 60px rgba(100, 255, 218, 0.6);
            }
        }
        
        @keyframes gradient-shift {
            0% { background-position: 0% 50%; }
            50% { background-position: 100% 50%; }
            100% { background-position: 0% 50%; }
        }
        
        #startScreen p {
            margin-bottom: 40px;
            max-width: 700px;
            line-height: 1.8;
            font-size: 20px;
            text-align: center;
            color: rgba(255, 255, 255, 0.9);
            text-shadow: 
                0 0 10px rgba(100, 255, 218, 0.3),
                0 2px 4px rgba(0, 0, 0, 0.5);
            animation: text-fade-in 2s ease-out forwards;
            opacity: 0;
            transform: translateY(20px);
        }
        
        @keyframes text-fade-in {
            to {
                opacity: 1;
                transform: translateY(0);
            }
        }
        
        #startGameBtn {
            background: linear-gradient(135deg, #64FFDA, #00D0B6, #64FFDA);
            background-size: 300% 300%;
            color: #0A0B2F;
            font-size: 1.4rem;
            font-weight: bold;
            padding: 18px 50px;
            border-radius: 50px;
            border: 3px solid rgba(100, 255, 218, 0.4);
            box-shadow: 
                0 0 30px rgba(100, 255, 218, 0.6),
                0 0 60px rgba(100, 255, 218, 0.3),
                inset 0 2px 10px rgba(255, 255, 255, 0.3);
            transition: all 0.4s cubic-bezier(0.175, 0.885, 0.32, 1.275);
            position: relative;
            overflow: hidden;
            animation: button-fade-in 1.5s ease-out forwards, button-gradient-shift 3s ease-in-out infinite;
            opacity: 0;
            transform: translateY(30px);
            text-shadow: 0 2px 4px rgba(0, 0, 0, 0.3);
            display: flex;
            align-items: center;
            justify-content: center;
            line-height: 1;
            text-align: center;
            min-height: 60px;
            box-sizing: border-box;
        }
        
        #startGameBtn::before {
            content: '';
            position: absolute;
            top: -50%;
            left: -50%;
            width: 200%;
            height: 200%;
            background: linear-gradient(45deg, 
                transparent, 
                rgba(255, 255, 255, 0.1), 
                transparent);
            transform: rotate(45deg);
            transition: all 0.5s;
            opacity: 0;
        }
        
        #startGameBtn:hover {
            transform: translateY(-8px) scale(1.08);
            border-color: rgba(100, 255, 218, 0.8);
            box-shadow: 
                0 0 40px rgba(100, 255, 218, 0.8),
                0 15px 35px rgba(100, 255, 218, 0.4),
                0 0 80px rgba(100, 255, 218, 0.2),
                inset 0 2px 15px rgba(255, 255, 255, 0.4);
            background-position: 100% 0;
        }
        
        #startGameBtn:hover::before {
            opacity: 1;
            left: 100%;
        }
        
        #startGameBtn:active {
            transform: translateY(-5px) scale(1.05);
            transition: all 0.1s;
        }
        
        @keyframes button-fade-in {
            to {
                opacity: 1;
                transform: translateY(0);
            }
        }
        
        @keyframes button-gradient-shift {
            0%, 100% { background-position: 0% 50%; }
            50% { background-position: 100% 50%; }
        }
        
        #resultScreen {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: radial-gradient(ellipse at center, rgba(20, 30, 70, 0.95), rgba(10, 11, 47, 0.98));
            display: none;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            z-index: 100;
            overflow-y: auto;
        }
        
        #resultScreen:before {
            content: '';
            position: absolute;
            width: 200%;
            height: 200%;
            top: -50%;
            left: -50%;
            background-image: 
                radial-gradient(circle, white 1px, transparent 1px),
                radial-gradient(circle, white 1px, transparent 1px),
                radial-gradient(circle, rgba(255, 255, 255, 0.7) 1px, transparent 1px);
            background-size: 100px 100px, 150px 150px, 70px 70px;
            background-position: 0 0, 40px 40px, 20px 20px;
            animation: stars-animation 100s linear infinite;
            opacity: 0.2;
            z-index: -1;
        }
        
        #resultScreen h2 {
            font-size: 36px;
            margin-bottom: 20px;
            color: #64FFDA;
            text-shadow: 0 0 15px rgba(100, 255, 218, 0.5);
        }
        
        #resultScreen p {
            margin-bottom: 10px;
            font-size: 20px;
        }
        
        #finalScore {
            font-size: 64px;
            font-weight: bold;
            color: #FFD700;
            margin: 30px 0 15px;
            text-shadow: 0 0 20px rgba(255, 215, 0, 0.6);
        }
        
        /* 成就系統相關樣式 */
        .achievement-badge {
            display: inline-flex;
            align-items: center;
            justify-content: center;
            width: 60px;
            height: 60px;
            border-radius: 50%;
            background: linear-gradient(135deg, rgba(0, 0, 0, 0.4), rgba(20, 20, 50, 0.6));
            margin: 5px;
            position: relative;
            border: 2px solid rgba(100, 255, 218, 0.4);
            box-shadow: 0 0 10px rgba(100, 255, 218, 0.3);
            transition: all 0.3s ease;
            opacity: 0.6;
        }
        
        .achievement-badge.unlocked {
            background: linear-gradient(135deg, rgba(100, 255, 218, 0.2), rgba(20, 80, 100, 0.3));
            border: 2px solid rgba(100, 255, 218, 0.8);
            box-shadow: 0 0 15px rgba(100, 255, 218, 0.5);
            opacity: 1;
            transform: scale(1.05);
        }
        
        .achievement-badge.new-unlock {
            animation: badge-pulse 1.5s infinite alternate;
        }
        
        @keyframes badge-pulse {
            0% { transform: scale(1.05); box-shadow: 0 0 15px rgba(100, 255, 218, 0.5); }
            100% { transform: scale(1.15); box-shadow: 0 0 25px rgba(100, 255, 218, 0.8); }
        }
        
        .achievement-badge .icon {
            font-size: 28px;
            color: #FFD700;
            text-shadow: 0 0 10px rgba(255, 215, 0, 0.6);
        }
        
        .achievement-badge.locked .icon {
            color: rgba(255, 255, 255, 0.4);
            text-shadow: none;
        }
        
        .achievement-container {
            display: flex;
            flex-wrap: wrap;
            justify-content: center;
            gap: 10px;
            margin: 15px 0;
        }
        
        .achievement-tooltip {
            position: absolute;
            bottom: -45px;
            left: 50%;
            transform: translateX(-50%);
            background: linear-gradient(135deg, rgba(0, 0, 0, 0.9), rgba(20, 20, 50, 0.9));
            padding: 5px 10px;
            border-radius: 10px;
            font-size: 12px;
            white-space: nowrap;
            z-index: 100;
            pointer-events: none;
            opacity: 0;
            transition: opacity 0.3s;
            border: 1px solid rgba(100, 255, 218, 0.3);
        }
        
        .achievement-badge:hover .achievement-tooltip {
            opacity: 1;
        }
        
        .achievement-popup {
            position: fixed;
            top: 15%;
            right: 10px;
            transform: translateX(100%) scale(0.5);
            background: linear-gradient(135deg, rgba(0, 0, 0, 0.7), rgba(20, 20, 80, 0.8));
            padding: 10px 15px;
            border-radius: 12px;
            z-index: 1000;
            text-align: center;
            border: 1px solid rgba(100, 255, 218, 0.4);
            box-shadow: 0 0 20px rgba(100, 255, 218, 0.3);
            pointer-events: none;
            opacity: 0;
            transition: all 0.4s cubic-bezier(0.175, 0.885, 0.32, 1.275);
            max-width: 200px;
        }
        
        .achievement-popup.show {
            opacity: 0.9;
            transform: translateX(0) scale(1);
        }
        
        .achievement-popup-title {
            font-size: 16px;
            color: #FFD700;
            margin-bottom: 5px;
            font-weight: bold;
            text-shadow: 0 0 10px rgba(255, 215, 0, 0.5);
        }
        
        .achievement-popup-desc {
            font-size: 12px;
            margin-bottom: 5px;
        }
        
        .achievement-icon-large {
            font-size: 28px;
            margin: 5px 0;
            color: #FFD700;
            text-shadow: 0 0 15px rgba(255, 215, 0, 0.7);
            animation: achievement-spin 1.5s ease-out;
        }
        
        @keyframes achievement-spin {
            0% { transform: scale(0.5) rotate(-30deg); opacity: 0; }
            100% { transform: scale(1) rotate(0); opacity: 1; }
        }
        
        #achievementsSummary {
            margin-top: 20px;
            background: linear-gradient(135deg, rgba(20, 20, 80, 0.3), rgba(20, 20, 50, 0.2));
            border-radius: 10px;
            padding: 15px;
            border: 1px solid rgba(100, 255, 218, 0.2);
            max-width: 500px;
            margin-left: auto;
            margin-right: auto;
        }
        
        #achievementsSummary h3 {
            font-size: 22px;
            color: #64FFDA;
            margin-bottom: 15px;
            text-shadow: 0 0 10px rgba(100, 255, 218, 0.4);
        }
        
        #playAgainBtn {
            background: linear-gradient(135deg, #64FFDA, #00D0B6);
            color: #0A0B2F;
            font-size: 1.3rem;
            font-weight: bold;
            padding: 15px 40px;
            border-radius: 50px;
            margin-top: 30px;
            box-shadow: 0 0 20px rgba(100, 255, 218, 0.5);
            transition: all 0.3s;
        }
        
        #playAgainBtn:hover {
            transform: translateY(-5px) scale(1.05);
            box-shadow: 0 10px 25px rgba(100, 255, 218, 0.7);
        }
        
        .difficulty-indicator {
            display: inline-block;
            margin-left: 8px;
            font-size: 12px;
            padding: 3px 8px;
            border-radius: 10px;
            background: linear-gradient(135deg, rgba(93, 92, 222, 0.6), rgba(66, 64, 179, 0.6));
            border: 1px solid rgba(255, 255, 255, 0.1);
        }
        
        .settings-row {
            margin-top: 30px;
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 20px;
            animation: settings-fade-in 2s ease-out forwards;
            opacity: 0;
            transform: translateY(20px);
        }
        
        .sound-toggle {
            display: flex;
            align-items: center;
            cursor: pointer;
            user-select: none;
            background: linear-gradient(135deg, rgba(255, 255, 255, 0.1), rgba(160, 255, 230, 0.1));
            padding: 12px 20px;
            border-radius: 25px;
            border: 1px solid rgba(160, 255, 230, 0.3);
            transition: all 0.3s;
            backdrop-filter: blur(5px);
            box-shadow: 0 4px 15px rgba(0, 0, 0, 0.1);
        }
        
        .sound-toggle:hover {
            background: linear-gradient(135deg, rgba(255, 255, 255, 0.2), rgba(160, 255, 230, 0.2));
            border-color: rgba(160, 255, 230, 0.5);
            transform: translateY(-2px);
            box-shadow: 0 6px 20px rgba(160, 255, 230, 0.2);
        }
        
        .sound-toggle input {
            margin-right: 10px;
            transform: scale(1.2);
            accent-color: #64FFDA;
        }
        
        .sound-toggle span {
            font-size: 16px;
            font-weight: 500;
            color: rgba(255, 255, 255, 0.9);
            text-shadow: 0 0 5px rgba(255, 255, 255, 0.3);
        }
        
        @keyframes settings-fade-in {
            to {
                opacity: 1;
                transform: translateY(0);
            }
        }
        
        /* Hero text styles */
        .hero-text {
            animation: text-fade-in 1.5s ease-out forwards;
            opacity: 0;
            transform: translateY(20px);
        }
        
        .main-tagline {
            font-size: 28px !important;
            font-weight: bold;
            margin-bottom: 15px !important;
            background: linear-gradient(45deg, #FFD700, #FFA500, #FFD700);
            background-size: 200% 200%;
            -webkit-background-clip: text;
            background-clip: text;
            -webkit-text-fill-color: transparent;
            animation: tagline-shimmer 3s ease-in-out infinite;
            text-shadow: none;
        }
        
        .sub-tagline {
            font-size: 18px !important;
            margin-bottom: 25px !important;
            color: rgba(255, 255, 255, 0.8);
            font-style: italic;
        }
        
        @keyframes tagline-shimmer {
            0%, 100% { background-position: 0% 50%; }
            50% { background-position: 100% 50%; }
        }
        
        /* How to Play button */
        .how-to-play-btn {
            background: linear-gradient(135deg, rgba(93, 92, 222, 0.15), rgba(66, 64, 179, 0.2));
            border: 2px solid rgba(100, 255, 218, 0.3);
            color: rgba(255, 255, 255, 0.9);
            padding: 12px 25px;
            border-radius: 25px;
            cursor: pointer;
            transition: all 0.3s ease;
            font-size: 16px;
            font-weight: 500;
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 8px;
            margin: 0 auto 20px;
            backdrop-filter: blur(10px);
            box-shadow: 0 4px 15px rgba(0, 0, 0, 0.2);
            min-width: 200px;
            animation: how-to-play-fade-in 2.5s ease-out forwards;
            opacity: 0;
            transform: translateY(20px);
        }
        
        .how-to-play-btn:hover {
            background: linear-gradient(135deg, rgba(93, 92, 222, 0.25), rgba(66, 64, 179, 0.3));
            border-color: rgba(100, 255, 218, 0.6);
            transform: translateY(-2px) scale(1.02);
            box-shadow: 0 8px 25px rgba(100, 255, 218, 0.3);
        }
        
        .how-to-play-btn .btn-icon {
            font-size: 18px;
        }
        
        .how-to-play-btn .btn-arrow {
            transition: transform 0.3s ease;
            font-size: 14px;
        }
        
        .how-to-play-btn:hover .btn-arrow {
            transform: translateY(2px);
        }
        
        @keyframes how-to-play-fade-in {
            to {
                opacity: 1;
                transform: translateY(0);
            }
        }
        
        /* Game instructions panel */
        .game-instructions {
            max-width: 600px;
            margin: 0 auto 30px;
            opacity: 0;
            max-height: 0;
            overflow: hidden;
            transition: all 0.5s ease;
            position: relative;
            z-index: 200;
        }
        
        .game-instructions.show {
            opacity: 1;
            max-height: 70vh;
            margin-bottom: 30px;
            overflow-y: auto;
        }
        
        .instruction-content {
            background: linear-gradient(135deg, rgba(20, 30, 70, 0.95), rgba(40, 20, 80, 0.95));
            border-radius: 15px;
            padding: 25px;
            border: 1px solid rgba(100, 255, 218, 0.2);
            backdrop-filter: blur(10px);
            box-shadow: 0 8px 32px rgba(0, 0, 0, 0.3);
            position: relative;
            max-height: 100%;
            overflow-y: auto;
        }
        
        .instruction-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 20px;
        }
        
        .close-instruction-btn {
            background: rgba(255, 100, 100, 0.2);
            color: #FF6464;
            border: 1px solid rgba(255, 100, 100, 0.3);
            border-radius: 50%;
            width: 30px;
            height: 30px;
            display: flex;
            align-items: center;
            justify-content: center;
            cursor: pointer;
            font-size: 16px;
            font-weight: bold;
            transition: all 0.3s ease;
            line-height: 1;
            padding: 0;
        }
        
        .close-instruction-btn:hover {
            background: rgba(255, 100, 100, 0.4);
            border-color: rgba(255, 100, 100, 0.6);
            transform: scale(1.1);
        }
        
        .instruction-footer {
            text-align: center;
            margin-top: 25px;
            padding-top: 20px;
            border-top: 1px solid rgba(100, 255, 218, 0.2);
        }
        
        .got-it-btn {
            background: linear-gradient(135deg, #64FFDA, #00D0B6);
            color: #0A0B2F;
            border: none;
            padding: 12px 30px;
            border-radius: 25px;
            cursor: pointer;
            font-size: 16px;
            font-weight: bold;
            transition: all 0.3s ease;
            box-shadow: 0 4px 15px rgba(100, 255, 218, 0.4);
        }
        
        .got-it-btn:hover {
            background: linear-gradient(135deg, #7AFFDF, #00E0C6);
            transform: translateY(-2px) scale(1.05);
            box-shadow: 0 8px 25px rgba(100, 255, 218, 0.6);
        }
        
        .instruction-content h3 {
            color: #64FFDA;
            font-size: 20px;
            margin-bottom: 12px;
            margin-top: 20px;
            text-shadow: 0 0 10px rgba(100, 255, 218, 0.4);
        }
        
        .instruction-content h3:first-child {
            margin-top: 0;
        }
        
        .instruction-content p {
            font-size: 16px;
            line-height: 1.6;
            margin-bottom: 15px;
            color: rgba(255, 255, 255, 0.9);
        }
        
        .instruction-content ul {
            list-style: none;
            padding-left: 0;
            margin-bottom: 15px;
        }
        
        .instruction-content li {
            padding: 8px 0;
            font-size: 15px;
            line-height: 1.5;
            color: rgba(255, 255, 255, 0.85);
            display: flex;
            align-items: flex-start;
            gap: 8px;
        }
        
        .instruction-content li::before {
            content: "";
            width: 6px;
            height: 6px;
            background: #64FFDA;
            border-radius: 50%;
            margin-top: 8px;
            flex-shrink: 0;
            box-shadow: 0 0 6px rgba(100, 255, 218, 0.6);
        }
        
        /* Star */
        .star {
            position: absolute;
            border-radius: 50%;
            background-color: rgba(255, 255, 255, 0.8);
            box-shadow: 0 0 10px rgba(255, 255, 255, 0.8),
                        0 0 20px rgba(255, 255, 255, 0.5);
            pointer-events: none;
        }
        
        .star-glow {
            position: absolute;
            border-radius: 50%;
            background: radial-gradient(circle, rgba(255, 255, 255, 0.8) 0%, rgba(255, 255, 255, 0) 70%);
            pointer-events: none;
            opacity: 0;
            animation: star-pulse 2s infinite alternate;
        }
        
        @keyframes star-pulse {
            0% { opacity: 0.1; transform: scale(0.8); }
            100% { opacity: 0.5; transform: scale(1.2); }
        }
        
        /* Line effect */
        .constellation-line {
            position: absolute;
            background: linear-gradient(90deg, 
                rgba(100, 255, 218, 0) 0%, 
                rgba(100, 255, 218, 0.8) 50%, 
                rgba(100, 255, 218, 0) 100%);
            height: 2px;
            transform-origin: left center;
            pointer-events: none;
            opacity: 0;
            animation: line-appear 0.5s forwards;
        }
        
        @keyframes line-appear {
            from { opacity: 0; }
            to { opacity: 1; }
        }
        
        /* Particles */
        .particle {
            position: absolute;
            background-color: rgba(100, 255, 218, 0.8);
            border-radius: 50%;
            pointer-events: none;
        }
        
        /* Floating stars background */
        .bg-stars {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            pointer-events: none;
            z-index: -1;
            overflow: hidden;
        }
        
        .bg-star {
            position: absolute;
            background-color: white;
            border-radius: 50%;
            animation: twinkle 4s infinite alternate;
        }
        
        @keyframes twinkle {
            0% { opacity: 0.3; }
            50% { opacity: 1; }
            100% { opacity: 0.3; }
        }
        
        .shooting-star {
            position: absolute;
            width: 2px;
            height: 2px;
            background: linear-gradient(to right, 
                rgba(255, 255, 255, 0) 0%, 
                rgba(255, 255, 255, 0.8) 50%, 
                rgba(255, 255, 255, 0) 100%);
            transform: rotate(-45deg);
            animation: shooting 3s linear forwards;
            box-shadow: 0 0 3px rgba(255, 255, 255, 0.3);
            pointer-events: none;
        }
        
        @keyframes shooting {
            from {
                transform: translateX(0) translateY(0) rotate(-45deg) scale(1);
                opacity: 1;
            }
            to {
                transform: translateX(500px) translateY(500px) rotate(-45deg) scale(0.1);
                opacity: 0;
            }
        }
        
        @media (max-width: 500px) {
            button {
                padding: 8px 12px;
                font-size: 0.8rem;
            }
            
            #checkBtn {
                padding: 10px 20px;
                font-size: 1rem;
            }
            
            .score-container, .timer-container {
                padding: 3px 10px;
            }
            
            #timerDisplay {
                font-size: 16px;
            }
            
            h1 {
                font-size: 22px;
            }
            
            #task {
                font-size: 16px;
            }
            
            #startScreen h2, #resultScreen h2 {
                font-size: 28px;
            }
            
            #finalScore {
                font-size: 48px;
            }
        }
    </style>
</head>
<body>
    <div class="bg-stars" id="bgStars"></div>
    
    <div id="startScreen">
        <h2>Stellar Explorer - Time Challenge Mode</h2>
        <div class="hero-text">
            <p class="main-tagline">🌟 Connect the Stars, Master Geometry! 🌟</p>
            <p class="sub-tagline">Race against time in this cosmic adventure</p>
            <button id="howToPlayBtn" class="how-to-play-btn">
                <span class="btn-icon">📚</span>
                How to Play
                <span class="btn-arrow">↓</span>
            </button>
            <div id="gameInstructions" class="game-instructions">
                <div class="instruction-content">
                    <div class="instruction-header">
                        <h3 style="margin-top: 0; margin-bottom: 0; display: inline-block;">📚 How to Play</h3>
                        <button class="close-instruction-btn" onclick="toggleInstructions()">✕</button>
                    </div>
                    
                    <h3>🎯 Your Mission</h3>
                    <p>Complete as many constellation geometry challenges as possible in <strong>60 seconds</strong>!</p>
                    
                    <h3>🎮 How to Play</h3>
                    <ul>
                        <li>🔗 <strong>Connect the stars</strong> by clicking on them to form lines</li>
                        <li>📐 <strong>Create geometric shapes</strong> like triangles, squares, rectangles</li>
                        <li>✨ <strong>Match the required pattern</strong> shown in the challenge</li>
                        <li>⚡ <strong>Complete quickly</strong> to build up your streak bonus!</li>
                    </ul>
                    
                    <h3>💡 Tips</h3>
                    <ul>
                        <li>🎯 Use <strong>Visual Hint</strong> to see where to connect</li>
                        <li>📖 Use <strong>Text Hint</strong> for geometry reminders</li>
                        <li>🔄 Use <strong>Reset</strong> to start over on a challenge</li>
                        <li>🏆 Build streaks for bonus points!</li>
                    </ul>
                    
                    <div class="instruction-footer">
                        <button class="got-it-btn" onclick="toggleInstructions()">
                            Got it! Let's Play 🚀
                        </button>
                    </div>
                </div>
            </div>
        </div>
        
        <div class="shape-selector">
            <p>Choose Constellation Type:</p>
            <div class="shape-options">
                <label class="shape-option">
                    <input type="radio" name="shapeType" value="triangles" checked>
                    <span class="shape-name">Triangle Constellations Only</span>
                </label>
                <label class="shape-option">
                    <input type="radio" name="shapeType" value="quadrilaterals">
                    <span class="shape-name">Quadrilateral Constellations Only</span>
                </label>
                <label class="shape-option">
                    <input type="radio" name="shapeType" value="all">
                    <span class="shape-name">All Constellation Shapes</span>
                </label>
            </div>
        </div>
        
        <div class="settings-row">
            <label class="sound-toggle">
                <input type="checkbox" id="soundToggle" checked>
                Stellar Sound Effects
            </label>
        </div>
        <button id="startGameBtn">Begin Your Journey</button>
    </div>

    <div id="resultScreen">
        <h2>Stellar Exploration Complete!</h2>
        <p>You completed in 1 minute:</p>
        <div id="finalScore">0 Constellations</div>
        <p>Total Score: <span id="finalTotalScore">0</span></p>
        
        <div id="achievementsSummary">
            <h3>Unlocked Stellar Explorer Badges</h3>
            <div id="achievementsContainer" class="achievement-container"></div>
        </div>
        
        <button id="playAgainBtn">Explore Again</button>
    </div>
    
    <div id="achievementPopup" class="achievement-popup">
        <div class="achievement-icon-large">✨</div>
        <div class="achievement-popup-title">Achievement Unlocked!</div>
        <div class="achievement-popup-desc">You earned a new badge</div>
    </div>

    <h1>Stellar Explorer - Constellation Geometry Learning</h1>
    
    <div id="task">Please connect the stars to form an isosceles triangle constellation</div>
    
    <div style="position: relative;">
        <div class="timer-container">
            <div id="timerDisplay">01:00</div>
        </div>
        <div class="score-container">
            <span id="scoreDisplay">Score: 0</span>
            <span id="streakDisplay">Streak: 0</span>
            <span id="solvedDisplay">Solved: 0</span>
            <span id="difficultyDisplay">Difficulty: Normal</span>
        </div>
        <canvas id="gameCanvas" width="450" height="450"></canvas>
        <div id="tooltip" class="tooltip">Click this star to start connecting</div>
    </div>
    
    <div id="controls">
        <button id="resetBtn" class="secondary-btn">Reset Stars</button>
        <button id="checkBtn">Check Constellation</button>
        <button id="hintTextBtn" class="secondary-btn">Text Hint</button>
        <button id="hintVisualBtn" class="secondary-btn">Visual Hint</button>
    </div>
    
    <div id="info">
        <p id="shapeInfo">Connect the shining stars to form the specified triangle constellation type</p>
        <p id="status">Connected: 0 lines (need to connect 2 lines)</p>
        <div id="hintBox"></div>
        <div id="resultMessage" class="result-message" style="display: none;"></div>
    </div>
    
    <script>
        // 獲取Canvas元素和上下文
        const canvas = document.getElementById('gameCanvas');
        const ctx = canvas.getContext('2d');
        const tooltip = document.getElementById('tooltip');
        const hintBox = document.getElementById('hintBox');
        const resultMessage = document.getElementById('resultMessage');
        const startScreen = document.getElementById('startScreen');
        const resultScreen = document.getElementById('resultScreen');
        const timerDisplay = document.getElementById('timerDisplay');
        const difficultyDisplay = document.getElementById('difficultyDisplay');
        const soundToggle = document.getElementById('soundToggle');
        const shapeInfo = document.getElementById('shapeInfo');
        const bgStars = document.getElementById('bgStars');
        
        // 背景星星生成
        function createBackgroundStars() {
            const starCount = Math.floor(window.innerWidth * window.innerHeight / 1000);
            bgStars.innerHTML = '';
            
            for (let i = 0; i < starCount; i++) {
                const star = document.createElement('div');
                star.className = 'bg-star';
                star.style.left = `${Math.random() * 100}%`;
                star.style.top = `${Math.random() * 100}%`;
                
                const size = Math.random() * 2;
                star.style.width = `${size}px`;
                star.style.height = `${size}px`;
                
                // 不同的閃爍時間
                star.style.animationDelay = `${Math.random() * 4}s`;
                star.style.animationDuration = `${2 + Math.random() * 3}s`;
                
                // 不同的亮度
                star.style.opacity = 0.3 + Math.random() * 0.7;
                
                bgStars.appendChild(star);
            }
            
            // 添加流星
            createShootingStar();
        }
        
        // 流星效果
        function createShootingStar() {
            if (!document.body.contains(bgStars)) return;
            
            const star = document.createElement('div');
            star.className = 'shooting-star';
            
            // 隨機位置和大小
            star.style.left = `${Math.random() * 30}%`;
            star.style.top = `${Math.random() * 20}%`;
            star.style.width = `${80 + Math.random() * 120}px`;
            
            bgStars.appendChild(star);
            
            // 動畫結束後移除
            setTimeout(() => {
                if (star.parentNode) {
                    star.parentNode.removeChild(star);
                }
                // 隨機時間後再次出現
                setTimeout(createShootingStar, 5000 + Math.random() * 15000);
            }, 3000);
        }
        
        // 遊戲設置
        let selectedShapeType = "triangles"; // 默認為三角形
        let debugMode = false; // 可在控制台設為true以顯示更多信息
        let lenientMode = true; // 較寬鬆的形狀檢測，因為我們不應該太嚴格
        
        // 音效系統 - 使用Web Audio API合成音效
        let audioContext;
        
        // 背景音樂系統
        let ambientMusicNodes = [];
        let isMusicPlaying = false;
        let musicGainNode;
        
        // 特效參數
        let stars = [];
        let particles = [];
        let constellationLines = [];
        
        // 初始化音效系統
        function initAudio() {
            try {
                audioContext = new (window.AudioContext || window.webkitAudioContext)();
                
                // 創建音樂總音量控制
                musicGainNode = audioContext.createGain();
                musicGainNode.connect(audioContext.destination);
                musicGainNode.gain.setValueAtTime(0.15, audioContext.currentTime); // 設定較低的背景音樂音量
                
            } catch(e) {
                console.warn('Web Audio API not supported:', e);
            }
        }
        
        // 創建星空環境音樂系統
        function createAmbientMusic() {
            if (!audioContext || !soundToggle.checked || isMusicPlaying) return;
            
            try {
                isMusicPlaying = true;
                
                // 清除之前的音樂節點
                stopAmbientMusic();
                
                // 層1: 深空基調 - 低頻嗡嗡聲
                createDeepSpaceDrone();
                
                // 層2: 星星閃爍音效
                createStarTwinkles();
                
                // 層3: 宇宙風聲
                createCosmicWind();
                
                // 層4: 偶爾的和弦
                createMysticalChords();
                
                console.log('🌌 星空環境音樂已啟動');
                
            } catch(e) {
                console.warn('Error creating ambient music:', e);
                isMusicPlaying = false;
            }
        }
        
        // 深空基調 - 持續的低頻嗡嗡聲
        function createDeepSpaceDrone() {
            const drone = audioContext.createOscillator();
            const droneGain = audioContext.createGain();
            
            drone.type = 'sine';
            drone.frequency.setValueAtTime(60, audioContext.currentTime); // 低頻 60Hz
            
            // 緩慢的頻率變化，營造漂移感
            drone.frequency.linearRampToValueAtTime(65, audioContext.currentTime + 20);
            drone.frequency.linearRampToValueAtTime(55, audioContext.currentTime + 40);
            drone.frequency.linearRampToValueAtTime(60, audioContext.currentTime + 60);
            
            droneGain.gain.setValueAtTime(0, audioContext.currentTime);
            droneGain.gain.linearRampToValueAtTime(0.3, audioContext.currentTime + 3); // 緩慢淡入
            
            drone.connect(droneGain);
            droneGain.connect(musicGainNode);
            
            drone.start();
            
            // 60秒後重新創建，形成循環
            setTimeout(() => {
                try {
                    drone.stop();
                    if (isMusicPlaying) createDeepSpaceDrone();
                } catch(e) {
                    console.warn('Error in drone recreation:', e);
                }
            }, 60000);
            
            ambientMusicNodes.push(drone);
        }
        
        // 星星閃爍音效 - 高頻隨機ping聲
        function createStarTwinkles() {
            const createTwinkle = () => {
                if (!isMusicPlaying) return;
                
                const osc = audioContext.createOscillator();
                const gain = audioContext.createGain();
                
                // 隨機頻率，模擬不同亮度的星星
                const frequency = 800 + Math.random() * 1200; // 800-2000Hz
                osc.frequency.setValueAtTime(frequency, audioContext.currentTime);
                osc.type = 'sine';
                
                // 快速衰減，模擬閃爍
                gain.gain.setValueAtTime(0, audioContext.currentTime);
                gain.gain.linearRampToValueAtTime(0.05, audioContext.currentTime + 0.1);
                gain.gain.exponentialRampToValueAtTime(0.001, audioContext.currentTime + 0.8);
                
                osc.connect(gain);
                gain.connect(musicGainNode);
                
                osc.start();
                osc.stop(audioContext.currentTime + 1);
                
                // 隨機間隔再次閃爍 (2-6秒)
                setTimeout(createTwinkle, 2000 + Math.random() * 4000);
            };
            
            // 延遲3秒開始，讓基調先建立
            setTimeout(createTwinkle, 3000);
        }
        
        // 宇宙風聲 - 白噪音混合
        function createCosmicWind() {
            const bufferSize = audioContext.sampleRate * 2; // 2秒的白噪音
            const buffer = audioContext.createBuffer(1, bufferSize, audioContext.sampleRate);
            const data = buffer.getChannelData(0);
            
            // 生成白噪音
            for (let i = 0; i < bufferSize; i++) {
                data[i] = (Math.random() * 2 - 1) * 0.3; // 較輕的噪音
            }
            
            const playWind = () => {
                if (!isMusicPlaying) return;
                
                const source = audioContext.createBufferSource();
                const filter = audioContext.createBiquadFilter();
                const windGain = audioContext.createGain();
                
                source.buffer = buffer;
                source.loop = true;
                
                // 低通濾波器，只留低頻成分
                filter.type = 'lowpass';
                filter.frequency.setValueAtTime(200, audioContext.currentTime);
                filter.Q.setValueAtTime(1, audioContext.currentTime);
                
                // 緩慢的音量變化
                windGain.gain.setValueAtTime(0, audioContext.currentTime);
                windGain.gain.linearRampToValueAtTime(0.15, audioContext.currentTime + 5);
                windGain.gain.linearRampToValueAtTime(0.05, audioContext.currentTime + 25);
                windGain.gain.linearRampToValueAtTime(0.15, audioContext.currentTime + 45);
                
                source.connect(filter);
                filter.connect(windGain);
                windGain.connect(musicGainNode);
                
                source.start();
                
                // 50秒後重新開始
                setTimeout(() => {
                    try {
                        source.stop();
                        if (isMusicPlaying) playWind();
                    } catch(e) {
                        console.warn('Error in wind recreation:', e);
                    }
                }, 50000);
                
                ambientMusicNodes.push(source);
            };
            
            // 延遲5秒開始
            setTimeout(playWind, 5000);
        }
        
        // 神秘和弦 - 偶爾出現的和諧音
        function createMysticalChords() {
            const playChord = () => {
                if (!isMusicPlaying) return;
                
                // C大調的神秘和弦組合
                const chordFrequencies = [
                    [261.63, 329.63, 392.00], // C - E - G
                    [293.66, 369.99, 440.00], // D - F# - A
                    [246.94, 311.13, 369.99], // B - D# - F#
                    [220.00, 277.18, 329.63]  // A - C# - E
                ];
                
                const chord = chordFrequencies[Math.floor(Math.random() * chordFrequencies.length)];
                const chordNodes = [];
                
                chord.forEach((freq, index) => {
                    const osc = audioContext.createOscillator();
                    const gain = audioContext.createGain();
                    
                    osc.type = 'triangle'; // 較柔和的音色
                    osc.frequency.setValueAtTime(freq, audioContext.currentTime);
                    
                    // 錯開淡入時間，創造層次感
                    const fadeInDelay = index * 0.5;
                    gain.gain.setValueAtTime(0, audioContext.currentTime + fadeInDelay);
                    gain.gain.linearRampToValueAtTime(0.03, audioContext.currentTime + fadeInDelay + 2);
                    gain.gain.linearRampToValueAtTime(0.02, audioContext.currentTime + fadeInDelay + 8);
                    gain.gain.exponentialRampToValueAtTime(0.001, audioContext.currentTime + fadeInDelay + 12);
                    
                    osc.connect(gain);
                    gain.connect(musicGainNode);
                    
                    osc.start(audioContext.currentTime + fadeInDelay);
                    osc.stop(audioContext.currentTime + fadeInDelay + 12);
                    
                    chordNodes.push(osc);
                });
                
                // 15-30秒後再次播放
                setTimeout(playChord, 15000 + Math.random() * 15000);
            };
            
            // 延遲10秒開始，給其他層次時間建立
            setTimeout(playChord, 10000);
        }
        
        // 停止環境音樂
        function stopAmbientMusic() {
            isMusicPlaying = false;
            
            // 停止所有音樂節點
            ambientMusicNodes.forEach(node => {
                try {
                    if (node.stop) node.stop();
                    if (node.disconnect) node.disconnect();
                } catch(e) {
                    // 節點可能已經停止，忽略錯誤
                }
            });
            
            ambientMusicNodes = [];
            console.log('🌌 星空環境音樂已停止');
        }
        
        // 淡入背景音樂
        function fadeInAmbientMusic() {
            if (!audioContext || !musicGainNode) return;
            
            musicGainNode.gain.cancelScheduledValues(audioContext.currentTime);
            musicGainNode.gain.setValueAtTime(0, audioContext.currentTime);
            musicGainNode.gain.linearRampToValueAtTime(0.15, audioContext.currentTime + 3);
        }
        
        // 淡出背景音樂
        function fadeOutAmbientMusic() {
            if (!audioContext || !musicGainNode) return;
            
            musicGainNode.gain.cancelScheduledValues(audioContext.currentTime);
            musicGainNode.gain.linearRampToValueAtTime(0, audioContext.currentTime + 2);
            
            setTimeout(() => {
                stopAmbientMusic();
            }, 2500);
        }
        
        // 播放音效
        function playSound(type) {
            if (!audioContext || !soundToggle.checked) return;
            
            try {
                // 建立音效節點
                const oscillator = audioContext.createOscillator();
                const gainNode = audioContext.createGain();
                
                // 連接節點
                oscillator.connect(gainNode);
                gainNode.connect(audioContext.destination);
                
                // 設置不同類型的音效參數
                switch(type) {
                    case 'correct':
                        // 正確音效 - 上升音
                        oscillator.type = 'sine';
                        oscillator.frequency.setValueAtTime(523.25, audioContext.currentTime);  // C5
                        oscillator.frequency.linearRampToValueAtTime(783.99, audioContext.currentTime + 0.15); // G5
                        gainNode.gain.setValueAtTime(0.3, audioContext.currentTime);
                        gainNode.gain.exponentialRampToValueAtTime(0.01, audioContext.currentTime + 0.3);
                        oscillator.start();
                        oscillator.stop(audioContext.currentTime + 0.3);
                        break;
                    
                    case 'wrong':
                        // 錯誤音效 - 下降音
                        oscillator.type = 'square';
                        oscillator.frequency.setValueAtTime(392.00, audioContext.currentTime);  // G4
                        oscillator.frequency.linearRampToValueAtTime(261.63, audioContext.currentTime + 0.2); // C4
                        gainNode.gain.setValueAtTime(0.2, audioContext.currentTime);
                        gainNode.gain.exponentialRampToValueAtTime(0.01, audioContext.currentTime + 0.3);
                        oscillator.start();
                        oscillator.stop(audioContext.currentTime + 0.3);
                        break;
                    
                    case 'connect':
                        // 連接音效 - 短促清脆
                        oscillator.type = 'triangle';
                        oscillator.frequency.setValueAtTime(659.25, audioContext.currentTime); // E5
                        oscillator.frequency.setValueAtTime(783.99, audioContext.currentTime + 0.05); // G5
                        gainNode.gain.setValueAtTime(0.2, audioContext.currentTime);
                        gainNode.gain.exponentialRampToValueAtTime(0.01, audioContext.currentTime + 0.2);
                        oscillator.start();
                        oscillator.stop(audioContext.currentTime + 0.2);
                        break;
                    
                    case 'click':
                        // 點擊音效 - 非常短促
                        oscillator.type = 'sine';
                        oscillator.frequency.setValueAtTime(880.00, audioContext.currentTime); // A5
                        oscillator.frequency.setValueAtTime(987.77, audioContext.currentTime + 0.03); // B5
                        gainNode.gain.setValueAtTime(0.1, audioContext.currentTime);
                        gainNode.gain.exponentialRampToValueAtTime(0.01, audioContext.currentTime + 0.08);
                        oscillator.start();
                        oscillator.stop(audioContext.currentTime + 0.08);
                        break;
                        
                    case 'hint':
                        // 提示音效 - 神秘的三和弦
                        oscillator.type = 'triangle';
                        oscillator.frequency.setValueAtTime(523.25, audioContext.currentTime); // C5
                        oscillator.frequency.setValueAtTime(659.25, audioContext.currentTime + 0.1); // E5
                        oscillator.frequency.setValueAtTime(783.99, audioContext.currentTime + 0.2); // G5
                        gainNode.gain.setValueAtTime(0.15, audioContext.currentTime);
                        gainNode.gain.exponentialRampToValueAtTime(0.01, audioContext.currentTime + 0.4);
                        oscillator.start();
                        oscillator.stop(audioContext.currentTime + 0.4);
                        break;
                }
            } catch(e) {
                console.warn('Error playing sound:', e);
            }
        }
        
        // 網格設置
        const gridSize = 50; // 每個格子的大小
        const numRows = 8;   // 行數
        const numCols = 8;   // 列數
        const offsetX = 25;  // X偏移（使網格從邊緣開始）
        const offsetY = 25;  // Y偏移

        // 遊戲狀態
        let selectedPoint = null;
        let lastMouseX = 0;
        let lastMouseY = 0;
        let isComplete = false;
        let currentLevelIndex = 0;
        let hoveredPoint = null;
        
        // 計分系統
        let score = 0;
        let streak = 0;  // 連勝
        let solvedCount = 0; // 已解題數
        
        // Achievement system
        const achievements = [
            { id: 'novice', level: 1, name: 'Stellar Novice', description: 'Complete your first constellation', icon: '🌟', unlocked: false },
            { id: 'connector', level: 2, name: 'Star Connector', description: 'Complete 2 constellations', icon: '⭐', unlocked: false },
            { id: 'seeker', level: 3, name: 'Constellation Seeker', description: 'Complete 3 constellations', icon: '✨', unlocked: false },
            { id: 'observer', level: 4, name: 'Night Sky Observer', description: 'Complete 4 constellations', icon: '🔭', unlocked: false },
            { id: 'apprentice', level: 5, name: 'Astronomy Apprentice', description: 'Complete 5 constellations', icon: '📚', unlocked: false },
            { id: 'ancient', level: 6, name: 'Ancient Astronomer', description: 'Complete 6 constellations', icon: '🏛️', unlocked: false },
            { id: 'interpreter', level: 7, name: 'Star Chart Interpreter', description: 'Complete 7 constellations', icon: '🧙', unlocked: false },
            { id: 'master', level: 8, name: 'Stellar Explorer Master', description: 'Complete 8 constellations', icon: '👑', unlocked: false }
        ];
        let newUnlocks = [];
        
        // Timer system
        let timeLeft = 60; // 60 seconds
        let timerInterval;
        let isGameActive = false;
        
        // Difficulty system
        let currentDifficulty = "Normal"; // Normal, Hard
        
        // 點的大小
        const pointRadius = 7;
        
        // 用戶連接的線
        let userLines = [];
        
        // 粒子效果相關
        let animationFrameId = null;
        
        // Triangle level definitions
        const triangleLevels = [
            // Equilateral triangle series - precisely calculated grid points
            {
                name: "Equilateral Triangle",
                description: "Please connect the stars to form an equilateral triangle constellation",
                hint: "An equilateral triangle has three equal sides, with each interior angle being 60 degrees.",
                checkFunction: isEquilateralTriangle,
                presetLine: {from: {row: 5, col: 3}, to: {row: 5, col: 5}}, // horizontal line
                solutionPoint: {row: 3, col: 4}, // precise equilateral triangle vertex
                congratsMessage: "Well done! You successfully created an equilateral triangle constellation!",
                requiredLines: 2,
                difficulty: 3,
                type: "triangle"
            },
            {
                name: "Equilateral Triangle",
                description: "Please connect the stars to form an equilateral triangle constellation",
                hint: "An equilateral triangle has three equal sides, with each interior angle being 60 degrees.",
                checkFunction: isEquilateralTriangle,
                presetLine: {from: {row: 3, col: 3}, to: {row: 7, col: 5}}, // diagonal line
                solutionPoint: {row: 5, col: 1}, // precise equilateral triangle vertex
                congratsMessage: "Well done! You successfully created an equilateral triangle constellation!",
                requiredLines: 2,
                difficulty: 3,
                type: "triangle"
            },
            {
                name: "Equilateral Triangle",
                description: "Please connect the stars to form an equilateral triangle constellation",
                hint: "An equilateral triangle has three equal sides, with each interior angle being 60 degrees.",
                checkFunction: isEquilateralTriangle,
                presetLine: {from: {row: 4, col: 2}, to: {row: 4, col: 6}}, // horizontal line
                solutionPoint: {row: 1, col: 4}, // precise equilateral triangle vertex
                congratsMessage: "Well done! You successfully created an equilateral triangle constellation!",
                requiredLines: 2,
                difficulty: 3,
                type: "triangle"
            },
            
            // Isosceles triangle series - multiple preset lines
            {
                name: "Isosceles Triangle",
                description: "Please connect the stars to form an isosceles triangle constellation",
                hint: "An isosceles triangle has two equal sides. Find a point equidistant from both ends of the blue line.",
                checkFunction: isIsoscelesTriangle,
                presetLine: {from: {row: 4, col: 2}, to: {row: 4, col: 6}}, // horizontal line
                solutionPoint: {row: 2, col: 4}, // definite solution
                congratsMessage: "Awesome! You successfully created an isosceles triangle constellation!",
                requiredLines: 2,
                difficulty: 2,
                type: "triangle"
            },
            {
                name: "Isosceles Triangle",
                description: "Please connect the stars to form an isosceles triangle constellation",
                hint: "An isosceles triangle has two equal sides. Find a point equidistant from both ends of the blue line.",
                checkFunction: isIsoscelesTriangle,
                presetLine: {from: {row: 2, col: 2}, to: {row: 6, col: 6}}, // diagonal line
                solutionPoint: {row: 6, col: 2}, // definite solution
                congratsMessage: "Awesome! You successfully created an isosceles triangle constellation!",
                requiredLines: 2,
                difficulty: 2,
                type: "triangle"
            },
            {
                name: "Isosceles Triangle",
                description: "Please connect the stars to form an isosceles triangle constellation",
                hint: "An isosceles triangle has two equal sides. Find a point equidistant from both ends of the blue line.",
                checkFunction: isIsoscelesTriangle,
                presetLine: {from: {row: 3, col: 2}, to: {row: 5, col: 5}}, // diagonal line
                solutionPoint: {row: 2, col: 6}, // definite solution
                congratsMessage: "Awesome! You successfully created an isosceles triangle constellation!",
                requiredLines: 2,
                difficulty: 2,
                type: "triangle"
            },
            
            // Right triangle series - Pythagorean triples
            {
                name: "Right Triangle",
                description: "Please connect the stars to form a right triangle constellation",
                hint: "A right triangle has one 90-degree angle. Find a point that makes two sides perpendicular.",
                checkFunction: isRightTriangle,
                presetLine: {from: {row: 2, col: 2}, to: {row: 2, col: 6}}, // horizontal line
                solutionPoint: {row: 6, col: 6}, // 3:4:5 triple
                congratsMessage: "Excellent! You successfully created a right triangle constellation!",
                requiredLines: 2,
                difficulty: 2,
                type: "triangle"
            },
            {
                name: "Right Triangle",
                description: "Please connect the stars to form a right triangle constellation",
                hint: "A right triangle has one 90-degree angle. Find a point that makes two sides perpendicular.",
                checkFunction: isRightTriangle,
                presetLine: {from: {row: 4, col: 1}, to: {row: 4, col: 5}}, // horizontal line
                solutionPoint: {row: 1, col: 5}, // 3:4:5 triple
                congratsMessage: "Excellent! You successfully created a right triangle constellation!",
                requiredLines: 2,
                difficulty: 2,
                type: "triangle"
            },
            {
                name: "Right Triangle",
                description: "Please connect the stars to form a right triangle constellation",
                hint: "A right triangle has one 90-degree angle. Find a point that makes two sides perpendicular.",
                checkFunction: isRightTriangle,
                presetLine: {from: {row: 3, col: 2}, to: {row: 6, col: 6}}, // diagonal line
                solutionPoint: {row: 7, col: 2}, // 5:12:13 triple variant
                congratsMessage: "Excellent! You successfully created a right triangle constellation!",
                requiredLines: 2,
                difficulty: 2,
                type: "triangle"
            },
            
            // Right isosceles triangle series
            {
                name: "Right Isosceles Triangle",
                description: "Please connect the stars to form a right isosceles triangle constellation",
                hint: "A right isosceles triangle has one 90-degree angle and two equal sides.",
                checkFunction: isRightIsoscelesTriangle,
                presetLine: {from: {row: 3, col: 3}, to: {row: 3, col: 7}}, // horizontal line
                solutionPoint: {row: 7, col: 3}, // perfect right isosceles solution
                congratsMessage: "Fantastic! You successfully created a right isosceles triangle constellation!",
                requiredLines: 2,
                difficulty: 3,
                type: "triangle"
            },
            {
                name: "Right Isosceles Triangle",
                description: "Please connect the stars to form a right isosceles triangle constellation",
                hint: "A right isosceles triangle has one 90-degree angle and two equal sides.",
                checkFunction: isRightIsoscelesTriangle,
                presetLine: {from: {row: 2, col: 2}, to: {row: 6, col: 2}}, // vertical line
                solutionPoint: {row: 6, col: 6}, // perfect right isosceles solution
                congratsMessage: "Fantastic! You successfully created a right isosceles triangle constellation!",
                requiredLines: 2,
                difficulty: 3,
                type: "triangle"
            },
            {
                name: "Right Isosceles Triangle",
                description: "Please connect the stars to form a right isosceles triangle constellation",
                hint: "A right isosceles triangle has one 90-degree angle and two equal sides.",
                checkFunction: isRightIsoscelesTriangle,
                presetLine: {from: {row: 4, col: 1}, to: {row: 1, col: 4}}, // diagonal line
                solutionPoint: {row: 4, col: 4}, // perfect right isosceles solution
                congratsMessage: "Fantastic! You successfully created a right isosceles triangle constellation!",
                requiredLines: 2,
                difficulty: 3,
                type: "triangle"
            },
            
            // Scalene triangle series
            {
                name: "Scalene Triangle",
                description: "Please connect the stars to form a scalene triangle constellation",
                hint: "A scalene triangle has three sides of different lengths.",
                checkFunction: isScaleneTriangle,
                presetLine: {from: {row: 3, col: 2}, to: {row: 5, col: 5}}, // diagonal line
                solutionPoint: {row: 6, col: 2}, // ensure all sides are unequal
                congratsMessage: "Excellent! You successfully created a scalene triangle constellation!",
                requiredLines: 2,
                difficulty: 2,
                type: "triangle"
            },
            {
                name: "Scalene Triangle",
                description: "Please connect the stars to form a scalene triangle constellation",
                hint: "A scalene triangle has three sides of different lengths.",
                checkFunction: isScaleneTriangle,
                presetLine: {from: {row: 2, col: 2}, to: {row: 5, col: 6}}, // diagonal line
                solutionPoint: {row: 7, col: 3}, // ensure all sides are unequal
                congratsMessage: "Excellent! You successfully created a scalene triangle constellation!",
                requiredLines: 2,
                difficulty: 2,
                type: "triangle"
            },
            {
                name: "Scalene Triangle",
                description: "Please connect the stars to form a scalene triangle constellation",
                hint: "A scalene triangle has three sides of different lengths.",
                checkFunction: isScaleneTriangle,
                presetLine: {from: {row: 4, col: 4}, to: {row: 4, col: 7}}, // horizontal line
                solutionPoint: {row: 1, col: 2}, // ensure all sides are unequal
                congratsMessage: "Excellent! You successfully created a scalene triangle constellation!",
                requiredLines: 2,
                difficulty: 2,
                type: "triangle"
            }
        ];
        
        // Quadrilateral level definitions - all trapezoid-related levels removed
        const quadrilateralLevels = [
            // Square series
            {
                name: "Square",
                description: "Please connect the stars to form a square constellation",
                hint: "A square has four equal sides and four 90-degree angles.",
                checkFunction: isSquare,
                presetLine: {from: {row: 2, col: 2}, to: {row: 2, col: 6}}, // horizontal line
                solutionPoints: [{row: 6, col: 2}, {row: 6, col: 6}], // the other two points of the square
                congratsMessage: "Awesome! You successfully created a square constellation!",
                requiredLines: 3,
                difficulty: 2,
                type: "quadrilateral"
            },
            {
                name: "Square",
                description: "Please connect the stars to form a square constellation",
                hint: "A square has four equal sides and four 90-degree angles.",
                checkFunction: isSquare,
                presetLine: {from: {row: 3, col: 3}, to: {row: 3, col: 7}}, // horizontal line
                solutionPoints: [{row: 7, col: 3}, {row: 7, col: 7}], // the other two points of the square
                congratsMessage: "Awesome! You successfully created a square constellation!",
                requiredLines: 3,
                difficulty: 2,
                type: "quadrilateral"
            },
            {
                name: "Square",
                description: "Please connect the stars to form a square constellation",
                hint: "A square has four equal sides and four 90-degree angles.",
                checkFunction: isSquare,
                presetLine: {from: {row: 2, col: 2}, to: {row: 6, col: 2}}, // vertical line
                solutionPoints: [{row: 2, col: 6}, {row: 6, col: 6}], // the other two points of the square
                congratsMessage: "Awesome! You successfully created a square constellation!",
                requiredLines: 3,
                difficulty: 2,
                type: "quadrilateral"
            },
            
            // Rectangle series
            {
                name: "Rectangle",
                description: "Please connect the stars to form a rectangle constellation",
                hint: "A rectangle has four 90-degree angles and opposite sides are equal.",
                checkFunction: isRectangle,
                presetLine: {from: {row: 2, col: 2}, to: {row: 2, col: 7}}, // horizontal line
                solutionPoints: [{row: 5, col: 2}, {row: 5, col: 7}], // the other two points of the rectangle
                congratsMessage: "Great! You successfully created a rectangle constellation!",
                requiredLines: 3,
                difficulty: 2,
                type: "quadrilateral"
            },
            {
                name: "Rectangle",
                description: "Please connect the stars to form a rectangle constellation",
                hint: "A rectangle has four 90-degree angles and opposite sides are equal.",
                checkFunction: isRectangle,
                presetLine: {from: {row: 1, col: 1}, to: {row: 6, col: 1}}, // vertical line
                solutionPoints: [{row: 1, col: 4}, {row: 6, col: 4}], // the other two points of the rectangle
                congratsMessage: "Great! You successfully created a rectangle constellation!",
                requiredLines: 3,
                difficulty: 2,
                type: "quadrilateral"
            },
            {
                name: "Rectangle",
                description: "Please connect the stars to form a rectangle constellation",
                hint: "A rectangle has four 90-degree angles and opposite sides are equal.",
                checkFunction: isRectangle,
                presetLine: {from: {row: 3, col: 1}, to: {row: 3, col: 7}}, // horizontal line
                solutionPoints: [{row: 7, col: 1}, {row: 7, col: 7}], // the other two points of the rectangle
                congratsMessage: "Great! You successfully created a rectangle constellation!",
                requiredLines: 3,
                difficulty: 2,
                type: "quadrilateral"
            },
            
            // Parallelogram series
            {
                name: "Parallelogram",
                description: "Please connect the stars to form a parallelogram constellation",
                hint: "A parallelogram has two pairs of parallel opposite sides that are equal.",
                checkFunction: isParallelogram,
                presetLine: {from: {row: 3, col: 2}, to: {row: 3, col: 6}}, // horizontal line
                solutionPoints: [{row: 6, col: 4}, {row: 6, col: 8}], // the other two points of the parallelogram
                congratsMessage: "Outstanding! You successfully created a parallelogram constellation!",
                requiredLines: 3,
                difficulty: 3,
                type: "quadrilateral"
            },
            {
                name: "Parallelogram",
                description: "Please connect the stars to form a parallelogram constellation",
                hint: "A parallelogram has two pairs of parallel opposite sides that are equal.",
                checkFunction: isParallelogram,
                presetLine: {from: {row: 2, col: 2}, to: {row: 5, col: 2}}, // vertical line
                solutionPoints: [{row: 3, col: 6}, {row: 6, col: 6}], // the other two points of the parallelogram
                congratsMessage: "Outstanding! You successfully created a parallelogram constellation!",
                requiredLines: 3,
                difficulty: 3,
                type: "quadrilateral"
            },
            {
                name: "Parallelogram",
                description: "Please connect the stars to form a parallelogram constellation",
                hint: "A parallelogram has two pairs of parallel opposite sides that are equal.",
                checkFunction: isParallelogram,
                presetLine: {from: {row: 2, col: 2}, to: {row: 2, col: 6}}, // horizontal line
                solutionPoints: [{row: 5, col: 4}, {row: 5, col: 8}], // the other two points of the parallelogram
                congratsMessage: "Outstanding! You successfully created a parallelogram constellation!",
                requiredLines: 3,
                difficulty: 3,
                type: "quadrilateral"
            }
        ];
        
        // 合併所有關卡
        let levels = [...triangleLevels];
        let currentLevels = [...triangleLevels]; // 當前使用的關卡集
        
        // 動畫循環
        function animate() {
            // 更新粒子
            updateParticles();
            
            // 繼續動畫循環
            animationFrameId = requestAnimationFrame(animate);
        }
        
        // 更新粒子
        function updateParticles() {
            // 更新粒子位置和生命週期
            for (let i = particles.length - 1; i >= 0; i--) {
                const particle = particles[i];
                
                // 更新位置
                particle.x += particle.vx;
                particle.y += particle.vy;
                
                // 更新生命
                particle.life -= 0.02;
                
                // 如果粒子死亡，移除
                if (particle.life <= 0) {
                    particle.element.remove();
                    particles.splice(i, 1);
                } else {
                    // 更新透明度
                    particle.element.style.opacity = particle.life;
                    
                    // 更新位置
                    particle.element.style.left = `${particle.x}px`;
                    particle.element.style.top = `${particle.y}px`;
                }
            }
            
            // 更新星星閃爍效果
            for (const star of stars) {
                if (Math.random() < 0.005) {
                    const originalScale = parseFloat(star.element.getAttribute('data-scale') || 1);
                    const newScale = originalScale * (0.8 + Math.random() * 0.4);
                    star.element.style.transform = `scale(${newScale})`;
                    
                    setTimeout(() => {
                        if (star.element.parentNode) {
                            star.element.style.transform = `scale(${originalScale})`;
                        }
                    }, 300 + Math.random() * 700);
                }
            }
        }
        
        // 創建星星效果
        function createStar(x, y, size = 3, container = document.body) {
            // 創建星星
            const star = document.createElement('div');
            star.className = 'star';
            star.style.width = `${size}px`;
            star.style.height = `${size}px`;
            star.style.left = `${x}px`;
            star.style.top = `${y}px`;
            star.setAttribute('data-scale', '1');
            
            // 創建發光效果
            const glow = document.createElement('div');
            glow.className = 'star-glow';
            glow.style.width = `${size * 6}px`;
            glow.style.height = `${size * 6}px`;
            glow.style.left = `${x - size * 2.5}px`;
            glow.style.top = `${y - size * 2.5}px`;
            
            // 隨機閃爍時間
            glow.style.animationDelay = `${Math.random() * 2}s`;
            
            // 添加到容器
            container.appendChild(star);
            container.appendChild(glow);
            
            return {
                element: star,
                glow: glow,
                x: x,
                y: y,
                size: size
            };
        }
        
        // 創建粒子
        function createParticle(x, y, color = '#64FFDA') {
            const size = 1 + Math.random() * 2;
            const particle = document.createElement('div');
            particle.className = 'particle';
            particle.style.width = `${size}px`;
            particle.style.height = `${size}px`;
            particle.style.backgroundColor = color;
            particle.style.left = `${x}px`;
            particle.style.top = `${y}px`;
            
            document.body.appendChild(particle);
            
            // 粒子屬性
            const particleObj = {
                element: particle,
                x: x,
                y: y,
                vx: (Math.random() - 0.5) * 2,
                vy: (Math.random() - 0.5) * 2,
                size: size,
                life: 1 // 從1減少到0
            };
            
            particles.push(particleObj);
            return particleObj;
        }
        
        // 創建連接線效果
        function createConstellationLine(fromX, fromY, toX, toY) {
            const dx = toX - fromX;
            const dy = toY - fromY;
            const length = Math.sqrt(dx * dx + dy * dy);
            const angle = Math.atan2(dy, dx);
            
            const line = document.createElement('div');
            line.className = 'constellation-line';
            line.style.width = `${length}px`;
            line.style.left = `${fromX}px`;
            line.style.top = `${fromY}px`;
            line.style.transform = `rotate(${angle}rad)`;
            
            document.body.appendChild(line);
            
            // 在線條上添加粒子效果
            const particleCount = Math.max(5, Math.floor(length / 20));
            for (let i = 0; i < particleCount; i++) {
                const ratio = Math.random();
                const x = fromX + dx * ratio;
                const y = fromY + dy * ratio;
                createParticle(x, y, 'rgba(100, 255, 218, 0.8)');
            }
            
            constellationLines.push(line);
            return line;
        }
        
        // 清除效果元素
        function clearEffects() {
            // 清除星星
            stars.forEach(star => {
                if (star.element.parentNode) star.element.parentNode.removeChild(star.element);
                if (star.glow.parentNode) star.glow.parentNode.removeChild(star.glow);
            });
            stars = [];
            
            // 清除粒子
            particles.forEach(particle => {
                if (particle.element.parentNode) 
                    particle.element.parentNode.removeChild(particle.element);
            });
            particles = [];
            
            // 清除連接線
            constellationLines.forEach(line => {
                if (line.parentNode) line.parentNode.removeChild(line);
            });
            constellationLines = [];
            
            // 取消動畫
            if (animationFrameId) {
                cancelAnimationFrame(animationFrameId);
                animationFrameId = null;
            }
        }
        
        // 創建連接線
        function createConnectionLine(fromPoint, toPoint) {
            // 計算網格尺寸比例和座標
            const gridRatio = (canvas.width - 2 * offsetX) / (numCols * gridSize);
            const fromX = offsetX + fromPoint.col * gridSize * gridRatio;
            const fromY = offsetY + fromPoint.row * gridSize * gridRatio;
            const toX = offsetX + toPoint.col * gridSize * gridRatio;
            const toY = offsetY + toPoint.row * gridSize * gridRatio;
            
            // 獲取Canvas相對於視窗的位置
            const rect = canvas.getBoundingClientRect();
            
            // 創建連接線效果
            createConstellationLine(
                rect.left + fromX, 
                rect.top + fromY, 
                rect.left + toX, 
                rect.top + toY
            );
            
            // 在線路上生成粒子效果
            const particleCount = 8 + Math.floor(Math.random() * 5);
            for (let i = 0; i < particleCount; i++) {
                setTimeout(() => {
                    const ratio = i / (particleCount - 1);
                    const x = rect.left + fromX + (toX - fromX) * ratio;
                    const y = rect.top + fromY + (toY - fromY) * ratio;
                    createParticle(x, y);
                }, i * 50);
            }
        }
        
        // 初始化遊戲
        function init() {
            // 初始化音效
            initAudio();
            
            // 創建背景星星
            createBackgroundStars();
            
            // 啟動動畫循環
            animate();
            
            // 添加事件監聽器
            document.getElementById('startGameBtn').addEventListener('click', startGame);
            document.getElementById('playAgainBtn').addEventListener('click', restartGame);
            document.getElementById('howToPlayBtn').addEventListener('click', toggleInstructions);
            
            canvas.addEventListener('mousedown', handleMouseDown);
            canvas.addEventListener('mousemove', handleMouseMove);
            document.addEventListener('mouseup', handleMouseUp);
            
            canvas.addEventListener('touchstart', handleTouchStart, {passive: false});
            canvas.addEventListener('touchmove', handleTouchMove, {passive: false});
            canvas.addEventListener('touchend', handleTouchEnd);
            
            // 按鈕事件
            document.getElementById('resetBtn').addEventListener('click', resetLines);
            document.getElementById('checkBtn').addEventListener('click', checkShape);
            document.getElementById('hintTextBtn').addEventListener('click', toggleTextHint);
            document.getElementById('hintVisualBtn').addEventListener('click', showVisualHint);
            
            // 形狀選擇事件
            const shapeOptions = document.querySelectorAll('input[name="shapeType"]');
            shapeOptions.forEach(option => {
                option.addEventListener('change', function() {
                    if (this.checked) {
                        selectedShapeType = this.value;
                    }
                });
            });
            
            // 說明面板滾動事件處理
            const instructionsPanel = document.getElementById('gameInstructions');
            instructionsPanel.addEventListener('touchstart', function(e) {
                e.stopPropagation();
            }, {passive: true});
            
            instructionsPanel.addEventListener('touchmove', function(e) {
                e.stopPropagation();
            }, {passive: true});
            
            instructionsPanel.addEventListener('wheel', function(e) {
                e.stopPropagation();
            }, {passive: true});
            
            // 防止背景滾動穿透 - 更精確的控制
            document.addEventListener('touchmove', function(e) {
                const instructions = document.getElementById('gameInstructions');
                const startScreen = document.getElementById('startScreen');
                
                if (instructions.classList.contains('show')) {
                    const target = e.target;
                    const isInsideInstructions = instructions.contains(target);
                    const isInStartScreen = startScreen.contains(target);
                    
                    // 如果在說明面板外但在起始畫面內，允許滾動起始畫面
                    if (!isInsideInstructions && isInStartScreen) {
                        // 允許起始畫面滾動
                        return;
                    } else if (!isInsideInstructions) {
                        // 在說明面板和起始畫面外，阻止滾動
                        e.preventDefault();
                    }
                }
            }, {passive: false});
            
            // 視窗大小改變時重畫
            window.addEventListener('resize', () => {
                resizeCanvas();
                createBackgroundStars();
            });
            resizeCanvas();
            
            // 預載入第一關但不開始遊戲
            loadLevel(0);
            
            console.log("Game initialized, please click 'Begin Your Journey' button to start the game");
        }
        
        // 開始遊戲
        function startGame() {
            startScreen.style.display = 'none';
            
            // 根據選擇的形狀類型設置關卡
            setLevelsByShapeType();
            
            // Update page title
            document.title = `Stellar Explorer - ${getShapeTypeName()} Learning`;
            document.querySelector('h1').textContent = `Stellar Explorer - ${getShapeTypeName()} Constellation Learning`;
            
            // 更新信息文字
            updateShapeInfoText();
            
            // 重置遊戲狀態
            score = 0;
            streak = 0;
            solvedCount = 0;
            timeLeft = 60;
            isGameActive = true;
            
            // 清空新解鎖的成就列表
            newUnlocks = [];
            
            // 重置成就狀態
            for (const achievement of achievements) {
                achievement.unlocked = false;
            }
            
            // 隨機選擇一個關卡開始
            loadRandomLevel();
            
            // 更新UI
            updateScoreDisplay();
            
            // Reset difficulty
            currentDifficulty = "Normal";
            difficultyDisplay.textContent = `Difficulty: ${currentDifficulty}`;
            
            // 啟動計時器
            startTimer();
            
            // 播放開始音效
            playSound('click');
            
            // 清除現有效果
            clearEffects();
            
            // 重啟動畫循環
            if (!animationFrameId) {
                animate();
            }
            
            // 啟動環境音樂
            setTimeout(() => {
                createAmbientMusic();
                fadeInAmbientMusic();
            }, 1000); // 1秒後開始，讓開始音效先播放
            
            console.log("Game started");
        }
        
        // 設置關卡根據形狀類型
        function setLevelsByShapeType() {
            switch(selectedShapeType) {
                case "triangles":
                    currentLevels = [...triangleLevels];
                    break;
                case "quadrilaterals":
                    currentLevels = [...quadrilateralLevels];
                    break;
                case "all":
                    currentLevels = [...triangleLevels, ...quadrilateralLevels];
                    break;
                default:
                    currentLevels = [...triangleLevels];
            }
            // 確保levels數組引用currentLevels的數據
            levels = currentLevels;
            
            if (debugMode) {
                console.log(`設置關卡類型: ${selectedShapeType}`);
                console.log(`總關卡數: ${levels.length}`);
            }
        }
        
        // Get shape type name
        function getShapeTypeName() {
            switch(selectedShapeType) {
                case "triangles": return "Triangle";
                case "quadrilaterals": return "Quadrilateral";
                case "all": return "Geometric Shapes";
                default: return "Geometric Shapes";
            }
        }
        
        // Update shape info text
        function updateShapeInfoText() {
            let infoText = "";
            switch(selectedShapeType) {
                case "triangles":
                    infoText = "Connect the shining stars to form the specified triangle constellation type";
                    break;
                case "quadrilaterals":
                    infoText = "Connect the shining stars to form the specified quadrilateral constellation type";
                    break;
                case "all":
                    infoText = "Connect the shining stars to form the specified geometric constellation type";
                    break;
                default:
                    infoText = "Connect the shining stars to form the specified geometric constellation type";
            }
            shapeInfo.textContent = infoText;
        }
        
        // 重新開始遊戲
        function restartGame() {
            resultScreen.style.display = 'none';
            startGame();
        }
        
        // 切換遊戲說明顯示
        function toggleInstructions() {
            const instructions = document.getElementById('gameInstructions');
            const arrow = document.querySelector('.btn-arrow');
            const startScreen = document.getElementById('startScreen');
            
            // 播放點擊音效
            playSound('click');
            
            if (instructions.classList.contains('show')) {
                // 隱藏說明
                instructions.classList.remove('show');
                arrow.textContent = '↓';
                arrow.style.transform = 'translateY(0)';
                // 恢復正常滾動
                startScreen.style.overflow = '';
                startScreen.style.height = '';
            } else {
                // 顯示說明
                instructions.classList.add('show');
                arrow.textContent = '↑';
                arrow.style.transform = 'translateY(-2px)';
                // 允許整個起始畫面滾動
                startScreen.style.overflow = 'auto';
                startScreen.style.height = '100vh';
                
                // 確保說明面板可以滾動
                setTimeout(() => {
                    const instructionContent = instructions.querySelector('.instruction-content');
                    if (instructionContent) {
                        instructionContent.scrollTop = 0;
                    }
                }, 100);
            }
        }
        
        // 顯示視覺提示
        function showVisualHint() {
            if (!isGameActive) return;
            
            playSound('hint');
            
            const level = levels[currentLevelIndex];
            
            // 計算網格尺寸比例
            const gridRatio = (canvas.width - 2 * offsetX) / (numCols * gridSize);
            
            // 根據關卡類型顯示提示
            if (level.type === "triangle") {
                const solutionPoint = level.solutionPoint;
                const x = offsetX + solutionPoint.col * gridSize * gridRatio;
                const y = offsetY + solutionPoint.row * gridSize * gridRatio;
                
                // 繪製閃爍提示效果
                ctx.beginPath();
                ctx.arc(x, y, pointRadius * 2.5 * gridRatio, 0, Math.PI * 2);
                
                // 創建漸變
                const gradient = ctx.createRadialGradient(
                    x, y, 0, 
                    x, y, pointRadius * 3 * gridRatio
                );
                gradient.addColorStop(0, 'rgba(100, 255, 218, 0.7)');
                gradient.addColorStop(1, 'rgba(100, 255, 218, 0)');
                
                ctx.fillStyle = gradient;
                ctx.fill();
                
                // 獲取Canvas相對於視窗的位置
                const rect = canvas.getBoundingClientRect();
                
                // 創建閃爍粒子效果
                for (let i = 0; i < 15; i++) {
                    setTimeout(() => {
                        const angle = Math.random() * Math.PI * 2;
                        const distance = Math.random() * 30;
                        const px = rect.left + x + Math.cos(angle) * distance;
                        const py = rect.top + y + Math.sin(angle) * distance;
                        createParticle(px, py, 'rgba(100, 255, 218, 0.8)');
                    }, i * 100);
                }
            } else if (level.type === "quadrilateral") {
                // 對於四邊形，顯示兩個解點
                for (const solutionPoint of level.solutionPoints) {
                    const x = offsetX + solutionPoint.col * gridSize * gridRatio;
                    const y = offsetY + solutionPoint.row * gridSize * gridRatio;
                    
                    // 繪製閃爍提示效果
                    ctx.beginPath();
                    ctx.arc(x, y, pointRadius * 2.5 * gridRatio, 0, Math.PI * 2);
                    
                    // 創建漸變
                    const gradient = ctx.createRadialGradient(
                        x, y, 0, 
                        x, y, pointRadius * 3 * gridRatio
                    );
                    gradient.addColorStop(0, 'rgba(100, 255, 218, 0.7)');
                    gradient.addColorStop(1, 'rgba(100, 255, 218, 0)');
                    
                    ctx.fillStyle = gradient;
                    ctx.fill();
                    
                    // 獲取Canvas相對於視窗的位置
                    const rect = canvas.getBoundingClientRect();
                    
                    // 創建閃爍粒子效果
                    for (let i = 0; i < 10; i++) {
                        setTimeout(() => {
                            const angle = Math.random() * Math.PI * 2;
                            const distance = Math.random() * 30;
                            const px = rect.left + x + Math.cos(angle) * distance;
                            const py = rect.top + y + Math.sin(angle) * distance;
                            createParticle(px, py, 'rgba(100, 255, 218, 0.8)');
                        }, i * 100);
                    }
                }
            }
            
            // 2秒後消失
            setTimeout(() => drawGame(), 2000);
        }
        
        // 顯示文字提示
        function toggleTextHint() {
            if (hintBox.style.display === 'none') {
                hintBox.style.display = 'block';
                playSound('hint');
                
                // 添加淡入效果
                hintBox.style.opacity = 0;
                setTimeout(() => {
                    hintBox.style.transition = 'opacity 0.5s';
                    hintBox.style.opacity = 1;
                }, 10);
            } else {
                // 添加淡出效果
                hintBox.style.transition = 'opacity 0.5s';
                hintBox.style.opacity = 0;
                
                setTimeout(() => {
                    hintBox.style.display = 'none';
                    hintBox.style.transition = '';
                }, 500);
            }
        }
        
        // 啟動計時器
        function startTimer() {
            updateTimerDisplay();
            
            timerInterval = setInterval(() => {
                timeLeft--;
                updateTimerDisplay();
                
                // 閃爍效果當時間少於10秒
                if (timeLeft <= 10 && timeLeft > 0) {
                    timerDisplay.classList.add('pulse-animation');
                    setTimeout(() => timerDisplay.classList.remove('pulse-animation'), 500);
                }
                
                if (timeLeft <= 0) {
                    endGame();
                }
            }, 1000);
        }
        
        // 更新計時器顯示
        function updateTimerDisplay() {
            const minutes = Math.floor(timeLeft / 60);
            const seconds = timeLeft % 60;
            timerDisplay.textContent = `${minutes.toString().padStart(2, '0')}:${seconds.toString().padStart(2, '0')}`;
            
            // 時間少於10秒時變紅
            if (timeLeft <= 10) {
                timerDisplay.style.color = '#FF6464';
                timerDisplay.style.textShadow = '0 0 8px rgba(255, 100, 100, 0.7)';
            } else {
                timerDisplay.style.color = '#FFD700';
                timerDisplay.style.textShadow = '0 0 8px rgba(255, 215, 0, 0.5)';
            }
        }
        
        // 結束遊戲
        function endGame() {
            clearInterval(timerInterval);
            isGameActive = false;
            
            // 檢查並更新最終成就
            checkAchievements();
            
            // 更新成就顯示
            updateAchievementDisplay();
            
            // Show result screen
            document.getElementById('finalScore').textContent = `${solvedCount} Constellations`;
            document.getElementById('finalTotalScore').textContent = score;
            resultScreen.style.display = 'flex';
            
            // 創建星點粒子效果
            const numParticles = Math.min(100, solvedCount * 20);
            for (let i = 0; i < numParticles; i++) {
                setTimeout(() => {
                    const x = Math.random() * window.innerWidth;
                    const y = Math.random() * window.innerHeight * 0.7;
                    createParticle(x, y, `hsl(${Math.random() * 60 + 180}, 100%, 70%)`);
                }, i * 20);
            }
            
            // 為已解鎖的成就添加特效
            if (newUnlocks.length > 0) {
                setTimeout(() => {
                    const achievementContainers = document.querySelectorAll('.achievement-badge.new-unlock');
                    achievementContainers.forEach((badge, index) => {
                        // 為每個新解鎖的成就創建發光效果
                        setTimeout(() => {
                            // 創建粒子效果
                            const rect = badge.getBoundingClientRect();
                            const centerX = rect.left + rect.width / 2;
                            const centerY = rect.top + rect.height / 2;
                            
                            for (let i = 0; i < 20; i++) {
                                setTimeout(() => {
                                    const angle = Math.random() * Math.PI * 2;
                                    const distance = Math.random() * 50 + 20;
                                    const x = centerX + Math.cos(angle) * distance;
                                    const y = centerY + Math.sin(angle) * distance;
                                    createParticle(x, y, '#FFD700');
                                }, i * 50);
                            }
                        }, index * 300);
                    });
                }, 500);
            }
            
            console.log("Game ended");
        }
        
        // 隨機選擇關卡
        function loadRandomLevel() {
            // 根據連勝調整難度
            let levelPool = levels;
            
            if (streak >= 5) {
                // 從關卡中篩選出困難的
                const hardLevels = levels.filter(l => l.difficulty >= 3);
                if (hardLevels.length > 0) {
                    levelPool = hardLevels;
                    
                    if (currentDifficulty !== "Hard") {
                        currentDifficulty = "Hard";
                        difficultyDisplay.textContent = `Difficulty: ${currentDifficulty}`;
                    }
                }
            }
            
            // 確保不重複上一個關卡
            let newIndex;
            do {
                if (levelPool.length === 1) {
                    newIndex = 0; // 只有一個關卡時直接選擇
                    break;
                }
                
                if (levelPool !== levels) {
                    // 從困難關卡中選擇
                    const hardIndex = Math.floor(Math.random() * levelPool.length);
                    // 找到在原始關卡陣列中的索引
                    newIndex = levels.findIndex(level => 
                        level.name === levelPool[hardIndex].name && 
                        level.presetLine.from.row === levelPool[hardIndex].presetLine.from.row &&
                        level.presetLine.from.col === levelPool[hardIndex].presetLine.from.col
                    );
                } else {
                    // 從所有關卡中選擇
                    newIndex = Math.floor(Math.random() * levels.length);
                }
            } while (newIndex === currentLevelIndex && levels.length > 1);
            
            currentLevelIndex = newIndex;
            loadLevel(currentLevelIndex);
        }
        
        // 調整Canvas大小
        function resizeCanvas() {
            // 獲取容器大小
            const containerWidth = Math.min(450, window.innerWidth - 40);
            canvas.width = containerWidth;
            canvas.height = containerWidth;
            canvas.style.width = containerWidth + 'px';
            canvas.style.height = containerWidth + 'px';
            
            drawGame();
        }
        
        // 載入關卡
        function loadLevel(index) {
            // 清除所有效果
            clearEffects();
            
            currentLevelIndex = index;
            
            if (!levels[currentLevelIndex]) {
                console.error("關卡載入錯誤：找不到關卡", index);
                if (levels.length > 0) {
                    currentLevelIndex = 0;
                } else {
                    console.error("沒有可用關卡！");
                    return;
                }
            }
            
            const level = levels[currentLevelIndex];
            
            if (debugMode) {
                console.log(`載入關卡: ${level.name} (索引: ${currentLevelIndex})`);
                console.log(`關卡類型: ${level.type}`);
            }
            
            // Update UI
            document.getElementById('task').textContent = level.description;
            const requiredLines = level.requiredLines || 2; // Default triangles is 2 lines, quadrilaterals is 3 lines
            document.getElementById('status').textContent = `Connected: 0 lines (need to connect ${requiredLines} lines)`;
            hintBox.style.display = 'none';
            hintBox.textContent = level.hint;
            
            // 隱藏結果訊息
            resultMessage.style.display = 'none';
            
            // 重置遊戲狀態
            userLines = [];
            selectedPoint = null;
            isComplete = false;
            
            // 繪製遊戲
            drawGame();
            
            // 重啟動畫循環（如果還沒啟動）
            if (!animationFrameId) {
                animate();
            }
        }
        
        // 繪製遊戲
        function drawGame() {
            // 清除畫布
            ctx.clearRect(0, 0, canvas.width, canvas.height);
            
            // 繪製背景
            const gradient = ctx.createLinearGradient(0, 0, 0, canvas.height);
            gradient.addColorStop(0, '#0B0E2E');
            gradient.addColorStop(1, '#1A1B4B');
            ctx.fillStyle = gradient;
            ctx.fillRect(0, 0, canvas.width, canvas.height);
            
            // 繪製背景星星 - 小點
            ctx.fillStyle = 'rgba(255, 255, 255, 0.5)';
            
            // 隨機種子，使星星位置保持一致
            const levelSeed = currentLevelIndex * 10000;
            const pseudoRandom = (seed) => {
                return ((seed * 9301 + 49297) % 233280) / 233280;
            };
            
            // 繪製小型星星
            for (let i = 0; i < 50; i++) {
                const seed = levelSeed + i;
                const x = pseudoRandom(seed) * canvas.width;
                const y = pseudoRandom(seed + 1) * canvas.height;
                const size = pseudoRandom(seed + 2) * 1.5;
                
                ctx.beginPath();
                ctx.arc(x, y, size, 0, Math.PI * 2);
                ctx.fill();
            }
            
            // 繪製星雲效果
            ctx.save();
            for (let i = 0; i < 3; i++) {
                const seed = levelSeed + i * 1000;
                const x = pseudoRandom(seed) * canvas.width;
                const y = pseudoRandom(seed + 1) * canvas.height;
                const radius = 50 + pseudoRandom(seed + 2) * 100;
                
                const nebulaGradient = ctx.createRadialGradient(x, y, 0, x, y, radius);
                nebulaGradient.addColorStop(0, `rgba(${50 + i * 20}, ${80 + i * 10}, ${150 + i * 20}, 0.03)`);
                nebulaGradient.addColorStop(0.5, `rgba(${40 + i * 20}, ${60 + i * 10}, ${120 + i * 20}, 0.02)`);
                nebulaGradient.addColorStop(1, 'rgba(20, 30, 80, 0)');
                
                ctx.fillStyle = nebulaGradient;
                ctx.beginPath();
                ctx.arc(x, y, radius, 0, Math.PI * 2);
                ctx.fill();
            }
            ctx.restore();
            
            // 計算網格尺寸比例
            const gridRatio = (canvas.width - 2 * offsetX) / (numCols * gridSize);
            
            // 繪製網格線（淡）
            ctx.strokeStyle = 'rgba(255, 255, 255, 0.05)';
            ctx.lineWidth = 1;
            
            // 垂直線
            for (let col = 0; col <= numCols; col++) {
                const x = offsetX + col * gridSize * gridRatio;
                ctx.beginPath();
                ctx.moveTo(x, offsetY);
                ctx.lineTo(x, offsetY + numRows * gridSize * gridRatio);
                ctx.stroke();
            }
            
            // 水平線
            for (let row = 0; row <= numRows; row++) {
                const y = offsetY + row * gridSize * gridRatio;
                ctx.beginPath();
                ctx.moveTo(offsetX, y);
                ctx.lineTo(offsetX + numCols * gridSize * gridRatio, y);
                ctx.stroke();
            }
            
            // 預設線
            if (!levels[currentLevelIndex]) return; // 避免初始化問題
            
            const level = levels[currentLevelIndex];
            const presetLine = level.presetLine;
            
            // 轉換預設線的座標
            const fromX = offsetX + presetLine.from.col * gridSize * gridRatio;
            const fromY = offsetY + presetLine.from.row * gridSize * gridRatio;
            const toX = offsetX + presetLine.to.col * gridSize * gridRatio;
            const toY = offsetY + presetLine.to.row * gridSize * gridRatio;
            
            // 繪製預設線
            ctx.beginPath();
            ctx.moveTo(fromX, fromY);
            ctx.lineTo(toX, toY);
            
            // 使用漸變
            const lineGradient = ctx.createLinearGradient(fromX, fromY, toX, toY);
            lineGradient.addColorStop(0, '#8A9EFF');
            lineGradient.addColorStop(0.5, '#ADC2FF');
            lineGradient.addColorStop(1, '#8A9EFF');
            
            ctx.strokeStyle = lineGradient;
            ctx.lineWidth = 3;
            ctx.stroke();
            
            // 添加發光效果
            ctx.shadowColor = 'rgba(138, 158, 255, 0.5)';
            ctx.shadowBlur = 10;
            
            ctx.beginPath();
            ctx.moveTo(fromX, fromY);
            ctx.lineTo(toX, toY);
            ctx.stroke();
            
            // 移除陰影以防影響其他繪製
            ctx.shadowColor = 'transparent';
            ctx.shadowBlur = 0;
            
            // 繪製用戶連接的線條
            for (const line of userLines) {
                const fromX = offsetX + line.from.col * gridSize * gridRatio;
                const fromY = offsetY + line.from.row * gridSize * gridRatio;
                const toX = offsetX + line.to.col * gridSize * gridRatio;
                const toY = offsetY + line.to.row * gridSize * gridRatio;
                
                // 計算線的漸變
                const lineGradient = ctx.createLinearGradient(fromX, fromY, toX, toY);
                lineGradient.addColorStop(0, '#64FFDA');
                lineGradient.addColorStop(0.5, '#A0FFE6');
                lineGradient.addColorStop(1, '#64FFDA');
                
                // 發光效果
                ctx.shadowColor = 'rgba(100, 255, 218, 0.5)';
                ctx.shadowBlur = 10;
                
                ctx.beginPath();
                ctx.moveTo(fromX, fromY);
                ctx.lineTo(toX, toY);
                ctx.strokeStyle = lineGradient;
                ctx.lineWidth = 3;
                ctx.stroke();
                
                // 移除陰影
                ctx.shadowBlur = 0;
                ctx.shadowColor = 'transparent';
            }
            
            // 繪製當前拖動的線
            if (selectedPoint !== null) {
                const fromX = offsetX + selectedPoint.col * gridSize * gridRatio;
                const fromY = offsetY + selectedPoint.row * gridSize * gridRatio;
                
                // 漸變顏色的虛線
                const dashLineGradient = ctx.createLinearGradient(fromX, fromY, lastMouseX, lastMouseY);
                dashLineGradient.addColorStop(0, 'rgba(255, 255, 255, 0.8)');
                dashLineGradient.addColorStop(1, 'rgba(255, 255, 255, 0.1)');
                
                ctx.beginPath();
                ctx.moveTo(fromX, fromY);
                ctx.lineTo(lastMouseX, lastMouseY);
                ctx.strokeStyle = dashLineGradient;
                ctx.lineWidth = 2;
                ctx.setLineDash([5, 5]); // 虛線效果
                ctx.stroke();
                ctx.setLineDash([]); // 重置為實線
            }
            
            // 創建星星映射，避免重複創建
            const starMap = new Map();
            
            // 清除現有的DOM星星
            clearEffects();
            
            // 初始化星星陣列
            stars = [];
            
            // 繪製所有網格點
            for (let row = 0; row <= numRows; row++) {
                for (let col = 0; col <= numCols; col++) {
                    const x = offsetX + col * gridSize * gridRatio;
                    const y = offsetY + row * gridSize * gridRatio;
                    
                    // 確定點的顏色和大小（預設線端點、用戶線端點、普通點）
                    let isSpecialPoint = false;
                    
                    // 檢查是否為預設線端點
                    if ((row === presetLine.from.row && col === presetLine.from.col) ||
                        (row === presetLine.to.row && col === presetLine.to.col)) {
                        isSpecialPoint = true;
                    }
                    
                    // 檢查是否為用戶線端點
                    for (const line of userLines) {
                        if ((row === line.from.row && col === line.from.col) ||
                            (row === line.to.row && col === line.to.col)) {
                            isSpecialPoint = true;
                            break;
                        }
                    }
                    
                    // 檢查是否為選中或懸停的點
                    const isSelected = selectedPoint && row === selectedPoint.row && col === selectedPoint.col;
                    const isHovered = hoveredPoint && row === hoveredPoint.row && col === hoveredPoint.col;
                    
                    // 決定點的繪製方式
                    if (isSpecialPoint || isSelected || isHovered) {
                        // 星點閃爍效果
                        const pulseSize = (Math.sin(Date.now() / 300) * 0.2 + 1);
                        
                        // 發光效果
                        ctx.beginPath();
                        ctx.arc(x, y, pointRadius * 2 * gridRatio * pulseSize, 0, Math.PI * 2);
                        const gradient = ctx.createRadialGradient(
                            x, y, 0,
                            x, y, pointRadius * 2 * gridRatio * pulseSize
                        );
                        gradient.addColorStop(0, 'rgba(255, 215, 0, 0.8)');
                        gradient.addColorStop(1, 'rgba(255, 215, 0, 0)');
                        ctx.fillStyle = gradient;
                        ctx.fill();
                        
                        // 主星點
                        ctx.beginPath();
                        ctx.arc(x, y, pointRadius * gridRatio * pulseSize, 0, Math.PI * 2);
                        ctx.fillStyle = '#FFD700';
                        ctx.fill();
                        
                        // 添加星光效果
                        ctx.beginPath();
                        ctx.arc(x, y, pointRadius * 0.8 * gridRatio * pulseSize, 0, Math.PI * 2);
                        ctx.fillStyle = '#FFFFFF';
                        ctx.fill();
                        
                        // 獲取Canvas相對於視窗的位置
                        const rect = canvas.getBoundingClientRect();
                        
                        // 在DOM中創建星光效果
                        if (!starMap.has(`${row},${col}`)) {
                            const star = createStar(
                                rect.left + x, 
                                rect.top + y, 
                                pointRadius * 1.5 * gridRatio
                            );
                            stars.push(star);
                            starMap.set(`${row},${col}`, star);
                        }
                    } else {
                        // 普通點
                        ctx.beginPath();
                        ctx.arc(x, y, pointRadius * 0.7 * gridRatio, 0, Math.PI * 2);
                        ctx.fillStyle = 'rgba(255, 255, 255, 0.4)';
                        ctx.fill();
                    }
                    
                    // 選中或懸停的點高亮
                    if (isSelected || isHovered) {
                        ctx.beginPath();
                        ctx.arc(x, y, pointRadius * 1.2 * gridRatio, 0, Math.PI * 2);
                        ctx.strokeStyle = isSelected ? '#ffffff' : 'rgba(255, 255, 255, 0.7)';
                        ctx.lineWidth = 2;
                        ctx.stroke();
                    }
                }
            }
            
            // 更新狀態
            const requiredLines = levels[currentLevelIndex].requiredLines || 2;
            document.getElementById('status').textContent = `Connected: ${userLines.length} lines (need to connect ${requiredLines} lines)`;
        }
        
        // 查找點擊位置的網格點
        function findGridPoint(x, y) {
            const gridRatio = (canvas.width - 2 * offsetX) / (numCols * gridSize);
            
            for (let row = 0; row <= numRows; row++) {
                for (let col = 0; col <= numCols; col++) {
                    const pointX = offsetX + col * gridSize * gridRatio;
                    const pointY = offsetY + row * gridSize * gridRatio;
                    
                    const distance = Math.sqrt(
                        Math.pow(x - pointX, 2) + Math.pow(y - pointY, 2)
                    );
                    
                    if (distance <= pointRadius * 2 * gridRatio) {
                        return { row, col };
                    }
                }
            }
            
            return null;
        }
        
        // 檢查是否可以連接兩個點
        function canConnectPoints(fromPoint, toPoint) {
            // 檢查是否已經連接
            for (const line of userLines) {
                if ((line.from.row === fromPoint.row && line.from.col === fromPoint.col &&
                     line.to.row === toPoint.row && line.to.col === toPoint.col) ||
                    (line.from.row === toPoint.row && line.from.col === toPoint.col &&
                     line.to.row === fromPoint.row && line.to.col === fromPoint.col)) {
                    return false;
                }
            }
            
            // 檢查是否與預設線重複
            const presetLine = levels[currentLevelIndex].presetLine;
            if ((fromPoint.row === presetLine.from.row && fromPoint.col === presetLine.from.col &&
                 toPoint.row === presetLine.to.row && toPoint.col === presetLine.to.col) ||
                (fromPoint.row === presetLine.to.row && fromPoint.col === presetLine.to.col &&
                 toPoint.row === presetLine.from.row && toPoint.col === presetLine.from.col)) {
                return false;
            }
            
            return true;
        }
        
        // Update score display
        function updateScoreDisplay() {
            document.getElementById('scoreDisplay').textContent = `Score: ${score}`;
            document.getElementById('streakDisplay').textContent = `Streak: ${streak}`;
            document.getElementById('solvedDisplay').textContent = `Solved: ${solvedCount}`;
        }
        
        // 加分
        function addPoints(points) {
            const scoreDisplay = document.getElementById('scoreDisplay');
            
            // 記錄原始分數
            const oldScore = score;
            
            // 增加分數
            score += points;
            
            // 更新分數顯示
            updateScoreDisplay();
            
            // 添加視覺效果
            scoreDisplay.classList.add('pulse-animation');
            setTimeout(() => {
                scoreDisplay.classList.remove('pulse-animation');
            }, 500);
            
            return score - oldScore; // 返回增加的分數
        }
        
        // 檢查形狀
        function checkShape() {
            if (!isGameActive) return;
            
            const level = levels[currentLevelIndex];
            const requiredLines = level.requiredLines || 2; // 預設為三角形(2條線)
            
            // Check connected line count
            if (userLines.length !== requiredLines) {
                showResultMessage(`You need to connect exactly ${requiredLines} lines to complete the ${level.name} constellation!`, false);
                playSound('wrong');
                return;
            }
            
            const result = level.checkFunction();
            
            if (result) {
                handleCorrectShape(level);
            } else {
                // 失敗 - 重置連勝
                streak = 0;
                updateScoreDisplay();
                
                // 播放錯誤音效
                playSound('wrong');
                
                // Show failure message
                showResultMessage("Not quite the correct " + level.name + " constellation! Please try again.", false);
            }
        }
        
        // 處理正確的形狀
        function handleCorrectShape(level) {
            // 完成！
            isComplete = true;
            
            // 播放正確音效
            playSound('correct');
            
            // 增加連勝
            streak++;
            
            // 增加已解題數
            solvedCount++;
            
            // 計算分數 - 基於難度和連勝
            const basePoints = level.difficulty * 10;
            const streakBonus = streak > 1 ? streak * 5 : 0;
            const totalPoints = basePoints + streakBonus;
            
            // 加分
            const pointsAdded = addPoints(totalPoints);
            
            // 更新狀態和顯示
            const statusText = `${level.congratsMessage} +${pointsAdded} points`;
            showResultMessage(statusText, true);
            
            // 檢查是否解鎖新成就
            checkAchievements();
            
            // 創建星點連接特效
            createConnectionEffects();
            
            // 漸變光芒效果
            const rect = canvas.getBoundingClientRect();
            ctx.fillStyle = 'rgba(255, 255, 255, 0.1)';
            ctx.fillRect(0, 0, canvas.width, canvas.height);
            
            // 創建完成粒子效果
            const centerX = rect.left + canvas.width / 2;
            const centerY = rect.top + canvas.height / 2;
            
            for (let i = 0; i < 40; i++) {
                setTimeout(() => {
                    const angle = Math.random() * Math.PI * 2;
                    const distance = Math.random() * canvas.width * 0.5;
                    const x = centerX + Math.cos(angle) * distance;
                    const y = centerY + Math.sin(angle) * distance;
                    createParticle(x, y, `rgba(${Math.random() * 100 + 155}, ${Math.random() * 100 + 155}, 255, 0.8)`);
                }, i * 50);
            }
            
            // 1.5秒後自動進入下一題
            setTimeout(() => {
                if (isGameActive) {
                    loadRandomLevel();
                }
            }, 1500);
        }
        
        // 檢查是否解鎖成就
        function checkAchievements() {
            // 檢查每個成就的解鎖條件
            for (let i = 0; i < achievements.length; i++) {
                const achievement = achievements[i];
                
                if (!achievement.unlocked && solvedCount >= achievement.level) {
                    // 解鎖成就
                    achievement.unlocked = true;
                    
                    // 添加到新解鎖列表
                    newUnlocks.push(achievement);
                    
                    // 顯示通知
                    setTimeout(() => {
                        showAchievementPopup(achievement);
                    }, 100 + i * 400); // 快速響應，如果連續解鎖多個成就，分開時間顯示
                }
            }
        }
        
        // 顯示成就解鎖彈窗
        function showAchievementPopup(achievement) {
            const popup = document.getElementById('achievementPopup');
            const iconEl = popup.querySelector('.achievement-icon-large');
            const titleEl = popup.querySelector('.achievement-popup-title');
            const descEl = popup.querySelector('.achievement-popup-desc');
            
            // 設置內容
            iconEl.textContent = achievement.icon;
            titleEl.textContent = `Achievement Unlocked: ${achievement.name}`;
            descEl.textContent = achievement.description;
            
            // 顯示彈窗
            popup.classList.add('show');
            
            // 播放解鎖成就音效
            playAchievementSound();
            
            // 2秒後隱藏 (縮短顯示時間)
            setTimeout(() => {
                popup.classList.remove('show');
            }, 2000);
        }
        
        // 播放成就解鎖音效
        function playAchievementSound() {
            if (!audioContext || !soundToggle.checked) return;
            
            try {
                // 特殊的成就解鎖音效 - 华丽的上升音
                const oscillator1 = audioContext.createOscillator();
                const oscillator2 = audioContext.createOscillator();
                const gainNode = audioContext.createGain();
                
                oscillator1.type = 'sine';
                oscillator2.type = 'triangle';
                
                oscillator1.connect(gainNode);
                oscillator2.connect(gainNode);
                gainNode.connect(audioContext.destination);
                
                // 第一個音調軌跡
                oscillator1.frequency.setValueAtTime(523.25, audioContext.currentTime); // C5
                oscillator1.frequency.linearRampToValueAtTime(783.99, audioContext.currentTime + 0.2); // G5
                oscillator1.frequency.linearRampToValueAtTime(1046.50, audioContext.currentTime + 0.4); // C6
                
                // 第二個音調軌跡 (稍微延遲，添加和聲效果)
                oscillator2.frequency.setValueAtTime(659.25, audioContext.currentTime + 0.05); // E5
                oscillator2.frequency.linearRampToValueAtTime(987.77, audioContext.currentTime + 0.25); // B5
                oscillator2.frequency.linearRampToValueAtTime(1318.51, audioContext.currentTime + 0.45); // E6
                
                // 漸變音量
                gainNode.gain.setValueAtTime(0, audioContext.currentTime);
                gainNode.gain.linearRampToValueAtTime(0.3, audioContext.currentTime + 0.1);
                gainNode.gain.exponentialRampToValueAtTime(0.01, audioContext.currentTime + 0.8);
                
                oscillator1.start();
                oscillator2.start();
                oscillator1.stop(audioContext.currentTime + 0.8);
                oscillator2.stop(audioContext.currentTime + 0.8);
            } catch(e) {
                console.warn('Error playing achievement sound:', e);
            }
        }
        
        // 更新成就顯示
        function updateAchievementDisplay() {
            const container = document.getElementById('achievementsContainer');
            container.innerHTML = '';
            
            // 先添加所有解鎖的成就
            for (const achievement of achievements) {
                const badge = document.createElement('div');
                badge.className = 'achievement-badge' + (achievement.unlocked ? ' unlocked' : ' locked');
                
                // 檢查是否為本次遊戲新解鎖
                if (newUnlocks.includes(achievement)) {
                    badge.classList.add('new-unlock');
                }
                
                const icon = document.createElement('span');
                icon.className = 'icon';
                icon.textContent = achievement.icon;
                
                const tooltip = document.createElement('div');
                tooltip.className = 'achievement-tooltip';
                tooltip.textContent = achievement.unlocked 
                    ? `${achievement.name}: ${achievement.description}` 
                    : `????: Complete ${achievement.level} constellations to unlock`;
                
                badge.appendChild(icon);
                badge.appendChild(tooltip);
                container.appendChild(badge);
            }
        }
        
        // 創建連接特效
        function createConnectionEffects() {
            // 獲取Canvas位置
            const rect = canvas.getBoundingClientRect();
            const gridRatio = (canvas.width - 2 * offsetX) / (numCols * gridSize);
            
            // 預設線的兩個端點
            const presetLine = levels[currentLevelIndex].presetLine;
            const p1 = {
                x: rect.left + offsetX + presetLine.from.col * gridSize * gridRatio,
                y: rect.top + offsetY + presetLine.from.row * gridSize * gridRatio
            };
            const p2 = {
                x: rect.left + offsetX + presetLine.to.col * gridSize * gridRatio,
                y: rect.top + offsetY + presetLine.to.row * gridSize * gridRatio
            };
            
            // 創建預設線的連接效果
            createConstellationLine(p1.x, p1.y, p2.x, p2.y);
            
            // 創建用戶線的連接效果
            for (const line of userLines) {
                const fromX = rect.left + offsetX + line.from.col * gridSize * gridRatio;
                const fromY = rect.top + offsetY + line.from.row * gridSize * gridRatio;
                const toX = rect.left + offsetX + line.to.col * gridSize * gridRatio;
                const toY = rect.top + offsetY + line.to.row * gridSize * gridRatio;
                
                createConstellationLine(fromX, fromY, toX, toY);
            }
        }
        
        // 顯示結果消息
        function showResultMessage(message, isSuccess) {
            resultMessage.textContent = message;
            resultMessage.style.display = 'block';
            
            // 設置樣式
            resultMessage.className = isSuccess ? 
                'result-message result-success' : 
                'result-message result-fail';
                
            // 效果
            resultMessage.classList.add('pulse-animation');
            setTimeout(() => {
                resultMessage.classList.remove('pulse-animation');
            }, 500);
            
            // 添加淡入效果
            resultMessage.style.opacity = 0;
            setTimeout(() => {
                resultMessage.style.transition = 'opacity 0.3s';
                resultMessage.style.opacity = 1;
            }, 10);
        }
        
        // 重置線條
        function resetLines() {
            userLines = [];
            selectedPoint = null;
            isComplete = false;
            
            const requiredLines = levels[currentLevelIndex].requiredLines || 2;
            document.getElementById('status').textContent = `Connected: 0 lines (need to connect ${requiredLines} lines)`;
            
            // 隱藏結果訊息
            resultMessage.style.display = 'none';
            
            // 播放點擊音效
            playSound('click');
            
            // 清除效果
            clearEffects();
            
            drawGame();
        }
        
        // 獲取點集合（包括預設線端點和用戶連線端點）
        function getShapePoints() {
            const level = levels[currentLevelIndex];
            const requiredLines = level.requiredLines || 2;
            
            if (userLines.length !== requiredLines) return null;
            
            const presetLine = level.presetLine;
            const points = new Set();
            
            // 添加預設線的兩個端點
            points.add(JSON.stringify(presetLine.from));
            points.add(JSON.stringify(presetLine.to));
            
            // 添加用戶連線的所有點
            for (const line of userLines) {
                points.add(JSON.stringify(line.from));
                points.add(JSON.stringify(line.to));
            }
            
            // 轉換回對象格式
            const shapePoints = Array.from(points).map(p => JSON.parse(p));
            
            // 三角形需要3個點，四邊形需要4個點
            const expectedPointCount = level.type === "triangle" ? 3 : 4;
            
            if (shapePoints.length !== expectedPointCount) {
                if (debugMode) {
                    console.warn(`點數量不符: 期望${expectedPointCount}個點, 實際${shapePoints.length}個點`);
                }
                return null;
            }
            
            return shapePoints;
        }
        
        // 獲取三角形的三個點
        function getTrianglePoints() {
            if (userLines.length !== 2) return null;
            
            const presetLine = levels[currentLevelIndex].presetLine;
            const presetPoints = [presetLine.from, presetLine.to];
            
            // 找出第三個點（不在預設線上的點）
            let thirdPoint = null;
            
            for (const line of userLines) {
                if (!isPointInArray(line.from, presetPoints)) {
                    thirdPoint = line.from;
                    break;
                }
                if (!isPointInArray(line.to, presetPoints)) {
                    thirdPoint = line.to;
                    break;
                }
            }
            
            if (!thirdPoint) return null;
            
            return {
                p1: presetLine.from,
                p2: presetLine.to,
                p3: thirdPoint
            };
        }
        
        // 獲取四邊形的四個點（按照順時針或逆時針順序）
        function getQuadrilateralPoints() {
            const points = getShapePoints();
            if (!points || points.length !== 4) return null;
            
            // 找出中心點
            const centerX = points.reduce((sum, p) => sum + p.col, 0) / 4;
            const centerY = points.reduce((sum, p) => sum + p.row, 0) / 4;
            
            // 按照角度排序（順時針或逆時針都可以）
            points.sort((a, b) => {
                const angleA = Math.atan2(a.row - centerY, a.col - centerX);
                const angleB = Math.atan2(b.row - centerY, b.col - centerX);
                return angleA - angleB;
            });
            
            if (debugMode) {
                console.log("排序後的四邊形頂點:", 
                    points.map(p => `(${p.row},${p.col})`).join(' -> '));
            }
            
            // 返回排序後的四個點
            return {
                p1: points[0],
                p2: points[1],
                p3: points[2],
                p4: points[3]
            };
        }
        
        // 檢查點是否在數組中
        function isPointInArray(point, pointArray) {
            return pointArray.some(p => p.row === point.row && p.col === point.col);
        }
        
        // 計算兩點之間的距離
        function calculateDistance(p1, p2) {
            return Math.sqrt(
                Math.pow((p1.col - p2.col), 2) + 
                Math.pow((p1.row - p2.row), 2)
            );
        }
        
        // 計算斜率
        function calculateSlope(p1, p2) {
            // 避免除以零的情況
            if (p1.col === p2.col) return Infinity;
            return (p1.row - p2.row) / (p1.col - p2.col);
        }
        
        // 計算向量
        function calculateVector(p1, p2) {
            return {
                x: p2.col - p1.col,
                y: p2.row - p1.row
            };
        }
        
        // 計算向量的點積
        function dotProduct(v1, v2) {
            return v1.x * v2.x + v1.y * v2.y;
        }
        
        // 計算向量的模（長度）
        function vectorMagnitude(v) {
            return Math.sqrt(v.x * v.x + v.y * v.y);
        }
        
        // 計算兩個向量之間的角度（弧度）
        function calculateAngle(v1, v2) {
            const dot = dotProduct(v1, v2);
            const mag1 = vectorMagnitude(v1);
            const mag2 = vectorMagnitude(v2);
            
            // 防止除以零或計算誤差
            if (mag1 === 0 || mag2 === 0) return 0;
            
            // 確保值在-1到1之間以避免因計算誤差導致的acos錯誤
            const cosTheta = Math.max(-1, Math.min(1, dot / (mag1 * mag2)));
            return Math.acos(cosTheta);
        }
        
        // 檢查兩條線是否平行
        function areLinesParallel(line1Start, line1End, line2Start, line2End) {
            const v1 = calculateVector(line1Start, line1End);
            const v2 = calculateVector(line2Start, line2End);
            
            // 平行向量的叉積為零
            const crossProduct = v1.x * v2.y - v1.y * v2.x;
            
            // 考慮浮點數誤差，使用較寬鬆的標準
            const tolerance = 0.15 * vectorMagnitude(v1) * vectorMagnitude(v2);
            return Math.abs(crossProduct) < tolerance;
        }
        
        // 檢查兩條線是否垂直
        function areLinesOrthogonal(line1Start, line1End, line2Start, line2End) {
            const v1 = calculateVector(line1Start, line1End);
            const v2 = calculateVector(line2Start, line2End);
            
            // 垂直向量的點積為零
            const dot = dotProduct(v1, v2);
            
            // 考慮浮點數誤差
            const tolerance = 0.15 * vectorMagnitude(v1) * vectorMagnitude(v2);
            return Math.abs(dot) < tolerance;
        }
        
        // 檢查是否為等腰三角形
        function isIsoscelesTriangle() {
            const points = getTrianglePoints();
            if (!points) return false;
            
            // 計算三條邊的長度
            const d1 = calculateDistance(points.p1, points.p2);
            const d2 = calculateDistance(points.p2, points.p3);
            const d3 = calculateDistance(points.p3, points.p1);
            
            // 使用較嚴格的容差
            const tolerance = 0.08; // 更嚴格的容差來判斷相等
            const notEqualTolerance = 0.15; // 判斷不相等的容差
            
            // 使用比率而不是絕對差值來處理較大的三角形
            const ratio12 = Math.abs(d1 - d2) / Math.max(d1, d2);
            const ratio23 = Math.abs(d2 - d3) / Math.max(d2, d3);
            const ratio31 = Math.abs(d3 - d1) / Math.max(d3, d1);
            
            if (debugMode) {
                console.log(`等腰檢測: 邊長 ${d1.toFixed(2)}, ${d2.toFixed(2)}, ${d3.toFixed(2)}`);
                console.log(`比率: ${ratio12.toFixed(4)}, ${ratio23.toFixed(4)}, ${ratio31.toFixed(4)}`);
                console.log(`相等閾值: ${tolerance}, 不相等閾值: ${notEqualTolerance}`);
            }
            
            // 等腰三角形必須恰好有兩條邊相等，第三條邊不等於其他兩條
            const sides12Equal = ratio12 < tolerance;
            const sides23Equal = ratio23 < tolerance;
            const sides31Equal = ratio31 < tolerance;
            
            // 檢查是否為等邊三角形（三條邊都相等）
            const isEquilateral = sides12Equal && sides23Equal && sides31Equal;
            
            // 返回true只有在恰好兩條邊相等並且不是等邊三角形的情況
            return !isEquilateral && (
                (sides12Equal && !sides23Equal && !sides31Equal) ||
                (!sides12Equal && sides23Equal && !sides31Equal) ||
                (!sides12Equal && !sides23Equal && sides31Equal)
            );
        }
        
        // 檢查是否為等邊三角形
        function isEquilateralTriangle() {
            const points = getTrianglePoints();
            if (!points) return false;
            
            // 計算三條邊的長度
            const d1 = calculateDistance(points.p1, points.p2);
            const d2 = calculateDistance(points.p2, points.p3);
            const d3 = calculateDistance(points.p3, points.p1);
            
            // 使用更寬鬆的容差，讓更多視覺上正確的三角形能被接受
            const tolerance = 0.15; // 增加容差到15%
            
            // 使用多種檢測方法結合判斷
            
            // 方法1: 邊長比率檢測
            const ratio12 = Math.abs(d1 - d2) / Math.max(d1, d2);
            const ratio23 = Math.abs(d2 - d3) / Math.max(d2, d3);
            const ratio31 = Math.abs(d3 - d1) / Math.max(d3, d1);
            
            // 計算最大偏差
            const maxRatio = Math.max(ratio12, ratio23, ratio31);
            const edgeRatioCheck = maxRatio < tolerance;
            
            // 方法2: 角度檢測 (60度角檢測)
            // 計算三個向量
            const v1 = calculateVector(points.p1, points.p2);
            const v2 = calculateVector(points.p2, points.p3);
            const v3 = calculateVector(points.p3, points.p1);
            
            // 計算夾角 (理想情況是60度，即π/3弧度)
            const angle1 = calculateAngle({x: -v3.x, y: -v3.y}, v1);
            const angle2 = calculateAngle({x: -v1.x, y: -v1.y}, v2);
            const angle3 = calculateAngle({x: -v2.x, y: -v2.y}, v3);
            
            // 檢查角度是否接近60度(π/3)
            const angleTolerance = 0.15; // 角度容差
            const angleCheck = (
                Math.abs(angle1 - Math.PI/3) < angleTolerance * Math.PI/3 &&
                Math.abs(angle2 - Math.PI/3) < angleTolerance * Math.PI/3 &&
                Math.abs(angle3 - Math.PI/3) < angleTolerance * Math.PI/3
            );
            
            // 方法3: 使用預設解法檢測 (比較與解答點的近似度)
            let solutionCheck = false;
            const level = levels[currentLevelIndex];
            if (level.solutionPoint) {
                // 檢查第三點是否接近預設的解答點
                const solutionDist = calculateDistance(points.p3, level.solutionPoint);
                solutionCheck = solutionDist < 1.5; // 如果點在解答附近，也認為正確
            }
            
            if (debugMode) {
                console.log(`等邊檢測: 邊長 ${d1.toFixed(2)}, ${d2.toFixed(2)}, ${d3.toFixed(2)}`);
                console.log(`邊長比率: ${ratio12.toFixed(4)}, ${ratio23.toFixed(4)}, ${ratio31.toFixed(4)}`);
                console.log(`最大偏差: ${maxRatio.toFixed(4)}, 閾值: ${tolerance}`);
                console.log(`角度檢測: ${angleCheck}, 解答檢測: ${solutionCheck}`);
            }
            
            // 放寬標準：只要滿足邊長比例或角度檢測的任一項，就認為是等邊三角形
            return edgeRatioCheck || angleCheck || solutionCheck;
        }
        
        // 檢查是否為直角三角形
        function isRightTriangle() {
            const points = getTrianglePoints();
            if (!points) return false;
            
            // 計算三邊長平方
            const sides = [
                {
                    squared: Math.pow(points.p1.col - points.p2.col, 2) + Math.pow(points.p1.row - points.p2.row, 2),
                    points: [points.p1, points.p2]
                },
                {
                    squared: Math.pow(points.p2.col - points.p3.col, 2) + Math.pow(points.p2.row - points.p3.row, 2),
                    points: [points.p2, points.p3]
                },
                {
                    squared: Math.pow(points.p3.col - points.p1.col, 2) + Math.pow(points.p3.row - points.p1.row, 2),
                    points: [points.p3, points.p1]
                }
            ].sort((a, b) => a.squared - b.squared);
            
            // 檢查畢氏定理 a² + b² = c²
            const tolerance = 0.15; // 使用較寬鬆的容差
            const pythagoreanRatio = sides[2].squared / (sides[0].squared + sides[1].squared);
            
            // 使用向量方法驗證
            const v1 = calculateVector(sides[0].points[0], sides[0].points[1]);
            const v2 = calculateVector(sides[1].points[0], sides[1].points[1]);
            const dotProduct = v1.x * v2.x + v1.y * v2.y;
            
            // 正交向量的點積應接近於零
            const orthogonalCheck = Math.abs(dotProduct) / (vectorMagnitude(v1) * vectorMagnitude(v2)) < 0.15;
            
            if (debugMode) {
                console.log(`直角檢測: 畢氏比率 ${pythagoreanRatio.toFixed(4)}`);
                console.log(`正交檢查: ${orthogonalCheck}`);
            }
            
            return Math.abs(pythagoreanRatio - 1) < tolerance || orthogonalCheck;
        }
        
        // 檢查是否為直角等腰三角形
        function isRightIsoscelesTriangle() {
            const points = getTrianglePoints();
            if (!points) return false;
            
            // 計算三條邊的長度和平方
            const sides = [
                {
                    length: calculateDistance(points.p1, points.p2),
                    squared: Math.pow(points.p1.col - points.p2.col, 2) + Math.pow(points.p1.row - points.p2.row, 2),
                    points: [points.p1, points.p2]
                },
                {
                    length: calculateDistance(points.p2, points.p3),
                    squared: Math.pow(points.p2.col - points.p3.col, 2) + Math.pow(points.p2.row - points.p3.row, 2),
                    points: [points.p2, points.p3]
                },
                {
                    length: calculateDistance(points.p3, points.p1),
                    squared: Math.pow(points.p3.col - points.p1.col, 2) + Math.pow(points.p3.row - points.p1.row, 2),
                    points: [points.p3, points.p1]
                }
            ].sort((a, b) => a.squared - b.squared);
            
            // 兩條短邊的比例
            const tolerance = 0.15; // 使用較寬鬆的容差
            const isoscelesRatio = Math.abs(sides[0].length - sides[1].length) / Math.max(sides[0].length, sides[1].length);
            
            // 畢氏定理檢查
            const pythagoreanRatio = sides[2].squared / (sides[0].squared + sides[1].squared);
            
            if (debugMode) {
                console.log(`直角等腰檢測: 等腰比率 ${isoscelesRatio.toFixed(4)}, 畢氏比率 ${pythagoreanRatio.toFixed(4)}`);
            }
            
            return isoscelesRatio < tolerance && Math.abs(pythagoreanRatio - 1) < tolerance;
        }
        
        // 檢查是否為不等邊三角形
        function isScaleneTriangle() {
            const points = getTrianglePoints();
            if (!points) return false;
            
            // 計算三條邊的長度
            const d1 = calculateDistance(points.p1, points.p2);
            const d2 = calculateDistance(points.p2, points.p3);
            const d3 = calculateDistance(points.p3, points.p1);
            
            // 檢查所有邊的比例不相等
            const tolerance = 0.15; // 使用較寬鬆的容差
            
            // 使用比率檢查
            const ratio12 = Math.abs(d1 - d2) / Math.max(d1, d2);
            const ratio23 = Math.abs(d2 - d3) / Math.max(d2, d3);
            const ratio31 = Math.abs(d3 - d1) / Math.max(d3, d1);
            
            if (debugMode) {
                console.log(`不等邊檢測: 邊長 ${d1.toFixed(2)}, ${d2.toFixed(2)}, ${d3.toFixed(2)}`);
                console.log(`比率: ${ratio12.toFixed(4)}, ${ratio23.toFixed(4)}, ${ratio31.toFixed(4)}`);
            }
            
            // 所有邊都不相等，也就是沒有兩條邊相等
            return ratio12 > tolerance && ratio23 > tolerance && ratio31 > tolerance;
        }
        
        // 檢查是否為正方形
        function isSquare() {
            const points = getQuadrilateralPoints();
            if (!points) return false;
            
            // 獲取四邊
            const edges = [
                {
                    length: calculateDistance(points.p1, points.p2),
                    vector: calculateVector(points.p1, points.p2)
                },
                {
                    length: calculateDistance(points.p2, points.p3),
                    vector: calculateVector(points.p2, points.p3)
                },
                {
                    length: calculateDistance(points.p3, points.p4),
                    vector: calculateVector(points.p3, points.p4)
                },
                {
                    length: calculateDistance(points.p4, points.p1),
                    vector: calculateVector(points.p4, points.p1)
                }
            ];
            
            // 計算對角線
            const diag1 = calculateDistance(points.p1, points.p3);
            const diag2 = calculateDistance(points.p2, points.p4);
            
            // 檢查所有邊是否嚴格相等 - 使用更嚴格的容差
            const tolerance = 0.06; // 更嚴格的容差，一般長方形不會通過此檢查
            const avgLength = edges.reduce((sum, edge) => sum + edge.length, 0) / 4;
            
            // 檢查每條邊與平均值的偏差
            const edgeDeviations = edges.map(edge => 
                Math.abs(edge.length - avgLength) / avgLength
            );
            
            const maxDeviation = Math.max(...edgeDeviations);
            const allSidesEqual = maxDeviation < tolerance;
            
            if (debugMode) {
                console.log(`正方形檢測 - 最大邊長偏差率: ${maxDeviation.toFixed(4)}, 閾值: ${tolerance}`);
                console.log(`正方形檢測 - 四邊長度: ${edges.map(e => e.length.toFixed(2)).join(', ')}`);
            }
            
            // 檢查對角線是否近似相等
            const diagRatio = Math.abs(diag1 - diag2) / Math.max(diag1, diag2);
            const diagEqual = diagRatio < tolerance;
            
            if (debugMode) {
                console.log(`正方形檢測 - 對角線比率: ${diagRatio.toFixed(4)}, 閾值: ${tolerance}`);
            }
            
            // 檢查相鄰邊是否嚴格垂直
            const anglesTolerance = 0.08; // 更嚴格的角度容差
            const rightAngles = [
                Math.abs(Math.PI/2 - calculateAngle(edges[0].vector, edges[1].vector)),
                Math.abs(Math.PI/2 - calculateAngle(edges[1].vector, edges[2].vector)),
                Math.abs(Math.PI/2 - calculateAngle(edges[2].vector, edges[3].vector)),
                Math.abs(Math.PI/2 - calculateAngle(edges[3].vector, edges[0].vector))
            ];
            
            const maxAngleDeviation = Math.max(...rightAngles);
            const hasRightAngles = maxAngleDeviation < anglesTolerance;
            
            if (debugMode) {
                console.log(`正方形檢測 - 最大角度偏差: ${(maxAngleDeviation * 180 / Math.PI).toFixed(2)}度, 閾值: ${(anglesTolerance * 180 / Math.PI).toFixed(2)}度`);
            }
            
            // 這三個條件必須同時滿足
            return allSidesEqual && diagEqual && hasRightAngles;
        }
        
        // 檢查是否為長方形
        function isRectangle() {
            const points = getQuadrilateralPoints();
            if (!points) return false;
            
            // 獲取四邊
            const edges = [
                {
                    length: calculateDistance(points.p1, points.p2),
                    vector: calculateVector(points.p1, points.p2)
                },
                {
                    length: calculateDistance(points.p2, points.p3),
                    vector: calculateVector(points.p2, points.p3)
                },
                {
                    length: calculateDistance(points.p3, points.p4),
                    vector: calculateVector(points.p3, points.p4)
                },
                {
                    length: calculateDistance(points.p4, points.p1),
                    vector: calculateVector(points.p4, points.p1)
                }
            ];
            
            // 對邊應該相等，但相鄰邊可能不等
            const tolerance = 0.1; // 對邊相等的容差
            
            // 檢查對邊是否相等（第1、3邊相等，第2、4邊相等）
            const ratio13 = Math.abs(edges[0].length - edges[2].length) / Math.max(edges[0].length, edges[2].length);
            const ratio24 = Math.abs(edges[1].length - edges[3].length) / Math.max(edges[1].length, edges[3].length);
            
            const oppositeSidesEqual = ratio13 < tolerance && ratio24 < tolerance;
            
            if (debugMode) {
                console.log(`長方形檢測 - 對邊比率: ${ratio13.toFixed(4)}, ${ratio24.toFixed(4)}, 閾值: ${tolerance}`);
            }
            
            // 計算對角線
            const diag1 = calculateDistance(points.p1, points.p3);
            const diag2 = calculateDistance(points.p2, points.p4);
            
            // 檢查對角線是否相等
            const diagRatio = Math.abs(diag1 - diag2) / Math.max(diag1, diag2);
            const diagEqual = diagRatio < tolerance;
            
            if (debugMode) {
                console.log(`長方形檢測 - 對角線比率: ${diagRatio.toFixed(4)}, 閾值: ${tolerance}`);
            }
            
            // 檢查是否有直角
            const anglesTolerance = 0.08; // 更嚴格的角度容差
            const angles = [
                Math.abs(Math.PI/2 - calculateAngle(
                    {x: -edges[0].vector.x, y: -edges[0].vector.y}, 
                    edges[3].vector
                )),
                Math.abs(Math.PI/2 - calculateAngle(
                    {x: -edges[1].vector.x, y: -edges[1].vector.y}, 
                    edges[0].vector
                )),
                Math.abs(Math.PI/2 - calculateAngle(
                    {x: -edges[2].vector.x, y: -edges[2].vector.y}, 
                    edges[1].vector
                )),
                Math.abs(Math.PI/2 - calculateAngle(
                    {x: -edges[3].vector.x, y: -edges[3].vector.y}, 
                    edges[2].vector
                ))
            ];
            
            const maxAngleDeviation = Math.max(...angles);
            const hasRightAngles = maxAngleDeviation < anglesTolerance;
            
            if (debugMode) {
                console.log(`長方形檢測 - 最大角度偏差: ${(maxAngleDeviation * 180 / Math.PI).toFixed(2)}度, 閾值: ${(anglesTolerance * 180 / Math.PI).toFixed(2)}度`);
            }
            
            // 額外檢查：確保不是正方形
            // 檢查相鄰邊是否不等（至少有一組相鄰邊差異較大）
            const adjacentRatio12 = Math.abs(edges[0].length - edges[1].length) / Math.max(edges[0].length, edges[1].length);
            const adjacentRatio23 = Math.abs(edges[1].length - edges[2].length) / Math.max(edges[1].length, edges[2].length);
            const adjacentRatio34 = Math.abs(edges[2].length - edges[3].length) / Math.max(edges[2].length, edges[3].length);
            const adjacentRatio41 = Math.abs(edges[3].length - edges[0].length) / Math.max(edges[3].length, edges[0].length);
            
            // 至少有一組相鄰邊差異較大（不是正方形）
            const squareTolerance = 0.06; // 與正方形判斷一致
            const notSquare = adjacentRatio12 > squareTolerance || 
                              adjacentRatio23 > squareTolerance ||
                              adjacentRatio34 > squareTolerance ||
                              adjacentRatio41 > squareTolerance;
            
            if (debugMode) {
                console.log(`長方形檢測 - 非正方形檢查: ${notSquare}, 相鄰邊比率: ${adjacentRatio12.toFixed(4)}, ${adjacentRatio23.toFixed(4)}, ${adjacentRatio34.toFixed(4)}, ${adjacentRatio41.toFixed(4)}`);
            }
            
            // 長方形條件：對邊相等、對角線相等、有直角，但不是正方形
            return oppositeSidesEqual && diagEqual && hasRightAngles && notSquare;
        }
        
        // 檢查是否為平行四邊形
        function isParallelogram() {
            const points = getQuadrilateralPoints();
            if (!points) return false;
            
            // 獲取四邊
            const edges = [
                {
                    length: calculateDistance(points.p1, points.p2),
                    vector: calculateVector(points.p1, points.p2)
                },
                {
                    length: calculateDistance(points.p2, points.p3),
                    vector: calculateVector(points.p2, points.p3)
                },
                {
                    length: calculateDistance(points.p3, points.p4),
                    vector: calculateVector(points.p3, points.p4)
                },
                {
                    length: calculateDistance(points.p4, points.p1),
                    vector: calculateVector(points.p4, points.p1)
                }
            ];
            
            // 檢查對邊是否平行和相等
            const tolerance = 0.15; // 使用較寬鬆的容差
            
            // 檢查對邊是否相等
            const oppositeSidesEqual = 
                Math.abs(edges[0].length - edges[2].length) / Math.max(edges[0].length, edges[2].length) < tolerance &&
                Math.abs(edges[1].length - edges[3].length) / Math.max(edges[1].length, edges[3].length) < tolerance;
            
            // 檢查對邊是否平行
            const parallelCheck1 = areLinesParallel(
                points.p1, points.p2,
                points.p3, points.p4
            );
            
            const parallelCheck2 = areLinesParallel(
                points.p2, points.p3,
                points.p4, points.p1
            );
            
            if (debugMode) {
                console.log(`平行四邊形檢測: 對邊相等 ${oppositeSidesEqual}, 平行檢查1 ${parallelCheck1}, 平行檢查2 ${parallelCheck2}`);
                console.log(`邊長: ${edges.map(e => e.length.toFixed(2)).join(', ')}`);
            }
            
            // 檢查是否是長方形或正方形
            const isRect = isRectangle();
            const isSq = isSquare();
            
            // 是平行四邊形但不是長方形或正方形
            return oppositeSidesEqual && parallelCheck1 && parallelCheck2 && !isRect && !isSq;
        }
        
        // 滑鼠事件處理
        function handleMouseMove(e) {
            if (!isGameActive) return;
            
            const rect = canvas.getBoundingClientRect();
            const x = e.clientX - rect.left;
            const y = e.clientY - rect.top;
            
            // 更新懸停點
            const previousHovered = hoveredPoint;
            hoveredPoint = findGridPoint(x, y);
            
            // 如果懸停點發生變化，添加星星閃爍動畫
            if (hoveredPoint && (!previousHovered || 
                previousHovered.row !== hoveredPoint.row || 
                previousHovered.col !== hoveredPoint.col)) {
                playSound('click');
                
                // 當懸停到新點時，可以添加粒子效果
                const gridRatio = (canvas.width - 2 * offsetX) / (numCols * gridSize);
                const pointX = offsetX + hoveredPoint.col * gridSize * gridRatio;
                const pointY = offsetY + hoveredPoint.row * gridSize * gridRatio;
                
                // 添加微弱的粒子效果
                for (let i = 0; i < 3; i++) {
                    setTimeout(() => {
                        const angle = Math.random() * Math.PI * 2;
                        const distance = Math.random() * 15;
                        createParticle(
                            rect.left + pointX + Math.cos(angle) * distance, 
                            rect.top + pointY + Math.sin(angle) * distance
                        );
                    }, i * 50);
                }
            }
            
            // 更新拖動線的終點
            if (selectedPoint !== null) {
                lastMouseX = x;
                lastMouseY = y;
            }
            
            // 更新工具提示
            updateTooltip(e);
            
            drawGame();
        }
        
        function updateTooltip(e) {
            if (hoveredPoint) {
                tooltip.style.display = 'block';
                tooltip.style.left = (e.clientX + 10) + 'px';
                tooltip.style.top = (e.clientY + 10) + 'px';
                
                if (selectedPoint === null) {
                    tooltip.textContent = 'Click this star to start connecting';
                } else if (hoveredPoint.row === selectedPoint.row && hoveredPoint.col === selectedPoint.col) {
                    tooltip.textContent = 'Cancel selection of this star';
                } else if (canConnectPoints(selectedPoint, hoveredPoint)) {
                    tooltip.textContent = 'Connect to this star';
                } else {
                    tooltip.textContent = 'These two points are already connected';
                }
                
                // 漸變出現效果
                tooltip.style.opacity = 0;
                tooltip.style.transition = 'opacity 0.3s';
                setTimeout(() => {
                    tooltip.style.opacity = 1;
                }, 10);
            } else {
                tooltip.style.opacity = 0;
                setTimeout(() => {
                    tooltip.style.display = 'none';
                }, 300);
            }
        }
        
        function handleMouseDown(e) {
            if (!isGameActive || isComplete) return;
            
            const rect = canvas.getBoundingClientRect();
            const x = e.clientX - rect.left;
            const y = e.clientY - rect.top;
            
            const gridPoint = findGridPoint(x, y);
            
            if (gridPoint) {
                if (selectedPoint && selectedPoint.row === gridPoint.row && selectedPoint.col === gridPoint.col) {
                    // 取消選擇
                    selectedPoint = null;
                    playSound('click');
                } else if (selectedPoint === null) {
                    // 選擇第一個點
                    selectedPoint = gridPoint;
                    playSound('click');
                    
                    // 獲取Canvas相對於視窗的位置和座標
                    const gridRatio = (canvas.width - 2 * offsetX) / (numCols * gridSize);
                    const pointX = offsetX + selectedPoint.col * gridSize * gridRatio;
                    const pointY = offsetY + selectedPoint.row * gridSize * gridRatio;
                    
                    // 選擇點時的粒子效果
                    for (let i = 0; i < 8; i++) {
                        setTimeout(() => {
                            const angle = Math.random() * Math.PI * 2;
                            const distance = Math.random() * 20;
                            createParticle(
                                rect.left + pointX + Math.cos(angle) * distance, 
                                rect.top + pointY + Math.sin(angle) * distance,
                                'rgba(255, 215, 0, 0.8)'
                            );
                        }, i * 30);
                    }
                } else if (canConnectPoints(selectedPoint, gridPoint)) {
                    // 連接到第二個點
                    userLines.push({
                        from: selectedPoint,
                        to: gridPoint
                    });
                    
                    // 獲取點座標
                    const gridRatio = (canvas.width - 2 * offsetX) / (numCols * gridSize);
                    const fromX = offsetX + selectedPoint.col * gridSize * gridRatio;
                    const fromY = offsetY + selectedPoint.row * gridSize * gridRatio;
                    const toX = offsetX + gridPoint.col * gridSize * gridRatio;
                    const toY = offsetY + gridPoint.row * gridSize * gridRatio;
                    
                    // 創建連接效果
                    createConnectionLine(selectedPoint, gridPoint);
                    
                    selectedPoint = null;
                    playSound('connect');
                    
                    // 獲取當前關卡所需的線條數
                    const requiredLines = levels[currentLevelIndex].requiredLines || 2;
                    
                    // 自動檢測 - 如果完成所需線條數
                    if (userLines.length === requiredLines) {
                        // 短暫延遲讓用戶看到完成的形狀
                        setTimeout(() => checkShape(), 300);
                    }
                }
            }
            
            lastMouseX = x;
            lastMouseY = y;
            
            drawGame();
        }
        
        function handleMouseUp(e) {
            if (!isGameActive || !selectedPoint || isComplete) return;
            
            const rect = canvas.getBoundingClientRect();
            const x = e.clientX - rect.left;
            const y = e.clientY - rect.top;
            
            const gridPoint = findGridPoint(x, y);
            
            if (gridPoint && canConnectPoints(selectedPoint, gridPoint)) {
                // 連接到第二個點
                userLines.push({
                    from: selectedPoint,
                    to: gridPoint
                });
                
                // 創建連接效果
                createConnectionLine(selectedPoint, gridPoint);
                
                playSound('connect');
                
                // 獲取當前關卡所需的線條數
                const requiredLines = levels[currentLevelIndex].requiredLines || 2;
                
                // 自動檢測 - 如果完成所需線條數
                if (userLines.length === requiredLines) {
                    // 短暫延遲讓用戶看到完成的形狀
                    setTimeout(() => checkShape(), 300);
                }
            }
            
            selectedPoint = null;
            drawGame();
        }
        
        // 觸控事件處理
        function handleTouchStart(e) {
            if (!isGameActive || isComplete) return;
            
            e.preventDefault();
            const rect = canvas.getBoundingClientRect();
            const touch = e.touches[0];
            const x = touch.clientX - rect.left;
            const y = touch.clientY - rect.top;
            
            const gridPoint = findGridPoint(x, y);
            
            if (gridPoint) {
                if (selectedPoint && selectedPoint.row === gridPoint.row && selectedPoint.col === gridPoint.col) {
                    // 取消選擇
                    selectedPoint = null;
                    playSound('click');
                } else if (selectedPoint === null) {
                    // 選擇第一個點
                    selectedPoint = gridPoint;
                    playSound('click');
                    
                    // 獲取Canvas相對於視窗的位置和座標
                    const gridRatio = (canvas.width - 2 * offsetX) / (numCols * gridSize);
                    const pointX = offsetX + selectedPoint.col * gridSize * gridRatio;
                    const pointY = offsetY + selectedPoint.row * gridSize * gridRatio;
                    
                    // 選擇點時的粒子效果
                    for (let i = 0; i < 8; i++) {
                        setTimeout(() => {
                            const angle = Math.random() * Math.PI * 2;
                            const distance = Math.random() * 20;
                            createParticle(
                                rect.left + pointX + Math.cos(angle) * distance, 
                                rect.top + pointY + Math.sin(angle) * distance,
                                'rgba(255, 215, 0, 0.8)'
                            );
                        }, i * 30);
                    }
                } else if (canConnectPoints(selectedPoint, gridPoint)) {
                    // 連接到第二個點
                    userLines.push({
                        from: selectedPoint,
                        to: gridPoint
                    });
                    
                    // 創建連接效果
                    createConnectionLine(selectedPoint, gridPoint);
                    
                    selectedPoint = null;
                    playSound('connect');
                    
                    // 獲取當前關卡所需的線條數
                    const requiredLines = levels[currentLevelIndex].requiredLines || 2;
                    
                    // 自動檢測 - 如果完成所需線條數
                    if (userLines.length === requiredLines) {
                        // 短暫延遲讓用戶看到完成的形狀
                        setTimeout(() => checkShape(), 300);
                    }
                }
            }
            
            lastMouseX = x;
            lastMouseY = y;
            
            drawGame();
        }
        
        function handleTouchMove(e) {
            if (!isGameActive || selectedPoint === null || isComplete) return;
            
            e.preventDefault();
            const rect = canvas.getBoundingClientRect();
            const touch = e.touches[0];
            lastMouseX = touch.clientX - rect.left;
            lastMouseY = touch.clientY - rect.top;
            
            // 更新懸停點
            hoveredPoint = findGridPoint(lastMouseX, lastMouseY);
            
            drawGame();
        }
        
        function handleTouchEnd(e) {
            if (!isGameActive || !selectedPoint || isComplete) return;
            
            const rect = canvas.getBoundingClientRect();
            let x, y;
            
            if (e.changedTouches && e.changedTouches.length > 0) {
                const touch = e.changedTouches[0];
                x = touch.clientX - rect.left;
                y = touch.clientY - rect.top;
            } else {
                x = lastMouseX;
                y = lastMouseY;
            }
            
            const gridPoint = findGridPoint(x, y);
            
            if (gridPoint && canConnectPoints(selectedPoint, gridPoint)) {
                // 連接到第二個點
                userLines.push({
                    from: selectedPoint,
                    to: gridPoint
                });
                
                // 創建連接效果
                createConnectionLine(selectedPoint, gridPoint);
                
                playSound('connect');
                
                // 獲取當前關卡所需的線條數
                const requiredLines = levels[currentLevelIndex].requiredLines || 2;
                
                // 自動檢測 - 如果完成所需線條數
                if (userLines.length === requiredLines) {
                    // 短暫延遲讓用戶看到完成的形狀
                    setTimeout(() => checkShape(), 300);
                }
            }
            
            selectedPoint = null;
            drawGame();
        }
        
        // 在控制台啟用debug模式的方法
        window.enableDebug = function() {
            debugMode = true;
            console.log("調試模式已啟用");
        };
        
        window.disableDebug = function() {
            debugMode = false;
            console.log("調試模式已禁用");
        };
        
        // PWA Service Worker 註冊和安裝提示
        if ('serviceWorker' in navigator) {
            window.addEventListener('load', () => {
                // Service Worker 代碼
                const serviceWorkerCode = `
                    const CACHE_NAME = 'stellar-explorer-v1.0.0';
                    const urlsToCache = ['./'];

                    self.addEventListener('install', event => {
                        event.waitUntil(
                            caches.open(CACHE_NAME)
                                .then(cache => {
                                    console.log('🚀 PWA Cache opened');
                                    return cache.addAll(urlsToCache);
                                })
                        );
                        self.skipWaiting();
                    });

                    self.addEventListener('activate', event => {
                        console.log('✅ PWA Service Worker activated');
                        event.waitUntil(
                            caches.keys().then(cacheNames => {
                                return Promise.all(
                                    cacheNames.map(cacheName => {
                                        if (cacheName !== CACHE_NAME) {
                                            return caches.delete(cacheName);
                                        }
                                    })
                                );
                            })
                        );
                        self.clients.claim();
                    });

                    self.addEventListener('fetch', event => {
                        if (event.request.url.startsWith('http')) {
                            event.respondWith(
                                caches.match(event.request)
                                    .then(response => {
                                        if (response) {
                                            return response;
                                        }
                                        return fetch(event.request).then(response => {
                                            if (!response || response.status !== 200 || response.type !== 'basic') {
                                                return response;
                                            }
                                            const responseToCache = response.clone();
                                            caches.open(CACHE_NAME)
                                                .then(cache => {
                                                    cache.put(event.request, responseToCache);
                                                });
                                            return response;
                                        }).catch(() => {
                                            if (event.request.headers.get('accept').includes('text/html')) {
                                                return caches.match('./');
                                            }
                                        });
                                    })
                            );
                        }
                    });
                `;

                const blob = new Blob([serviceWorkerCode], { type: 'application/javascript' });
                const swUrl = URL.createObjectURL(blob);

                navigator.serviceWorker.register(swUrl)
                    .then(registration => {
                        console.log('🌟 PWA Service Worker registered:', registration.scope);
                    })
                    .catch(error => {
                        console.warn('❌ PWA Service Worker registration failed:', error);
                    });
            });
        }

        // PWA 安裝提示
        let deferredPrompt;
        let installPromptShown = false;

        window.addEventListener('beforeinstallprompt', (e) => {
            e.preventDefault();
            deferredPrompt = e;
            setTimeout(() => {
                showInstallPrompt();
            }, 5000);
        });

        function showInstallPrompt() {
            if (installPromptShown || !deferredPrompt) return;
            installPromptShown = true;

            const installBanner = document.createElement('div');
            installBanner.style.position = 'fixed';
            installBanner.style.top = '20px';
            installBanner.style.left = '50%';
            installBanner.style.transform = 'translateX(-50%)';
            installBanner.style.background = 'linear-gradient(135deg, rgba(93, 92, 222, 0.95), rgba(66, 64, 179, 0.95))';
            installBanner.style.color = 'white';
            installBanner.style.padding = '15px 25px';
            installBanner.style.borderRadius = '15px';
            installBanner.style.boxShadow = '0 8px 32px rgba(0, 0, 0, 0.3)';
            installBanner.style.border = '1px solid rgba(100, 255, 218, 0.3)';
            installBanner.style.zIndex = '10000';
            installBanner.style.maxWidth = '350px';
            installBanner.style.textAlign = 'center';
            installBanner.style.backdropFilter = 'blur(10px)';

            installBanner.innerHTML = 
                '<div style="margin-bottom: 10px;">' +
                    '<span style="font-size: 24px;">📱</span>' +
                    '<div style="font-size: 16px; font-weight: bold; margin: 5px 0;">Install Stellar Explorer</div>' +
                    '<div style="font-size: 13px; opacity: 0.9;">Add to your home screen for the best experience!</div>' +
                '</div>' +
                '<div>' +
                    '<button id="installBtn" style="background: linear-gradient(135deg, #64FFDA, #00D0B6); color: #0A0B2F; border: none; padding: 8px 20px; border-radius: 20px; margin: 5px; cursor: pointer; font-weight: bold; font-size: 14px;">Install App</button>' +
                    '<button id="dismissBtn" style="background: rgba(255, 255, 255, 0.2); color: white; border: 1px solid rgba(255, 255, 255, 0.3); padding: 8px 20px; border-radius: 20px; margin: 5px; cursor: pointer; font-size: 14px;">Later</button>' +
                '</div>';

            document.body.appendChild(installBanner);

            document.getElementById('installBtn').addEventListener('click', () => {
                installBanner.remove();
                deferredPrompt.prompt();
                deferredPrompt.userChoice.then((choiceResult) => {
                    if (choiceResult.outcome === 'accepted') {
                        console.log('📱 User accepted the PWA install prompt');
                    } else {
                        console.log('❌ User dismissed the PWA install prompt');
                    }
                    deferredPrompt = null;
                });
            });

            document.getElementById('dismissBtn').addEventListener('click', () => {
                installBanner.remove();
            });

            setTimeout(() => {
                if (document.body.contains(installBanner)) {
                    installBanner.remove();
                }
            }, 10000);
        }

        window.addEventListener('appinstalled', (evt) => {
            console.log('🎉 PWA was installed successfully');
        });

        function isPWA() {
            return window.matchMedia('(display-mode: standalone)').matches ||
                   window.navigator.standalone ||
                   document.referrer.includes('android-app://');
        }

        if (isPWA()) {
            console.log('🚀 Running as PWA!');
        }

        // 初始化遊戲
        window.onload = init;
    </script>
    <!-- MindCrafter 署名 -->
    <div style="text-align: center; margin-top: 15px; margin-bottom: 10px; font-size: 14px; opacity: 0.7;">
        <span style="color: #64FFDA;">@ MindCrafter</span>
    </div>
</body>
</html>

