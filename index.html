<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Stellar Explorer - Geometry Learning</title>
    
    <!-- PWA Meta Tags -->
    <meta name="description" content="Connect the stars to master geometry! Race against time in this cosmic adventure learning triangles, squares, and more.">
    <meta name="theme-color" content="#0A0B2F">
    <meta name="background-color" content="#0A0B2F">
    <meta name="display" content="standalone">
    <meta name="orientation" content="portrait">
    <meta name="start_url" content="./">
    >
    <!-- iOS PWA Support --
    <meta name="apple-mobile-web-app-capable" content="yes">
    <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
    <meta name="apple-mobile-web-app-title" content="Stellar Explorer">
    
    <!-- PWA Icons -->
    <!-- PWA Icons -->
    <link rel="icon" type="image/png" sizes="192x192" href="data:image/svg+xml,<svg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 192 192'><defs><radialGradient id='bg' cx='50%25' cy='50%25' r='50%25'><stop offset='0%25' style='stop-color:%23001122;stop-opacity:1' /><stop offset='100%25' style='stop-color:%230A0B2F;stop-opacity:1' /></radialGradient></defs><rect width='192' height='192' fill='url(%23bg)'/><circle cx='96' cy='70' r='3' fill='%23FFD700'/><circle cx='60' cy='90' r='2' fill='%2364FFDA'/><circle cx='130' cy='80' r='2.5' fill='%23FFFFFF'/><circle cx='80' cy='120' r='2' fill='%23FFD700'/><circle cx='120' cy='110' r='2' fill='%2364FFDA'/><polygon points='60,90 80,120 120,110' stroke='%2364FFDA' stroke-width='2' fill='none'/><text x='96' y='150' text-anchor='middle' fill='%2364FFDA' font-family='Arial,sans-serif' font-size='14' font-weight='bold'>STELLAR</text><text x='96' y='170' text-anchor='middle' fill='%23FFD700' font-family='Arial,sans-serif' font-size='12'>EXPLORER</text></svg>">
    <link rel="apple-touch-icon" href="data:image/svg+xml,<svg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 180 180'><defs><radialGradient id='bg2' cx='50%25' cy='50%25' r='50%25'><stop offset='0%25' style='stop-color:%23001122;stop-opacity:1' /><stop offset='100%25' style='stop-color:%230A0B2F;stop-opacity:1' /></radialGradient></defs><rect width='180' height='180' rx='40' fill='url(%23bg2)'/><circle cx='90' cy='65' r='3' fill='%23FFD700'/><circle cx='55' cy='85' r='2' fill='%2364FFDA'/><circle cx='125' cy='75' r='2.5' fill='%23FFFFFF'/><circle cx='75' cy='115' r='2' fill='%23FFD700'/><circle cx='115' cy='105' r='2' fill='%2364FFDA'/><polygon points='55,85 75,115 115,105' stroke='%2364FFDA' stroke-width='2' fill='none'/><text x='90' y='140' text-anchor='middle' fill='%2364FFDA' font-family='Arial,sans-serif' font-size='12' font-weight='bold'>STELLAR</text><text x='90' y='155' text-anchor='middle' fill='%23FFD700' font-family='Arial,sans-serif' font-size='10'>EXPLORER</text></svg>">
    
    <!-- PWA Manifest -->
    <script>
        // Inline Web App Manifest
        const manifestData = {
            "name": "Stellar Explorer - Geometry Learning Game",
            "short_name": "Stellar Explorer",
            "description": "Connect the stars to master geometry! Race against time in this cosmic adventure learning triangles, squares, and more.",
            "start_url": "./",
            "display": "standalone",
            "background_color": "#0A0B2F",
            "theme_color": "#0A0B2F",
            "orientation": "portrait-primary",
            "scope": "./",
            "categories": ["education", "games"],
            "screenshots": [
                {
                    "src": "data:image/svg+xml,<svg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 540 960'><defs><radialGradient id='bg' cx='50%25' cy='50%25' r='50%25'><stop offset='0%25' style='stop-color:%23001122;stop-opacity:1' /><stop offset='100%25' style='stop-color:%230A0B2F;stop-opacity:1' /></radialGradient></defs><rect width='540' height='960' fill='url(%23bg)'/><text x='270' y='100' text-anchor='middle' fill='%2364FFDA' font-family='Arial,sans-serif' font-size='32' font-weight='bold'>Stellar Explorer</text><rect x='45' y='150' width='450' height='450' fill='%23001122' rx='8'/><circle cx='120' cy='250' r='4' fill='%23FFD700'/><circle cx='200' cy='300' r='4' fill='%2364FFDA'/><circle cx='350' cy='280' r='4' fill='%23FFFFFF'/><circle cx='180' cy='400' r='4' fill='%23FFD700'/><circle cx='320' cy='380' r='4' fill='%2364FFDA'/><polygon points='120,250 180,400 320,380' stroke='%2364FFDA' stroke-width='3' fill='none'/><text x='270' y='700' text-anchor='middle' fill='%23FFD700' font-family='Arial,sans-serif' font-size='24'>Connect the Stars!</text><text x='270' y='750' text-anchor='middle' fill='%23FFFFFF' font-family='Arial,sans-serif' font-size='18'>Master Geometry in Space</text></svg>",
                    "sizes": "540x960",
                    "type": "image/svg+xml",
                    "form_factor": "narrow",
                    "label": "Stellar Explorer - Main Game Screen"
                },
                {
                    "src": "data:image/svg+xml,<svg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 960 540'><defs><radialGradient id='bg' cx='50%25' cy='50%25' r='50%25'><stop offset='0%25' style='stop-color:%23001122;stop-opacity:1' /><stop offset='100%25' style='stop-color:%230A0B2F;stop-opacity:1' /></radialGradient></defs><rect width='960' height='540' fill='url(%23bg)'/><text x='480' y='80' text-anchor='middle' fill='%2364FFDA' font-family='Arial,sans-serif' font-size='36' font-weight='bold'>Stellar Explorer - Time Challenge</text><rect x='255' y='120' width='450' height='300' fill='%23001122' rx='8'/><circle cx='330' cy='200' r='4' fill='%23FFD700'/><circle cx='410' cy='250' r='4' fill='%2364FFDA'/><circle cx='560' cy='230' r='4' fill='%23FFFFFF'/><circle cx='390' cy='350' r='4' fill='%23FFD700'/><circle cx='530' cy='330' r='4' fill='%2364FFDA'/><polygon points='330,200 390,350 530,330' stroke='%2364FFDA' stroke-width='3' fill='none'/><text x='480' y='480' text-anchor='middle' fill='%23FFD700' font-family='Arial,sans-serif' font-size='24'>Learn Geometry Through Play</text></svg>",
                    "sizes": "960x540",
                    "type": "image/svg+xml",
                    "form_factor": "wide",
                    "label": "Stellar Explorer - Desktop View"
                }
            ],
            "icons": [
                {
                    "src": "data:image/svg+xml,<svg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 72 72'><defs><radialGradient id='bg' cx='50%25' cy='50%25' r='50%25'><stop offset='0%25' style='stop-color:%23001122;stop-opacity:1' /><stop offset='100%25' style='stop-color:%230A0B2F;stop-opacity:1' /></radialGradient></defs><rect width='72' height='72' rx='16' fill='url(%23bg)'/><circle cx='36' cy='28' r='2' fill='%23FFD700'/><circle cx='26' cy='36' r='1.5' fill='%2364FFDA'/><circle cx='46' cy='32' r='1.5' fill='%23FFFFFF'/><circle cx='32' cy='48' r='1.5' fill='%23FFD700'/><circle cx='44' cy='44' r='1.5' fill='%2364FFDA'/><polygon points='26,36 32,48 44,44' stroke='%2364FFDA' stroke-width='1.5' fill='none'/></svg>",
                    "sizes": "72x72",
                    "type": "image/svg+xml",
                    "purpose": "any"
                },
                {
                    "src": "data:image/svg+xml,<svg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 96 96'><defs><radialGradient id='bg' cx='50%25' cy='50%25' r='50%25'><stop offset='0%25' style='stop-color:%23001122;stop-opacity:1' /><stop offset='100%25' style='stop-color:%230A0B2F;stop-opacity:1' /></radialGradient></defs><rect width='96' height='96' rx='20' fill='url(%23bg)'/><circle cx='48' cy='35' r='2.5' fill='%23FFD700'/><circle cx='35' cy='45' r='2' fill='%2364FFDA'/><circle cx='61' cy='40' r='2' fill='%23FFFFFF'/><circle cx='42' cy='60' r='2' fill='%23FFD700'/><circle cx='58' cy='55' r='2' fill='%2364FFDA'/><polygon points='35,45 42,60 58,55' stroke='%2364FFDA' stroke-width='2' fill='none'/></svg>",
                    "sizes": "96x96",
                    "type": "image/svg+xml",
                    "purpose": "any"
                },
                {
                    "src": "data:image/svg+xml,<svg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 128 128'><defs><radialGradient id='bg' cx='50%25' cy='50%25' r='50%25'><stop offset='0%25' style='stop-color:%23001122;stop-opacity:1' /><stop offset='100%25' style='stop-color:%230A0B2F;stop-opacity:1' /></radialGradient></defs><rect width='128' height='128' rx='28' fill='url(%23bg)'/><circle cx='64' cy='46' r='3' fill='%23FFD700'/><circle cx='46' cy='60' r='2.5' fill='%2364FFDA'/><circle cx='82' cy='53' r='2.5' fill='%23FFFFFF'/><circle cx='56' cy='80' r='2.5' fill='%23FFD700'/><circle cx='78' cy='73' r='2.5' fill='%2364FFDA'/><polygon points='46,60 56,80 78,73' stroke='%2364FFDA' stroke-width='2.5' fill='none'/></svg>",
                    "sizes": "128x128",
                    "type": "image/svg+xml",
                    "purpose": "any"
                },
                {
                    "src": "data:image/svg+xml,<svg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 192 192'><defs><radialGradient id='bg' cx='50%25' cy='50%25' r='50%25'><stop offset='0%25' style='stop-color:%23001122;stop-opacity:1' /><stop offset='100%25' style='stop-color:%230A0B2F;stop-opacity:1' /></radialGradient></defs><rect width='192' height='192' rx='42' fill='url(%23bg)'/><circle cx='96' cy='70' r='4' fill='%23FFD700'/><circle cx='70' cy='90' r='3' fill='%2364FFDA'/><circle cx='122' cy='80' r='3' fill='%23FFFFFF'/><circle cx='84' cy='120' r='3' fill='%23FFD700'/><circle cx='114' cy='110' r='3' fill='%2364FFDA'/><polygon points='70,90 84,120 114,110' stroke='%2364FFDA' stroke-width='3' fill='none'/><text x='96' y='150' text-anchor='middle' fill='%2364FFDA' font-family='Arial,sans-serif' font-size='12' font-weight='bold'>STELLAR</text><text x='96' y='165' text-anchor='middle' fill='%23FFD700' font-family='Arial,sans-serif' font-size='10'>EXPLORER</text></svg>",
                    "sizes": "192x192",
                    "type": "image/svg+xml",
                    "purpose": "any"
                },
                {
                    "src": "data:image/svg+xml,<svg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 512 512'><defs><radialGradient id='bg' cx='50%25' cy='50%25' r='50%25'><stop offset='0%25' style='stop-color:%23001122;stop-opacity:1' /><stop offset='100%25' style='stop-color:%230A0B2F;stop-opacity:1' /></radialGradient></defs><rect width='512' height='512' rx='115' fill='url(%23bg)'/><circle cx='256' cy='180' r='8' fill='%23FFD700'/><circle cx='200' cy='220' r='6' fill='%2364FFDA'/><circle cx='312' cy='200' r='7' fill='%23FFFFFF'/><circle cx='230' cy='300' r='6' fill='%23FFD700'/><circle cx='290' cy='280' r='6' fill='%2364FFDA'/><polygon points='200,220 230,300 290,280' stroke='%2364FFDA' stroke-width='6' fill='none'/><text x='256' y='370' text-anchor='middle' fill='%2364FFDA' font-family='Arial,sans-serif' font-size='32' font-weight='bold'>STELLAR</text><text x='256' y='410' text-anchor='middle' fill='%23FFD700' font-family='Arial,sans-serif' font-size='24'>EXPLORER</text><text x='256' y='450' text-anchor='middle' fill='%23FFFFFF' font-family='Arial,sans-serif' font-size='18'>Geometry Learning</text></svg>",
                    "sizes": "512x512",
                    "type": "image/svg+xml",
                    "purpose": "any maskable"
                }
            ]
        };
        
        // Create and inject manifest
        const manifestBlob = new Blob([JSON.stringify(manifestData)], {type: 'application/json'});
        const manifestURL = URL.createObjectURL(manifestBlob);
        const manifestLink = document.createElement('link');
        manifestLink.rel = 'manifest';
        manifestLink.href = manifestURL;
        document.head.appendChild(manifestLink);
    </script>
    <style>
        body {
            background-color: #0A0B2F;
            color: white;
            font-family: 'Arial', sans-serif;
            text-align: center;
            margin: 0;
            padding: 20px;
            overflow-x: hidden;
        }
        
        .shape-selector {
            margin-bottom: 30px;
            animation: selector-fade-in 1.5s ease-out forwards;
            opacity: 0;
            transform: translateY(30px);
        }
        
        .shape-selector p {
            margin-bottom: 20px;
            font-size: 22px;
            font-weight: bold;
            color: #A0FFE6;
            text-shadow: 0 0 10px rgba(160, 255, 230, 0.4);
        }
        
        .shape-options {
            display: flex;
            flex-direction: column;
            gap: 15px;
            align-items: center;
        }
        
        .shape-option {
            display: flex;
            align-items: center;
            cursor: pointer;
            user-select: none;
            background: linear-gradient(135deg, rgba(93, 92, 222, 0.15), rgba(66, 64, 179, 0.1));
            padding: 12px 25px;
            border-radius: 25px;
            border: 2px solid rgba(100, 255, 218, 0.3);
            transition: all 0.3s ease;
            min-width: 280px;
            justify-content: center;
            backdrop-filter: blur(10px);
            box-shadow: 0 4px 15px rgba(0, 0, 0, 0.2);
        }
        
        .shape-option:hover {
            background: linear-gradient(135deg, rgba(93, 92, 222, 0.25), rgba(66, 64, 179, 0.2));
            border-color: rgba(100, 255, 218, 0.6);
            transform: translateY(-3px) scale(1.02);
            box-shadow: 0 8px 25px rgba(100, 255, 218, 0.3);
        }
        
        .shape-option input {
            margin-right: 12px;
            transform: scale(1.2);
            accent-color: #64FFDA;
        }
        
        .shape-name {
            font-size: 18px;
            font-weight: 600;
            color: rgba(255, 255, 255, 0.9);
            text-shadow: 0 0 5px rgba(255, 255, 255, 0.3);
        }
        
        @keyframes selector-fade-in {
            to {
                opacity: 1;
                transform: translateY(0);
            }
        }
        
        h1 {
            margin-bottom: 20px;
            font-size: 28px;
            text-shadow: 0 0 10px rgba(100, 255, 218, 0.5);
            color: #64FFDA;
        }
        
        #gameCanvas {
            background: linear-gradient(to bottom, #0B0E2E, #1A1B4B);
            border-radius: 8px;
            margin: 0 auto;
            display: block;
            box-shadow: 0 0 20px rgba(0, 0, 0, 0.5);
            border: 1px solid #2A2A6A;
            position: relative;
        }
        
        #controls {
            margin-top: 20px;
            display: flex;
            flex-wrap: wrap;
            justify-content: center;
            gap: 10px;
            align-items: center;
        }
        
        button {
            background: linear-gradient(135deg, #5D5CDE, #4240B3);
            color: white;
            border: none;
            padding: 10px 15px;
            border-radius: 5px;
            cursor: pointer;
            transition: all 0.3s;
            font-size: 0.9rem;
            box-shadow: 0 3px 8px rgba(93, 92, 222, 0.4);
        }
        
        button:hover {
            background: linear-gradient(135deg, #6E6DFF, #5250C4);
            transform: translateY(-3px);
            box-shadow: 0 5px 15px rgba(93, 92, 222, 0.6);
        }
        
        button:active {
            transform: translateY(-1px);
            box-shadow: 0 2px 5px rgba(93, 92, 222, 0.4);
        }
        
        #checkBtn {
            background: linear-gradient(135deg, #64FFDA, #00D0B6);
            color: #0A0B2F;
            font-size: 1.1rem;
            font-weight: bold;
            padding: 12px 25px;
            box-shadow: 0 4px 12px rgba(100, 255, 218, 0.4);
        }
        
        #checkBtn:hover {
            background: linear-gradient(135deg, #7AFFDF, #00E0C6);
            transform: translateY(-3px);
            box-shadow: 0 8px 20px rgba(100, 255, 218, 0.5);
        }
        
        .secondary-btn {
            background: linear-gradient(135deg, rgba(93, 92, 222, 0.7), rgba(66, 64, 179, 0.7));
            font-size: 0.8rem;
            padding: 8px 12px;
        }
        
        #hintVisualBtn {
            background: linear-gradient(135deg, rgba(255, 215, 0, 0.7), rgba(230, 190, 0, 0.7));
            color: #0A0B2F;
        }
        
        #hintVisualBtn:hover {
            background: linear-gradient(135deg, rgba(255, 215, 0, 0.9), rgba(230, 190, 0, 0.9));
        }
        
        #info {
            margin-top: 20px;
            padding: 15px;
            background: linear-gradient(135deg, rgba(93, 92, 222, 0.2), rgba(93, 92, 222, 0.1));
            border-radius: 10px;
            max-width: 400px;
            margin-left: auto;
            margin-right: auto;
            box-shadow: 0 4px 15px rgba(0, 0, 0, 0.2);
            border: 1px solid rgba(93, 92, 222, 0.3);
        }

        #task {
            font-weight: bold;
            color: #64FFDA;
            margin-bottom: 15px;
            line-height: 1.5;
            font-size: 18px;
            text-shadow: 0 0 5px rgba(100, 255, 218, 0.3);
        }

        .tooltip {
            position: absolute;
            background: linear-gradient(135deg, rgba(0, 0, 0, 0.8), rgba(20, 20, 50, 0.8));
            padding: 8px 15px;
            border-radius: 20px;
            pointer-events: none;
            z-index: 100;
            font-size: 14px;
            box-shadow: 0 4px 10px rgba(0, 0, 0, 0.3);
            border: 1px solid rgba(100, 255, 218, 0.3);
            color: #64FFDA;
            display: none;
        }

        #hintBox {
            margin-top: 15px;
            padding: 12px;
            background: linear-gradient(135deg, rgba(100, 255, 218, 0.1), rgba(100, 255, 218, 0.05));
            border-radius: 8px;
            display: none;
            border: 1px solid rgba(100, 255, 218, 0.2);
            box-shadow: 0 0 10px rgba(100, 255, 218, 0.1);
        }
        
        .score-container {
            position: absolute;
            top: 15px;
            right: 15px;
            background: linear-gradient(135deg, rgba(93, 92, 222, 0.7), rgba(66, 64, 179, 0.7));
            padding: 8px 15px;
            border-radius: 20px;
            box-shadow: 0 4px 15px rgba(0, 0, 0, 0.3);
            z-index: 10;
            display: flex;
            flex-direction: column;
            border: 1px solid rgba(255, 255, 255, 0.1);
        }
        
        #scoreDisplay, #streakDisplay, #highScoreDisplay {
            display: block;
            margin: 3px 0;
            font-size: 14px;
            text-shadow: 0 0 5px rgba(255, 255, 255, 0.5);
        }
        
        #streakDisplay {
            color: #FFD700;
        }
        
        .timer-container {
            position: absolute;
            top: 15px;
            left: 15px;
            background: linear-gradient(135deg, rgba(93, 92, 222, 0.7), rgba(66, 64, 179, 0.7));
            padding: 8px 15px;
            border-radius: 20px;
            box-shadow: 0 4px 15px rgba(0, 0, 0, 0.3);
            z-index: 10;
            border: 1px solid rgba(255, 255, 255, 0.1);
        }
        
        #timerDisplay {
            font-size: 20px;
            font-weight: bold;
            color: #FFD700;
            text-shadow: 0 0 8px rgba(255, 215, 0, 0.5);
        }
        
        .pulse-animation {
            animation: pulse-effect 0.5s;
        }
        
        @keyframes pulse-effect {
            0% { transform: scale(1); }
            50% { transform: scale(1.2); }
            100% { transform: scale(1); }
        }
        
        .result-message {
            padding: 12px 20px;
            border-radius: 10px;
            margin-top: 15px;
            display: inline-block;
            font-weight: bold;
            font-size: 16px;
            box-shadow: 0 4px 15px rgba(0, 0, 0, 0.2);
        }
        
        .result-success {
            background: linear-gradient(135deg, rgba(100, 255, 128, 0.2), rgba(80, 235, 108, 0.2));
            color: #64FFDA;
            border: 1px solid rgba(100, 255, 128, 0.3);
            text-shadow: 0 0 5px rgba(100, 255, 218, 0.5);
        }
        
        .result-fail {
            background: linear-gradient(135deg, rgba(255, 100, 100, 0.2), rgba(235, 80, 80, 0.2));
            color: #FF6464;
            border: 1px solid rgba(255, 100, 100, 0.3);
            text-shadow: 0 0 5px rgba(255, 100, 100, 0.5);
        }
        
        #startScreen {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100vh;
            background: 
                radial-gradient(ellipse at top, rgba(30, 40, 100, 0.8) 0%, rgba(10, 15, 40, 0.95) 50%, rgba(5, 8, 25, 0.98) 100%),
                linear-gradient(135deg, rgba(20, 30, 70, 0.3), rgba(40, 20, 80, 0.3));
            display: flex;
            flex-direction: column;
            justify-content: flex-start;
            align-items: center;
            z-index: 100;
            overflow-y: auto;
            overflow-x: hidden;
            animation: cosmic-pulse 8s ease-in-out infinite alternate;
            padding: 20px 0 40px 0;
            box-sizing: border-box;
        }
        
        @keyframes cosmic-pulse {
            0% { background-size: 100% 100%; }
            100% { background-size: 110% 110%; }
        }
        
        #startScreen:before {
            content: '';
            position: absolute;
            width: 300%;
            height: 300%;
            top: -100%;
            left: -100%;
            background-image: 
                radial-gradient(circle at 20% 80%, rgba(100, 255, 218, 0.4) 0%, transparent 50%),
                radial-gradient(circle at 80% 20%, rgba(255, 100, 255, 0.3) 0%, transparent 50%),
                radial-gradient(circle at 40% 40%, rgba(100, 200, 255, 0.2) 0%, transparent 70%),
                radial-gradient(2px 2px, rgba(255, 255, 255, 0.8) 1px, transparent 1px),
                radial-gradient(1px 1px, rgba(100, 255, 218, 0.6) 1px, transparent 1px),
                radial-gradient(1px 1px, rgba(255, 200, 100, 0.4) 1px, transparent 1px);
            background-size: 
                800px 800px, 600px 600px, 400px 400px,
                100px 100px, 150px 150px, 200px 200px;
            background-position: 
                0 0, 400px 400px, 200px 200px,
                0 0, 50px 50px, 100px 100px;
            animation: 
                nebula-drift 30s linear infinite,
                stars-twinkle 20s linear infinite,
                cosmic-rotation 60s linear infinite;
            z-index: -1;
            opacity: 0.8;
        }
        
        #startScreen:after {
            content: '';
            position: absolute;
            width: 100%;
            height: 100%;
            background: 
                radial-gradient(circle at 25% 25%, rgba(100, 255, 218, 0.1) 0%, transparent 25%),
                radial-gradient(circle at 75% 75%, rgba(255, 100, 255, 0.1) 0%, transparent 25%);
            animation: aurora-dance 15s ease-in-out infinite alternate;
            z-index: -1;
        }
        
        @keyframes nebula-drift {
            from { transform: translateX(-20px) translateY(-10px); }
            to { transform: translateX(20px) translateY(10px); }
        }
        
        @keyframes stars-twinkle {
            0%, 100% { opacity: 0.8; }
            50% { opacity: 1; }
        }
        
        @keyframes cosmic-rotation {
            from { transform: rotate(0deg) scale(1); }
            to { transform: rotate(360deg) scale(1.1); }
        }
        
        @keyframes aurora-dance {
            0% { opacity: 0.3; transform: skewX(-5deg); }
            50% { opacity: 0.7; transform: skewX(5deg); }
            100% { opacity: 0.3; transform: skewX(-5deg); }
        }
        
        #startScreen h2 {
            font-size: 48px;
            margin-bottom: 30px;
            color: #64FFDA;
            text-shadow: 
                0 0 10px rgba(100, 255, 218, 0.8),
                0 0 20px rgba(100, 255, 218, 0.6),
                0 0 40px rgba(100, 255, 218, 0.4),
                0 0 80px rgba(100, 255, 218, 0.2);
            font-weight: bold;
            text-align: center;
            animation: title-glow 3s ease-in-out infinite alternate;
            background: linear-gradient(45deg, #64FFDA, #A0FFE6, #64FFDA);
            background-size: 300% 300%;
            -webkit-background-clip: text;
            background-clip: text;
            -webkit-text-fill-color: transparent;
            animation: title-glow 3s ease-in-out infinite alternate, gradient-shift 4s ease-in-out infinite;
        }
        
        @keyframes title-glow {
            0% { 
                text-shadow: 
                    0 0 10px rgba(100, 255, 218, 0.8),
                    0 0 20px rgba(100, 255, 218, 0.6),
                    0 0 40px rgba(100, 255, 218, 0.4);
            }
            100% { 
                text-shadow: 
                    0 0 20px rgba(100, 255, 218, 1),
                    0 0 30px rgba(100, 255, 218, 0.8),
                    0 0 60px rgba(100, 255, 218, 0.6);
            }
        }
        
        @keyframes gradient-shift {
            0% { background-position: 0% 50%; }
            50% { background-position: 100% 50%; }
            100% { background-position: 0% 50%; }
        }
        
        #startScreen p {
            margin-bottom: 40px;
            max-width: 700px;
            line-height: 1.8;
            font-size: 20px;
            text-align: center;
            color: rgba(255, 255, 255, 0.9);
            text-shadow: 
                0 0 10px rgba(100, 255, 218, 0.3),
                0 2px 4px rgba(0, 0, 0, 0.5);
            animation: text-fade-in 2s ease-out forwards;
            opacity: 0;
            transform: translateY(20px);
        }
        
        @keyframes text-fade-in {
            to {
                opacity: 1;
                transform: translateY(0);
            }
        }
        
        #startGameBtn {
            background: linear-gradient(135deg, #64FFDA, #00D0B6, #64FFDA);
            background-size: 300% 300%;
            color: #0A0B2F;
            font-size: 1.4rem;
            font-weight: bold;
            padding: 18px 50px;
            border-radius: 50px;
            border: 3px solid rgba(100, 255, 218, 0.4);
            box-shadow: 
                0 0 30px rgba(100, 255, 218, 0.6),
                0 0 60px rgba(100, 255, 218, 0.3),
                inset 0 2px 10px rgba(255, 255, 255, 0.3);
            transition: all 0.4s cubic-bezier(0.175, 0.885, 0.32, 1.275);
            position: relative;
            overflow: hidden;
            animation: button-fade-in 1.5s ease-out forwards, button-gradient-shift 3s ease-in-out infinite;
            opacity: 0;
            transform: translateY(30px);
            text-shadow: 0 2px 4px rgba(0, 0, 0, 0.3);
            display: flex;
            align-items: center;
            justify-content: center;
            line-height: 1;
            text-align: center;
            min-height: 60px;
            box-sizing: border-box;
        }
        
        #startGameBtn::before {
            content: '';
            position: absolute;
            top: -50%;
            left: -50%;
            width: 200%;
            height: 200%;
            background: linear-gradient(45deg, 
                transparent, 
                rgba(255, 255, 255, 0.1), 
                transparent);
            transform: rotate(45deg);
            transition: all 0.5s;
            opacity: 0;
        }
        
        #startGameBtn:hover {
            transform: translateY(-8px) scale(1.08);
            border-color: rgba(100, 255, 218, 0.8);
            box-shadow: 
                0 0 40px rgba(100, 255, 218, 0.8),
                0 15px 35px rgba(100, 255, 218, 0.4),
                0 0 80px rgba(100, 255, 218, 0.2),
                inset 0 2px 15px rgba(255, 255, 255, 0.4);
            background-position: 100% 0;
        }
        
        #startGameBtn:hover::before {
            opacity: 1;
            left: 100%;
        }
        
        #startGameBtn:active {
            transform: translateY(-5px) scale(1.05);
            transition: all 0.1s;
        }
        
        @keyframes button-fade-in {
            to {
                opacity: 1;
                transform: translateY(0);
            }
        }
        
        @keyframes button-gradient-shift {
            0%, 100% { background-position: 0% 50%; }
            50% { background-position: 100% 50%; }
        }
        
        #resultScreen {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: radial-gradient(ellipse at center, rgba(20, 30, 70, 0.95), rgba(10, 11, 47, 0.98));
            display: none;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            z-index: 100;
            overflow-y: auto;
        }
        
        #resultScreen:before {
            content: '';
            position: absolute;
            width: 200%;
            height: 200%;
            top: -50%;
            left: -50%;
            background-image: 
                radial-gradient(circle, white 1px, transparent 1px),
                radial-gradient(circle, white 1px, transparent 1px),
                radial-gradient(circle, rgba(255, 255, 255, 0.7) 1px, transparent 1px);
            background-size: 100px 100px, 150px 150px, 70px 70px;
            background-position: 0 0, 40px 40px, 20px 20px;
            animation: stars-animation 100s linear infinite;
            opacity: 0.2;
            z-index: -1;
        }
        
        #resultScreen h2 {
            font-size: 36px;
            margin-bottom: 20px;
            color: #64FFDA;
            text-shadow: 0 0 15px rgba(100, 255, 218, 0.5);
        }
        
        #resultScreen p {
            margin-bottom: 10px;
            font-size: 20px;
        }
        
        #finalScore {
            font-size: 64px;
            font-weight: bold;
            color: #FFD700;
            margin: 30px 0 15px;
            text-shadow: 0 0 20px rgba(255, 215, 0, 0.6);
        }
        
        /* ÊàêÂ∞±Á≥ªÁµ±Áõ∏ÈóúÊ®£Âºè */
        .achievement-badge {
            display: inline-flex;
            align-items: center;
            justify-content: center;
            width: 60px;
            height: 60px;
            border-radius: 50%;
            background: linear-gradient(135deg, rgba(0, 0, 0, 0.4), rgba(20, 20, 50, 0.6));
            margin: 5px;
            position: relative;
            border: 2px solid rgba(100, 255, 218, 0.4);
            box-shadow: 0 0 10px rgba(100, 255, 218, 0.3);
            transition: all 0.3s ease;
            opacity: 0.6;
        }
        
        .achievement-badge.unlocked {
            background: linear-gradient(135deg, rgba(100, 255, 218, 0.2), rgba(20, 80, 100, 0.3));
            border: 2px solid rgba(100, 255, 218, 0.8);
            box-shadow: 0 0 15px rgba(100, 255, 218, 0.5);
            opacity: 1;
            transform: scale(1.05);
        }
        
        .achievement-badge.new-unlock {
            animation: badge-pulse 1.5s infinite alternate;
        }
        
        @keyframes badge-pulse {
            0% { transform: scale(1.05); box-shadow: 0 0 15px rgba(100, 255, 218, 0.5); }
            100% { transform: scale(1.15); box-shadow: 0 0 25px rgba(100, 255, 218, 0.8); }
        }
        
        .achievement-badge .icon {
            font-size: 28px;
            color: #FFD700;
            text-shadow: 0 0 10px rgba(255, 215, 0, 0.6);
        }
        
        .achievement-badge.locked .icon {
            color: rgba(255, 255, 255, 0.4);
            text-shadow: none;
        }
        
        .achievement-container {
            display: flex;
            flex-wrap: wrap;
            justify-content: center;
            gap: 10px;
            margin: 15px 0;
        }
        
        .achievement-tooltip {
            position: absolute;
            bottom: -45px;
            left: 50%;
            transform: translateX(-50%);
            background: linear-gradient(135deg, rgba(0, 0, 0, 0.9), rgba(20, 20, 50, 0.9));
            padding: 5px 10px;
            border-radius: 10px;
            font-size: 12px;
            white-space: nowrap;
            z-index: 100;
            pointer-events: none;
            opacity: 0;
            transition: opacity 0.3s;
            border: 1px solid rgba(100, 255, 218, 0.3);
        }
        
        .achievement-badge:hover .achievement-tooltip {
            opacity: 1;
        }
        
        .achievement-popup {
            position: fixed;
            top: 15%;
            right: 10px;
            transform: translateX(100%) scale(0.5);
            background: linear-gradient(135deg, rgba(0, 0, 0, 0.7), rgba(20, 20, 80, 0.8));
            padding: 10px 15px;
            border-radius: 12px;
            z-index: 1000;
            text-align: center;
            border: 1px solid rgba(100, 255, 218, 0.4);
            box-shadow: 0 0 20px rgba(100, 255, 218, 0.3);
            pointer-events: none;
            opacity: 0;
            transition: all 0.4s cubic-bezier(0.175, 0.885, 0.32, 1.275);
            max-width: 200px;
        }
        
        .achievement-popup.show {
            opacity: 0.9;
            transform: translateX(0) scale(1);
        }
        
        .achievement-popup-title {
            font-size: 16px;
            color: #FFD700;
            margin-bottom: 5px;
            font-weight: bold;
            text-shadow: 0 0 10px rgba(255, 215, 0, 0.5);
        }
        
        .achievement-popup-desc {
            font-size: 12px;
            margin-bottom: 5px;
        }
        
        .achievement-icon-large {
            font-size: 28px;
            margin: 5px 0;
            color: #FFD700;
            text-shadow: 0 0 15px rgba(255, 215, 0, 0.7);
            animation: achievement-spin 1.5s ease-out;
        }
        
        @keyframes achievement-spin {
            0% { transform: scale(0.5) rotate(-30deg); opacity: 0; }
            100% { transform: scale(1) rotate(0); opacity: 1; }
        }
        
        #achievementsSummary {
            margin-top: 20px;
            background: linear-gradient(135deg, rgba(20, 20, 80, 0.3), rgba(20, 20, 50, 0.2));
            border-radius: 10px;
            padding: 15px;
            border: 1px solid rgba(100, 255, 218, 0.2);
            max-width: 500px;
            margin-left: auto;
            margin-right: auto;
        }
        
        #achievementsSummary h3 {
            font-size: 22px;
            color: #64FFDA;
            margin-bottom: 15px;
            text-shadow: 0 0 10px rgba(100, 255, 218, 0.4);
        }
        
        #playAgainBtn {
            background: linear-gradient(135deg, #64FFDA, #00D0B6);
            color: #0A0B2F;
            font-size: 1.3rem;
            font-weight: bold;
            padding: 15px 40px;
            border-radius: 50px;
            margin-top: 30px;
            box-shadow: 0 0 20px rgba(100, 255, 218, 0.5);
            transition: all 0.3s;
        }
        
        #playAgainBtn:hover {
            transform: translateY(-5px) scale(1.05);
            box-shadow: 0 10px 25px rgba(100, 255, 218, 0.7);
        }
        
        .difficulty-indicator {
            display: inline-block;
            margin-left: 8px;
            font-size: 12px;
            padding: 3px 8px;
            border-radius: 10px;
            background: linear-gradient(135deg, rgba(93, 92, 222, 0.6), rgba(66, 64, 179, 0.6));
            border: 1px solid rgba(255, 255, 255, 0.1);
        }
        
        .settings-row {
            margin-top: 30px;
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 20px;
            animation: settings-fade-in 2s ease-out forwards;
            opacity: 0;
            transform: translateY(20px);
        }
        
        .sound-toggle {
            display: flex;
            align-items: center;
            cursor: pointer;
            user-select: none;
            background: linear-gradient(135deg, rgba(255, 255, 255, 0.1), rgba(160, 255, 230, 0.1));
            padding: 12px 20px;
            border-radius: 25px;
            border: 1px solid rgba(160, 255, 230, 0.3);
            transition: all 0.3s;
            backdrop-filter: blur(5px);
            box-shadow: 0 4px 15px rgba(0, 0, 0, 0.1);
        }
        
        .sound-toggle:hover {
            background: linear-gradient(135deg, rgba(255, 255, 255, 0.2), rgba(160, 255, 230, 0.2));
            border-color: rgba(160, 255, 230, 0.5);
            transform: translateY(-2px);
            box-shadow: 0 6px 20px rgba(160, 255, 230, 0.2);
        }
        
        .sound-toggle input {
            margin-right: 10px;
            transform: scale(1.2);
            accent-color: #64FFDA;
        }
        
        .sound-toggle span {
            font-size: 16px;
            font-weight: 500;
            color: rgba(255, 255, 255, 0.9);
            text-shadow: 0 0 5px rgba(255, 255, 255, 0.3);
        }
        
        @keyframes settings-fade-in {
            to {
                opacity: 1;
                transform: translateY(0);
            }
        }
        
        /* Hero text styles */
        .hero-text {
            animation: text-fade-in 1.5s ease-out forwards;
            opacity: 0;
            transform: translateY(20px);
        }
        
        .main-tagline {
            font-size: 28px !important;
            font-weight: bold;
            margin-bottom: 15px !important;
            background: linear-gradient(45deg, #FFD700, #FFA500, #FFD700);
            background-size: 200% 200%;
            -webkit-background-clip: text;
            background-clip: text;
            -webkit-text-fill-color: transparent;
            animation: tagline-shimmer 3s ease-in-out infinite;
            text-shadow: none;
        }
        
        .sub-tagline {
            font-size: 18px !important;
            margin-bottom: 25px !important;
            color: rgba(255, 255, 255, 0.8);
            font-style: italic;
        }
        
        @keyframes tagline-shimmer {
            0%, 100% { background-position: 0% 50%; }
            50% { background-position: 100% 50%; }
        }
        
        /* How to Play button */
        .how-to-play-btn {
            background: linear-gradient(135deg, rgba(93, 92, 222, 0.15), rgba(66, 64, 179, 0.2));
            border: 2px solid rgba(100, 255, 218, 0.3);
            color: rgba(255, 255, 255, 0.9);
            padding: 12px 25px;
            border-radius: 25px;
            cursor: pointer;
            transition: all 0.3s ease;
            font-size: 16px;
            font-weight: 500;
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 8px;
            margin: 0 auto 20px;
            backdrop-filter: blur(10px);
            box-shadow: 0 4px 15px rgba(0, 0, 0, 0.2);
            min-width: 200px;
            animation: how-to-play-fade-in 2.5s ease-out forwards;
            opacity: 0;
            transform: translateY(20px);
        }
        
        .how-to-play-btn:hover {
            background: linear-gradient(135deg, rgba(93, 92, 222, 0.25), rgba(66, 64, 179, 0.3));
            border-color: rgba(100, 255, 218, 0.6);
            transform: translateY(-2px) scale(1.02);
            box-shadow: 0 8px 25px rgba(100, 255, 218, 0.3);
        }
        
        .how-to-play-btn .btn-icon {
            font-size: 18px;
        }
        
        .how-to-play-btn .btn-arrow {
            transition: transform 0.3s ease;
            font-size: 14px;
        }
        
        .how-to-play-btn:hover .btn-arrow {
            transform: translateY(2px);
        }
        
        @keyframes how-to-play-fade-in {
            to {
                opacity: 1;
                transform: translateY(0);
            }
        }
        
        /* Game instructions panel */
        .game-instructions {
            max-width: 600px;
            margin: 0 auto 30px;
            opacity: 0;
            max-height: 0;
            overflow: hidden;
            transition: all 0.5s ease;
            position: relative;
            z-index: 200;
        }
        
        .game-instructions.show {
            opacity: 1;
            max-height: 70vh;
            margin-bottom: 30px;
            overflow-y: auto;
        }
        
        .instruction-content {
            background: linear-gradient(135deg, rgba(20, 30, 70, 0.95), rgba(40, 20, 80, 0.95));
            border-radius: 15px;
            padding: 25px;
            border: 1px solid rgba(100, 255, 218, 0.2);
            backdrop-filter: blur(10px);
            box-shadow: 0 8px 32px rgba(0, 0, 0, 0.3);
            position: relative;
            max-height: 100%;
            overflow-y: auto;
        }
        
        .instruction-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 20px;
        }
        
        .close-instruction-btn {
            background: rgba(255, 100, 100, 0.2);
            color: #FF6464;
            border: 1px solid rgba(255, 100, 100, 0.3);
            border-radius: 50%;
            width: 30px;
            height: 30px;
            display: flex;
            align-items: center;
            justify-content: center;
            cursor: pointer;
            font-size: 16px;
            font-weight: bold;
            transition: all 0.3s ease;
            line-height: 1;
            padding: 0;
        }
        
        .close-instruction-btn:hover {
            background: rgba(255, 100, 100, 0.4);
            border-color: rgba(255, 100, 100, 0.6);
            transform: scale(1.1);
        }
        
        .instruction-footer {
            text-align: center;
            margin-top: 25px;
            padding-top: 20px;
            border-top: 1px solid rgba(100, 255, 218, 0.2);
        }
        
        .got-it-btn {
            background: linear-gradient(135deg, #64FFDA, #00D0B6);
            color: #0A0B2F;
            border: none;
            padding: 12px 30px;
            border-radius: 25px;
            cursor: pointer;
            font-size: 16px;
            font-weight: bold;
            transition: all 0.3s ease;
            box-shadow: 0 4px 15px rgba(100, 255, 218, 0.4);
        }
        
        .got-it-btn:hover {
            background: linear-gradient(135deg, #7AFFDF, #00E0C6);
            transform: translateY(-2px) scale(1.05);
            box-shadow: 0 8px 25px rgba(100, 255, 218, 0.6);
        }
        
        .instruction-content h3 {
            color: #64FFDA;
            font-size: 20px;
            margin-bottom: 12px;
            margin-top: 20px;
            text-shadow: 0 0 10px rgba(100, 255, 218, 0.4);
        }
        
        .instruction-content h3:first-child {
            margin-top: 0;
        }
        
        .instruction-content p {
            font-size: 16px;
            line-height: 1.6;
            margin-bottom: 15px;
            color: rgba(255, 255, 255, 0.9);
        }
        
        .instruction-content ul {
            list-style: none;
            padding-left: 0;
            margin-bottom: 15px;
        }
        
        .instruction-content li {
            padding: 8px 0;
            font-size: 15px;
            line-height: 1.5;
            color: rgba(255, 255, 255, 0.85);
            display: flex;
            align-items: flex-start;
            gap: 8px;
        }
        
        .instruction-content li::before {
            content: "";
            width: 6px;
            height: 6px;
            background: #64FFDA;
            border-radius: 50%;
            margin-top: 8px;
            flex-shrink: 0;
            box-shadow: 0 0 6px rgba(100, 255, 218, 0.6);
        }
        
        /* Star */
        .star {
            position: absolute;
            border-radius: 50%;
            background-color: rgba(255, 255, 255, 0.8);
            box-shadow: 0 0 10px rgba(255, 255, 255, 0.8),
                        0 0 20px rgba(255, 255, 255, 0.5);
            pointer-events: none;
        }
        
        .star-glow {
            position: absolute;
            border-radius: 50%;
            background: radial-gradient(circle, rgba(255, 255, 255, 0.8) 0%, rgba(255, 255, 255, 0) 70%);
            pointer-events: none;
            opacity: 0;
            animation: star-pulse 2s infinite alternate;
        }
        
        @keyframes star-pulse {
            0% { opacity: 0.1; transform: scale(0.8); }
            100% { opacity: 0.5; transform: scale(1.2); }
        }
        
        /* Line effect */
        .constellation-line {
            position: absolute;
            background: linear-gradient(90deg, 
                rgba(100, 255, 218, 0) 0%, 
                rgba(100, 255, 218, 0.8) 50%, 
                rgba(100, 255, 218, 0) 100%);
            height: 2px;
            transform-origin: left center;
            pointer-events: none;
            opacity: 0;
            animation: line-appear 0.5s forwards;
        }
        
        @keyframes line-appear {
            from { opacity: 0; }
            to { opacity: 1; }
        }
        
        /* Particles */
        .particle {
            position: absolute;
            background-color: rgba(100, 255, 218, 0.8);
            border-radius: 50%;
            pointer-events: none;
        }
        
        /* Floating stars background */
        .bg-stars {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            pointer-events: none;
            z-index: -1;
            overflow: hidden;
        }
        
        .bg-star {
            position: absolute;
            background-color: white;
            border-radius: 50%;
            animation: twinkle 4s infinite alternate;
        }
        
        @keyframes twinkle {
            0% { opacity: 0.3; }
            50% { opacity: 1; }
            100% { opacity: 0.3; }
        }
        
        .shooting-star {
            position: absolute;
            width: 2px;
            height: 2px;
            background: linear-gradient(to right, 
                rgba(255, 255, 255, 0) 0%, 
                rgba(255, 255, 255, 0.8) 50%, 
                rgba(255, 255, 255, 0) 100%);
            transform: rotate(-45deg);
            animation: shooting 3s linear forwards;
            box-shadow: 0 0 3px rgba(255, 255, 255, 0.3);
            pointer-events: none;
        }
        
        @keyframes shooting {
            from {
                transform: translateX(0) translateY(0) rotate(-45deg) scale(1);
                opacity: 1;
            }
            to {
                transform: translateX(500px) translateY(500px) rotate(-45deg) scale(0.1);
                opacity: 0;
            }
        }
        
        @media (max-width: 500px) {
            button {
                padding: 8px 12px;
                font-size: 0.8rem;
            }
            
            #checkBtn {
                padding: 10px 20px;
                font-size: 1rem;
            }
            
            .score-container, .timer-container {
                padding: 3px 10px;
            }
            
            #timerDisplay {
                font-size: 16px;
            }
            
            h1 {
                font-size: 22px;
            }
            
            #task {
                font-size: 16px;
            }
            
            #startScreen h2, #resultScreen h2 {
                font-size: 28px;
            }
            
            #finalScore {
                font-size: 48px;
            }
        }
    </style>
</head>
<body>
    <div class="bg-stars" id="bgStars"></div>
    
    <div id="startScreen">
        <h2>Stellar Explorer - Time Challenge Mode</h2>
        <div class="hero-text">
            <p class="main-tagline">üåü Connect the Stars, Master Geometry! üåü</p>
            <p class="sub-tagline">Race against time in this cosmic adventure</p>
            <button id="howToPlayBtn" class="how-to-play-btn">
                <span class="btn-icon">üìö</span>
                How to Play
                <span class="btn-arrow">‚Üì</span>
            </button>
            <div id="gameInstructions" class="game-instructions">
                <div class="instruction-content">
                    <div class="instruction-header">
                        <h3 style="margin-top: 0; margin-bottom: 0; display: inline-block;">üìö How to Play</h3>
                        <button class="close-instruction-btn" onclick="toggleInstructions()">‚úï</button>
                    </div>
                    
                    <h3>üéØ Your Mission</h3>
                    <p>Complete as many constellation geometry challenges as possible in <strong>60 seconds</strong>!</p>
                    
                    <h3>üéÆ How to Play</h3>
                    <ul>
                        <li>üîó <strong>Connect the stars</strong> by clicking on them to form lines</li>
                        <li>üìê <strong>Create geometric shapes</strong> like triangles, squares, rectangles</li>
                        <li>‚ú® <strong>Match the required pattern</strong> shown in the challenge</li>
                        <li>‚ö° <strong>Complete quickly</strong> to build up your streak bonus!</li>
                    </ul>
                    
                    <h3>üí° Tips</h3>
                    <ul>
                        <li>üéØ Use <strong>Visual Hint</strong> to see where to connect</li>
                        <li>üìñ Use <strong>Text Hint</strong> for geometry reminders</li>
                        <li>üîÑ Use <strong>Reset</strong> to start over on a challenge</li>
                        <li>üèÜ Build streaks for bonus points!</li>
                    </ul>
                    
                    <div class="instruction-footer">
                        <button class="got-it-btn" onclick="toggleInstructions()">
                            Got it! Let's Play üöÄ
                        </button>
                    </div>
                </div>
            </div>
        </div>
        
        <div class="shape-selector">
            <p>Choose Constellation Type:</p>
            <div class="shape-options">
                <label class="shape-option">
                    <input type="radio" name="shapeType" value="triangles" checked>
                    <span class="shape-name">Triangle Constellations Only</span>
                </label>
                <label class="shape-option">
                    <input type="radio" name="shapeType" value="quadrilaterals">
                    <span class="shape-name">Quadrilateral Constellations Only</span>
                </label>
                <label class="shape-option">
                    <input type="radio" name="shapeType" value="all">
                    <span class="shape-name">All Constellation Shapes</span>
                </label>
            </div>
        </div>
        
        <div class="settings-row">
            <label class="sound-toggle">
                <input type="checkbox" id="soundToggle" checked>
                Stellar Sound Effects
            </label>
        </div>
        <button id="startGameBtn">Begin Your Journey</button>
    </div>

    <div id="resultScreen">
        <h2>Stellar Exploration Complete!</h2>
        <p>You completed in 1 minute:</p>
        <div id="finalScore">0 Constellations</div>
        <p>Total Score: <span id="finalTotalScore">0</span></p>
        
        <div id="achievementsSummary">
            <h3>Unlocked Stellar Explorer Badges</h3>
            <div id="achievementsContainer" class="achievement-container"></div>
        </div>
        
        <button id="playAgainBtn">Explore Again</button>
    </div>
    
    <div id="achievementPopup" class="achievement-popup">
        <div class="achievement-icon-large">‚ú®</div>
        <div class="achievement-popup-title">Achievement Unlocked!</div>
        <div class="achievement-popup-desc">You earned a new badge</div>
    </div>

    <h1>Stellar Explorer - Constellation Geometry Learning</h1>
    
    <div id="task">Please connect the stars to form an isosceles triangle constellation</div>
    
    <div style="position: relative;">
        <div class="timer-container">
            <div id="timerDisplay">01:00</div>
        </div>
        <div class="score-container">
            <span id="scoreDisplay">Score: 0</span>
            <span id="streakDisplay">Streak: 0</span>
            <span id="solvedDisplay">Solved: 0</span>
            <span id="difficultyDisplay">Difficulty: Normal</span>
        </div>
        <canvas id="gameCanvas" width="450" height="450"></canvas>
        <div id="tooltip" class="tooltip">Click this star to start connecting</div>
    </div>
    
    <div id="controls">
        <button id="resetBtn" class="secondary-btn">Reset Stars</button>
        <button id="checkBtn">Check Constellation</button>
        <button id="hintTextBtn" class="secondary-btn">Text Hint</button>
        <button id="hintVisualBtn" class="secondary-btn">Visual Hint</button>
    </div>
    
    <div id="info">
        <p id="shapeInfo">Connect the shining stars to form the specified triangle constellation type</p>
        <p id="status">Connected: 0 lines (need to connect 2 lines)</p>
        <div id="hintBox"></div>
        <div id="resultMessage" class="result-message" style="display: none;"></div>
    </div>
    
    <script>
        // Áç≤ÂèñCanvasÂÖÉÁ¥†Âíå‰∏ä‰∏ãÊñá
        const canvas = document.getElementById('gameCanvas');
        const ctx = canvas.getContext('2d');
        const tooltip = document.getElementById('tooltip');
        const hintBox = document.getElementById('hintBox');
        const resultMessage = document.getElementById('resultMessage');
        const startScreen = document.getElementById('startScreen');
        const resultScreen = document.getElementById('resultScreen');
        const timerDisplay = document.getElementById('timerDisplay');
        const difficultyDisplay = document.getElementById('difficultyDisplay');
        const soundToggle = document.getElementById('soundToggle');
        const shapeInfo = document.getElementById('shapeInfo');
        const bgStars = document.getElementById('bgStars');
        
        // ËÉåÊôØÊòüÊòüÁîüÊàê
        function createBackgroundStars() {
            const starCount = Math.floor(window.innerWidth * window.innerHeight / 1000);
            bgStars.innerHTML = '';
            
            for (let i = 0; i < starCount; i++) {
                const star = document.createElement('div');
                star.className = 'bg-star';
                star.style.left = `${Math.random() * 100}%`;
                star.style.top = `${Math.random() * 100}%`;
                
                const size = Math.random() * 2;
                star.style.width = `${size}px`;
                star.style.height = `${size}px`;
                
                // ‰∏çÂêåÁöÑÈñÉÁàçÊôÇÈñì
                star.style.animationDelay = `${Math.random() * 4}s`;
                star.style.animationDuration = `${2 + Math.random() * 3}s`;
                
                // ‰∏çÂêåÁöÑ‰∫ÆÂ∫¶
                star.style.opacity = 0.3 + Math.random() * 0.7;
                
                bgStars.appendChild(star);
            }
            
            // Ê∑ªÂä†ÊµÅÊòü
            createShootingStar();
        }
        
        // ÊµÅÊòüÊïàÊûú
        function createShootingStar() {
            if (!document.body.contains(bgStars)) return;
            
            const star = document.createElement('div');
            star.className = 'shooting-star';
            
            // Èö®Ê©ü‰ΩçÁΩÆÂíåÂ§ßÂ∞è
            star.style.left = `${Math.random() * 30}%`;
            star.style.top = `${Math.random() * 20}%`;
            star.style.width = `${80 + Math.random() * 120}px`;
            
            bgStars.appendChild(star);
            
            // ÂãïÁï´ÁµêÊùüÂæåÁßªÈô§
            setTimeout(() => {
                if (star.parentNode) {
                    star.parentNode.removeChild(star);
                }
                // Èö®Ê©üÊôÇÈñìÂæåÂÜçÊ¨°Âá∫Áèæ
                setTimeout(createShootingStar, 5000 + Math.random() * 15000);
            }, 3000);
        }
        
        // ÈÅäÊà≤Ë®≠ÁΩÆ
        let selectedShapeType = "triangles"; // ÈªòË™çÁÇ∫‰∏âËßíÂΩ¢
        let debugMode = false; // ÂèØÂú®ÊéßÂà∂Âè∞Ë®≠ÁÇ∫true‰ª•È°ØÁ§∫Êõ¥Â§ö‰ø°ÊÅØ
        let lenientMode = true; // ËºÉÂØ¨È¨ÜÁöÑÂΩ¢ÁãÄÊ™¢Ê∏¨ÔºåÂõ†ÁÇ∫ÊàëÂÄë‰∏çÊáâË©≤Â§™Âö¥Ê†º
        
        // Èü≥ÊïàÁ≥ªÁµ± - ‰ΩøÁî®Web Audio APIÂêàÊàêÈü≥Êïà
        let audioContext;
        
        // ËÉåÊôØÈü≥Ê®ÇÁ≥ªÁµ±
        let ambientMusicNodes = [];
        let isMusicPlaying = false;
        let musicGainNode;
        
        // ÁâπÊïàÂèÉÊï∏
        let stars = [];
        let particles = [];
        let constellationLines = [];
        
        // ÂàùÂßãÂåñÈü≥ÊïàÁ≥ªÁµ±
        function initAudio() {
            try {
                audioContext = new (window.AudioContext || window.webkitAudioContext)();
                
                // ÂâµÂª∫Èü≥Ê®ÇÁ∏ΩÈü≥ÈáèÊéßÂà∂
                musicGainNode = audioContext.createGain();
                musicGainNode.connect(audioContext.destination);
                musicGainNode.gain.setValueAtTime(0.15, audioContext.currentTime); // Ë®≠ÂÆöËºÉ‰ΩéÁöÑËÉåÊôØÈü≥Ê®ÇÈü≥Èáè
                
            } catch(e) {
                console.warn('Web Audio API not supported:', e);
            }
        }
        
        // ÂâµÂª∫ÊòüÁ©∫Áí∞Â¢ÉÈü≥Ê®ÇÁ≥ªÁµ±
        function createAmbientMusic() {
            if (!audioContext || !soundToggle.checked || isMusicPlaying) return;
            
            try {
                isMusicPlaying = true;
                
                // Ê∏ÖÈô§‰πãÂâçÁöÑÈü≥Ê®ÇÁØÄÈªû
                stopAmbientMusic();
                
                // Â±§1: Ê∑±Á©∫Âü∫Ë™ø - ‰ΩéÈ†ªÂó°Âó°ËÅ≤
                createDeepSpaceDrone();
                
                // Â±§2: ÊòüÊòüÈñÉÁàçÈü≥Êïà
                createStarTwinkles();
                
                // Â±§3: ÂÆáÂÆôÈ¢®ËÅ≤
                createCosmicWind();
                
                // Â±§4: ÂÅ∂ÁàæÁöÑÂíåÂº¶
                createMysticalChords();
                
                console.log('üåå ÊòüÁ©∫Áí∞Â¢ÉÈü≥Ê®ÇÂ∑≤ÂïüÂãï');
                
            } catch(e) {
                console.warn('Error creating ambient music:', e);
                isMusicPlaying = false;
            }
        }
        
        // Ê∑±Á©∫Âü∫Ë™ø - ÊåÅÁ∫åÁöÑ‰ΩéÈ†ªÂó°Âó°ËÅ≤
        function createDeepSpaceDrone() {
            const drone = audioContext.createOscillator();
            const droneGain = audioContext.createGain();
            
            drone.type = 'sine';
            drone.frequency.setValueAtTime(60, audioContext.currentTime); // ‰ΩéÈ†ª 60Hz
            
            // Á∑©ÊÖ¢ÁöÑÈ†ªÁéáËÆäÂåñÔºåÁáüÈÄ†ÊºÇÁßªÊÑü
            drone.frequency.linearRampToValueAtTime(65, audioContext.currentTime + 20);
            drone.frequency.linearRampToValueAtTime(55, audioContext.currentTime + 40);
            drone.frequency.linearRampToValueAtTime(60, audioContext.currentTime + 60);
            
            droneGain.gain.setValueAtTime(0, audioContext.currentTime);
            droneGain.gain.linearRampToValueAtTime(0.3, audioContext.currentTime + 3); // Á∑©ÊÖ¢Ê∑°ÂÖ•
            
            drone.connect(droneGain);
            droneGain.connect(musicGainNode);
            
            drone.start();
            
            // 60ÁßíÂæåÈáçÊñ∞ÂâµÂª∫ÔºåÂΩ¢ÊàêÂæ™Áí∞
            setTimeout(() => {
                try {
                    drone.stop();
                    if (isMusicPlaying) createDeepSpaceDrone();
                } catch(e) {
                    console.warn('Error in drone recreation:', e);
                }
            }, 60000);
            
            ambientMusicNodes.push(drone);
        }
        
        // ÊòüÊòüÈñÉÁàçÈü≥Êïà - È´òÈ†ªÈö®Ê©üpingËÅ≤
        function createStarTwinkles() {
            const createTwinkle = () => {
                if (!isMusicPlaying) return;
                
                const osc = audioContext.createOscillator();
                const gain = audioContext.createGain();
                
                // Èö®Ê©üÈ†ªÁéáÔºåÊ®°Êì¨‰∏çÂêå‰∫ÆÂ∫¶ÁöÑÊòüÊòü
                const frequency = 800 + Math.random() * 1200; // 800-2000Hz
                osc.frequency.setValueAtTime(frequency, audioContext.currentTime);
                osc.type = 'sine';
                
                // Âø´ÈÄüË°∞Ê∏õÔºåÊ®°Êì¨ÈñÉÁàç
                gain.gain.setValueAtTime(0, audioContext.currentTime);
                gain.gain.linearRampToValueAtTime(0.05, audioContext.currentTime + 0.1);
                gain.gain.exponentialRampToValueAtTime(0.001, audioContext.currentTime + 0.8);
                
                osc.connect(gain);
                gain.connect(musicGainNode);
                
                osc.start();
                osc.stop(audioContext.currentTime + 1);
                
                // Èö®Ê©üÈñìÈöîÂÜçÊ¨°ÈñÉÁàç (2-6Áßí)
                setTimeout(createTwinkle, 2000 + Math.random() * 4000);
            };
            
            // Âª∂ÈÅ≤3ÁßíÈñãÂßãÔºåËÆìÂü∫Ë™øÂÖàÂª∫Á´ã
            setTimeout(createTwinkle, 3000);
        }
        
        // ÂÆáÂÆôÈ¢®ËÅ≤ - ÁôΩÂô™Èü≥Ê∑∑Âêà
        function createCosmicWind() {
            const bufferSize = audioContext.sampleRate * 2; // 2ÁßíÁöÑÁôΩÂô™Èü≥
            const buffer = audioContext.createBuffer(1, bufferSize, audioContext.sampleRate);
            const data = buffer.getChannelData(0);
            
            // ÁîüÊàêÁôΩÂô™Èü≥
            for (let i = 0; i < bufferSize; i++) {
                data[i] = (Math.random() * 2 - 1) * 0.3; // ËºÉËºïÁöÑÂô™Èü≥
            }
            
            const playWind = () => {
                if (!isMusicPlaying) return;
                
                const source = audioContext.createBufferSource();
                const filter = audioContext.createBiquadFilter();
                const windGain = audioContext.createGain();
                
                source.buffer = buffer;
                source.loop = true;
                
                // ‰ΩéÈÄöÊøæÊ≥¢Âô®ÔºåÂè™Áïô‰ΩéÈ†ªÊàêÂàÜ
                filter.type = 'lowpass';
                filter.frequency.setValueAtTime(200, audioContext.currentTime);
                filter.Q.setValueAtTime(1, audioContext.currentTime);
                
                // Á∑©ÊÖ¢ÁöÑÈü≥ÈáèËÆäÂåñ
                windGain.gain.setValueAtTime(0, audioContext.currentTime);
                windGain.gain.linearRampToValueAtTime(0.15, audioContext.currentTime + 5);
                windGain.gain.linearRampToValueAtTime(0.05, audioContext.currentTime + 25);
                windGain.gain.linearRampToValueAtTime(0.15, audioContext.currentTime + 45);
                
                source.connect(filter);
                filter.connect(windGain);
                windGain.connect(musicGainNode);
                
                source.start();
                
                // 50ÁßíÂæåÈáçÊñ∞ÈñãÂßã
                setTimeout(() => {
                    try {
                        source.stop();
                        if (isMusicPlaying) playWind();
                    } catch(e) {
                        console.warn('Error in wind recreation:', e);
                    }
                }, 50000);
                
                ambientMusicNodes.push(source);
            };
            
            // Âª∂ÈÅ≤5ÁßíÈñãÂßã
            setTimeout(playWind, 5000);
        }
        
        // Á•ûÁßòÂíåÂº¶ - ÂÅ∂ÁàæÂá∫ÁèæÁöÑÂíåË´ßÈü≥
        function createMysticalChords() {
            const playChord = () => {
                if (!isMusicPlaying) return;
                
                // CÂ§ßË™øÁöÑÁ•ûÁßòÂíåÂº¶ÁµÑÂêà
                const chordFrequencies = [
                    [261.63, 329.63, 392.00], // C - E - G
                    [293.66, 369.99, 440.00], // D - F# - A
                    [246.94, 311.13, 369.99], // B - D# - F#
                    [220.00, 277.18, 329.63]  // A - C# - E
                ];
                
                const chord = chordFrequencies[Math.floor(Math.random() * chordFrequencies.length)];
                const chordNodes = [];
                
                chord.forEach((freq, index) => {
                    const osc = audioContext.createOscillator();
                    const gain = audioContext.createGain();
                    
                    osc.type = 'triangle'; // ËºÉÊüîÂíåÁöÑÈü≥Ëâ≤
                    osc.frequency.setValueAtTime(freq, audioContext.currentTime);
                    
                    // ÈåØÈñãÊ∑°ÂÖ•ÊôÇÈñìÔºåÂâµÈÄ†Â±§Ê¨°ÊÑü
                    const fadeInDelay = index * 0.5;
                    gain.gain.setValueAtTime(0, audioContext.currentTime + fadeInDelay);
                    gain.gain.linearRampToValueAtTime(0.03, audioContext.currentTime + fadeInDelay + 2);
                    gain.gain.linearRampToValueAtTime(0.02, audioContext.currentTime + fadeInDelay + 8);
                    gain.gain.exponentialRampToValueAtTime(0.001, audioContext.currentTime + fadeInDelay + 12);
                    
                    osc.connect(gain);
                    gain.connect(musicGainNode);
                    
                    osc.start(audioContext.currentTime + fadeInDelay);
                    osc.stop(audioContext.currentTime + fadeInDelay + 12);
                    
                    chordNodes.push(osc);
                });
                
                // 15-30ÁßíÂæåÂÜçÊ¨°Êí≠Êîæ
                setTimeout(playChord, 15000 + Math.random() * 15000);
            };
            
            // Âª∂ÈÅ≤10ÁßíÈñãÂßãÔºåÁµ¶ÂÖ∂‰ªñÂ±§Ê¨°ÊôÇÈñìÂª∫Á´ã
            setTimeout(playChord, 10000);
        }
        
        // ÂÅúÊ≠¢Áí∞Â¢ÉÈü≥Ê®Ç
        function stopAmbientMusic() {
            isMusicPlaying = false;
            
            // ÂÅúÊ≠¢ÊâÄÊúâÈü≥Ê®ÇÁØÄÈªû
            ambientMusicNodes.forEach(node => {
                try {
                    if (node.stop) node.stop();
                    if (node.disconnect) node.disconnect();
                } catch(e) {
                    // ÁØÄÈªûÂèØËÉΩÂ∑≤Á∂ìÂÅúÊ≠¢ÔºåÂøΩÁï•ÈåØË™§
                }
            });
            
            ambientMusicNodes = [];
            console.log('üåå ÊòüÁ©∫Áí∞Â¢ÉÈü≥Ê®ÇÂ∑≤ÂÅúÊ≠¢');
        }
        
        // Ê∑°ÂÖ•ËÉåÊôØÈü≥Ê®Ç
        function fadeInAmbientMusic() {
            if (!audioContext || !musicGainNode) return;
            
            musicGainNode.gain.cancelScheduledValues(audioContext.currentTime);
            musicGainNode.gain.setValueAtTime(0, audioContext.currentTime);
            musicGainNode.gain.linearRampToValueAtTime(0.15, audioContext.currentTime + 3);
        }
        
        // Ê∑°Âá∫ËÉåÊôØÈü≥Ê®Ç
        function fadeOutAmbientMusic() {
            if (!audioContext || !musicGainNode) return;
            
            musicGainNode.gain.cancelScheduledValues(audioContext.currentTime);
            musicGainNode.gain.linearRampToValueAtTime(0, audioContext.currentTime + 2);
            
            setTimeout(() => {
                stopAmbientMusic();
            }, 2500);
        }
        
        // Êí≠ÊîæÈü≥Êïà
        function playSound(type) {
            if (!audioContext || !soundToggle.checked) return;
            
            try {
                // Âª∫Á´ãÈü≥ÊïàÁØÄÈªû
                const oscillator = audioContext.createOscillator();
                const gainNode = audioContext.createGain();
                
                // ÈÄ£Êé•ÁØÄÈªû
                oscillator.connect(gainNode);
                gainNode.connect(audioContext.destination);
                
                // Ë®≠ÁΩÆ‰∏çÂêåÈ°ûÂûãÁöÑÈü≥ÊïàÂèÉÊï∏
                switch(type) {
                    case 'correct':
                        // Ê≠£Á¢∫Èü≥Êïà - ‰∏äÂçáÈü≥
                        oscillator.type = 'sine';
                        oscillator.frequency.setValueAtTime(523.25, audioContext.currentTime);  // C5
                        oscillator.frequency.linearRampToValueAtTime(783.99, audioContext.currentTime + 0.15); // G5
                        gainNode.gain.setValueAtTime(0.3, audioContext.currentTime);
                        gainNode.gain.exponentialRampToValueAtTime(0.01, audioContext.currentTime + 0.3);
                        oscillator.start();
                        oscillator.stop(audioContext.currentTime + 0.3);
                        break;
                    
                    case 'wrong':
                        // ÈåØË™§Èü≥Êïà - ‰∏ãÈôçÈü≥
                        oscillator.type = 'square';
                        oscillator.frequency.setValueAtTime(392.00, audioContext.currentTime);  // G4
                        oscillator.frequency.linearRampToValueAtTime(261.63, audioContext.currentTime + 0.2); // C4
                        gainNode.gain.setValueAtTime(0.2, audioContext.currentTime);
                        gainNode.gain.exponentialRampToValueAtTime(0.01, audioContext.currentTime + 0.3);
                        oscillator.start();
                        oscillator.stop(audioContext.currentTime + 0.3);
                        break;
                    
                    case 'connect':
                        // ÈÄ£Êé•Èü≥Êïà - Áü≠‰øÉÊ∏ÖËÑÜ
                        oscillator.type = 'triangle';
                        oscillator.frequency.setValueAtTime(659.25, audioContext.currentTime); // E5
                        oscillator.frequency.setValueAtTime(783.99, audioContext.currentTime + 0.05); // G5
                        gainNode.gain.setValueAtTime(0.2, audioContext.currentTime);
                        gainNode.gain.exponentialRampToValueAtTime(0.01, audioContext.currentTime + 0.2);
                        oscillator.start();
                        oscillator.stop(audioContext.currentTime + 0.2);
                        break;
                    
                    case 'click':
                        // ÈªûÊìäÈü≥Êïà - ÈùûÂ∏∏Áü≠‰øÉ
                        oscillator.type = 'sine';
                        oscillator.frequency.setValueAtTime(880.00, audioContext.currentTime); // A5
                        oscillator.frequency.setValueAtTime(987.77, audioContext.currentTime + 0.03); // B5
                        gainNode.gain.setValueAtTime(0.1, audioContext.currentTime);
                        gainNode.gain.exponentialRampToValueAtTime(0.01, audioContext.currentTime + 0.08);
                        oscillator.start();
                        oscillator.stop(audioContext.currentTime + 0.08);
                        break;
                        
                    case 'hint':
                        // ÊèêÁ§∫Èü≥Êïà - Á•ûÁßòÁöÑ‰∏âÂíåÂº¶
                        oscillator.type = 'triangle';
                        oscillator.frequency.setValueAtTime(523.25, audioContext.currentTime); // C5
                        oscillator.frequency.setValueAtTime(659.25, audioContext.currentTime + 0.1); // E5
                        oscillator.frequency.setValueAtTime(783.99, audioContext.currentTime + 0.2); // G5
                        gainNode.gain.setValueAtTime(0.15, audioContext.currentTime);
                        gainNode.gain.exponentialRampToValueAtTime(0.01, audioContext.currentTime + 0.4);
                        oscillator.start();
                        oscillator.stop(audioContext.currentTime + 0.4);
                        break;
                }
            } catch(e) {
                console.warn('Error playing sound:', e);
            }
        }
        
        // Á∂≤Ê†ºË®≠ÁΩÆ
        const gridSize = 50; // ÊØèÂÄãÊ†ºÂ≠êÁöÑÂ§ßÂ∞è
        const numRows = 8;   // Ë°åÊï∏
        const numCols = 8;   // ÂàóÊï∏
        const offsetX = 25;  // XÂÅèÁßªÔºà‰ΩøÁ∂≤Ê†ºÂæûÈÇäÁ∑£ÈñãÂßãÔºâ
        const offsetY = 25;  // YÂÅèÁßª

        // ÈÅäÊà≤ÁãÄÊÖã
        let selectedPoint = null;
        let lastMouseX = 0;
        let lastMouseY = 0;
        let isComplete = false;
        let currentLevelIndex = 0;
        let hoveredPoint = null;
        
        // Ë®àÂàÜÁ≥ªÁµ±
        let score = 0;
        let streak = 0;  // ÈÄ£Âãù
        let solvedCount = 0; // Â∑≤Ëß£È°åÊï∏
        
        // Achievement system
        const achievements = [
            { id: 'novice', level: 1, name: 'Stellar Novice', description: 'Complete your first constellation', icon: 'üåü', unlocked: false },
            { id: 'connector', level: 2, name: 'Star Connector', description: 'Complete 2 constellations', icon: '‚≠ê', unlocked: false },
            { id: 'seeker', level: 3, name: 'Constellation Seeker', description: 'Complete 3 constellations', icon: '‚ú®', unlocked: false },
            { id: 'observer', level: 4, name: 'Night Sky Observer', description: 'Complete 4 constellations', icon: 'üî≠', unlocked: false },
            { id: 'apprentice', level: 5, name: 'Astronomy Apprentice', description: 'Complete 5 constellations', icon: 'üìö', unlocked: false },
            { id: 'ancient', level: 6, name: 'Ancient Astronomer', description: 'Complete 6 constellations', icon: 'üèõÔ∏è', unlocked: false },
            { id: 'interpreter', level: 7, name: 'Star Chart Interpreter', description: 'Complete 7 constellations', icon: 'üßô', unlocked: false },
            { id: 'master', level: 8, name: 'Stellar Explorer Master', description: 'Complete 8 constellations', icon: 'üëë', unlocked: false }
        ];
        let newUnlocks = [];
        
        // Timer system
        let timeLeft = 60; // 60 seconds
        let timerInterval;
        let isGameActive = false;
        
        // Difficulty system
        let currentDifficulty = "Normal"; // Normal, Hard
        
        // ÈªûÁöÑÂ§ßÂ∞è
        const pointRadius = 7;
        
        // Áî®Êà∂ÈÄ£Êé•ÁöÑÁ∑ö
        let userLines = [];
        
        // Á≤íÂ≠êÊïàÊûúÁõ∏Èóú
        let animationFrameId = null;
        
        // Triangle level definitions
        const triangleLevels = [
            // Equilateral triangle series - precisely calculated grid points
            {
                name: "Equilateral Triangle",
                description: "Please connect the stars to form an equilateral triangle constellation",
                hint: "An equilateral triangle has three equal sides, with each interior angle being 60 degrees.",
                checkFunction: isEquilateralTriangle,
                presetLine: {from: {row: 5, col: 3}, to: {row: 5, col: 5}}, // horizontal line
                solutionPoint: {row: 3, col: 4}, // precise equilateral triangle vertex
                congratsMessage: "Well done! You successfully created an equilateral triangle constellation!",
                requiredLines: 2,
                difficulty: 3,
                type: "triangle"
            },
            {
                name: "Equilateral Triangle",
                description: "Please connect the stars to form an equilateral triangle constellation",
                hint: "An equilateral triangle has three equal sides, with each interior angle being 60 degrees.",
                checkFunction: isEquilateralTriangle,
                presetLine: {from: {row: 3, col: 3}, to: {row: 7, col: 5}}, // diagonal line
                solutionPoint: {row: 5, col: 1}, // precise equilateral triangle vertex
                congratsMessage: "Well done! You successfully created an equilateral triangle constellation!",
                requiredLines: 2,
                difficulty: 3,
                type: "triangle"
            },
            {
                name: "Equilateral Triangle",
                description: "Please connect the stars to form an equilateral triangle constellation",
                hint: "An equilateral triangle has three equal sides, with each interior angle being 60 degrees.",
                checkFunction: isEquilateralTriangle,
                presetLine: {from: {row: 4, col: 2}, to: {row: 4, col: 6}}, // horizontal line
                solutionPoint: {row: 1, col: 4}, // precise equilateral triangle vertex
                congratsMessage: "Well done! You successfully created an equilateral triangle constellation!",
                requiredLines: 2,
                difficulty: 3,
                type: "triangle"
            },
            
            // Isosceles triangle series - multiple preset lines
            {
                name: "Isosceles Triangle",
                description: "Please connect the stars to form an isosceles triangle constellation",
                hint: "An isosceles triangle has two equal sides. Find a point equidistant from both ends of the blue line.",
                checkFunction: isIsoscelesTriangle,
                presetLine: {from: {row: 4, col: 2}, to: {row: 4, col: 6}}, // horizontal line
                solutionPoint: {row: 2, col: 4}, // definite solution
                congratsMessage: "Awesome! You successfully created an isosceles triangle constellation!",
                requiredLines: 2,
                difficulty: 2,
                type: "triangle"
            },
            {
                name: "Isosceles Triangle",
                description: "Please connect the stars to form an isosceles triangle constellation",
                hint: "An isosceles triangle has two equal sides. Find a point equidistant from both ends of the blue line.",
                checkFunction: isIsoscelesTriangle,
                presetLine: {from: {row: 2, col: 2}, to: {row: 6, col: 6}}, // diagonal line
                solutionPoint: {row: 6, col: 2}, // definite solution
                congratsMessage: "Awesome! You successfully created an isosceles triangle constellation!",
                requiredLines: 2,
                difficulty: 2,
                type: "triangle"
            },
            {
                name: "Isosceles Triangle",
                description: "Please connect the stars to form an isosceles triangle constellation",
                hint: "An isosceles triangle has two equal sides. Find a point equidistant from both ends of the blue line.",
                checkFunction: isIsoscelesTriangle,
                presetLine: {from: {row: 3, col: 2}, to: {row: 5, col: 5}}, // diagonal line
                solutionPoint: {row: 2, col: 6}, // definite solution
                congratsMessage: "Awesome! You successfully created an isosceles triangle constellation!",
                requiredLines: 2,
                difficulty: 2,
                type: "triangle"
            },
            
            // Right triangle series - Pythagorean triples
            {
                name: "Right Triangle",
                description: "Please connect the stars to form a right triangle constellation",
                hint: "A right triangle has one 90-degree angle. Find a point that makes two sides perpendicular.",
                checkFunction: isRightTriangle,
                presetLine: {from: {row: 2, col: 2}, to: {row: 2, col: 6}}, // horizontal line
                solutionPoint: {row: 6, col: 6}, // 3:4:5 triple
                congratsMessage: "Excellent! You successfully created a right triangle constellation!",
                requiredLines: 2,
                difficulty: 2,
                type: "triangle"
            },
            {
                name: "Right Triangle",
                description: "Please connect the stars to form a right triangle constellation",
                hint: "A right triangle has one 90-degree angle. Find a point that makes two sides perpendicular.",
                checkFunction: isRightTriangle,
                presetLine: {from: {row: 4, col: 1}, to: {row: 4, col: 5}}, // horizontal line
                solutionPoint: {row: 1, col: 5}, // 3:4:5 triple
                congratsMessage: "Excellent! You successfully created a right triangle constellation!",
                requiredLines: 2,
                difficulty: 2,
                type: "triangle"
            },
            {
                name: "Right Triangle",
                description: "Please connect the stars to form a right triangle constellation",
                hint: "A right triangle has one 90-degree angle. Find a point that makes two sides perpendicular.",
                checkFunction: isRightTriangle,
                presetLine: {from: {row: 3, col: 2}, to: {row: 6, col: 6}}, // diagonal line
                solutionPoint: {row: 7, col: 2}, // 5:12:13 triple variant
                congratsMessage: "Excellent! You successfully created a right triangle constellation!",
                requiredLines: 2,
                difficulty: 2,
                type: "triangle"
            },
            
            // Right isosceles triangle series
            {
                name: "Right Isosceles Triangle",
                description: "Please connect the stars to form a right isosceles triangle constellation",
                hint: "A right isosceles triangle has one 90-degree angle and two equal sides.",
                checkFunction: isRightIsoscelesTriangle,
                presetLine: {from: {row: 3, col: 3}, to: {row: 3, col: 7}}, // horizontal line
                solutionPoint: {row: 7, col: 3}, // perfect right isosceles solution
                congratsMessage: "Fantastic! You successfully created a right isosceles triangle constellation!",
                requiredLines: 2,
                difficulty: 3,
                type: "triangle"
            },
            {
                name: "Right Isosceles Triangle",
                description: "Please connect the stars to form a right isosceles triangle constellation",
                hint: "A right isosceles triangle has one 90-degree angle and two equal sides.",
                checkFunction: isRightIsoscelesTriangle,
                presetLine: {from: {row: 2, col: 2}, to: {row: 6, col: 2}}, // vertical line
                solutionPoint: {row: 6, col: 6}, // perfect right isosceles solution
                congratsMessage: "Fantastic! You successfully created a right isosceles triangle constellation!",
                requiredLines: 2,
                difficulty: 3,
                type: "triangle"
            },
            {
                name: "Right Isosceles Triangle",
                description: "Please connect the stars to form a right isosceles triangle constellation",
                hint: "A right isosceles triangle has one 90-degree angle and two equal sides.",
                checkFunction: isRightIsoscelesTriangle,
                presetLine: {from: {row: 4, col: 1}, to: {row: 1, col: 4}}, // diagonal line
                solutionPoint: {row: 4, col: 4}, // perfect right isosceles solution
                congratsMessage: "Fantastic! You successfully created a right isosceles triangle constellation!",
                requiredLines: 2,
                difficulty: 3,
                type: "triangle"
            },
            
            // Scalene triangle series
            {
                name: "Scalene Triangle",
                description: "Please connect the stars to form a scalene triangle constellation",
                hint: "A scalene triangle has three sides of different lengths.",
                checkFunction: isScaleneTriangle,
                presetLine: {from: {row: 3, col: 2}, to: {row: 5, col: 5}}, // diagonal line
                solutionPoint: {row: 6, col: 2}, // ensure all sides are unequal
                congratsMessage: "Excellent! You successfully created a scalene triangle constellation!",
                requiredLines: 2,
                difficulty: 2,
                type: "triangle"
            },
            {
                name: "Scalene Triangle",
                description: "Please connect the stars to form a scalene triangle constellation",
                hint: "A scalene triangle has three sides of different lengths.",
                checkFunction: isScaleneTriangle,
                presetLine: {from: {row: 2, col: 2}, to: {row: 5, col: 6}}, // diagonal line
                solutionPoint: {row: 7, col: 3}, // ensure all sides are unequal
                congratsMessage: "Excellent! You successfully created a scalene triangle constellation!",
                requiredLines: 2,
                difficulty: 2,
                type: "triangle"
            },
            {
                name: "Scalene Triangle",
                description: "Please connect the stars to form a scalene triangle constellation",
                hint: "A scalene triangle has three sides of different lengths.",
                checkFunction: isScaleneTriangle,
                presetLine: {from: {row: 4, col: 4}, to: {row: 4, col: 7}}, // horizontal line
                solutionPoint: {row: 1, col: 2}, // ensure all sides are unequal
                congratsMessage: "Excellent! You successfully created a scalene triangle constellation!",
                requiredLines: 2,
                difficulty: 2,
                type: "triangle"
            }
        ];
        
        // Quadrilateral level definitions - all trapezoid-related levels removed
        const quadrilateralLevels = [
            // Square series
            {
                name: "Square",
                description: "Please connect the stars to form a square constellation",
                hint: "A square has four equal sides and four 90-degree angles.",
                checkFunction: isSquare,
                presetLine: {from: {row: 2, col: 2}, to: {row: 2, col: 6}}, // horizontal line
                solutionPoints: [{row: 6, col: 2}, {row: 6, col: 6}], // the other two points of the square
                congratsMessage: "Awesome! You successfully created a square constellation!",
                requiredLines: 3,
                difficulty: 2,
                type: "quadrilateral"
            },
            {
                name: "Square",
                description: "Please connect the stars to form a square constellation",
                hint: "A square has four equal sides and four 90-degree angles.",
                checkFunction: isSquare,
                presetLine: {from: {row: 3, col: 3}, to: {row: 3, col: 7}}, // horizontal line
                solutionPoints: [{row: 7, col: 3}, {row: 7, col: 7}], // the other two points of the square
                congratsMessage: "Awesome! You successfully created a square constellation!",
                requiredLines: 3,
                difficulty: 2,
                type: "quadrilateral"
            },
            {
                name: "Square",
                description: "Please connect the stars to form a square constellation",
                hint: "A square has four equal sides and four 90-degree angles.",
                checkFunction: isSquare,
                presetLine: {from: {row: 2, col: 2}, to: {row: 6, col: 2}}, // vertical line
                solutionPoints: [{row: 2, col: 6}, {row: 6, col: 6}], // the other two points of the square
                congratsMessage: "Awesome! You successfully created a square constellation!",
                requiredLines: 3,
                difficulty: 2,
                type: "quadrilateral"
            },
            
            // Rectangle series
            {
                name: "Rectangle",
                description: "Please connect the stars to form a rectangle constellation",
                hint: "A rectangle has four 90-degree angles and opposite sides are equal.",
                checkFunction: isRectangle,
                presetLine: {from: {row: 2, col: 2}, to: {row: 2, col: 7}}, // horizontal line
                solutionPoints: [{row: 5, col: 2}, {row: 5, col: 7}], // the other two points of the rectangle
                congratsMessage: "Great! You successfully created a rectangle constellation!",
                requiredLines: 3,
                difficulty: 2,
                type: "quadrilateral"
            },
            {
                name: "Rectangle",
                description: "Please connect the stars to form a rectangle constellation",
                hint: "A rectangle has four 90-degree angles and opposite sides are equal.",
                checkFunction: isRectangle,
                presetLine: {from: {row: 1, col: 1}, to: {row: 6, col: 1}}, // vertical line
                solutionPoints: [{row: 1, col: 4}, {row: 6, col: 4}], // the other two points of the rectangle
                congratsMessage: "Great! You successfully created a rectangle constellation!",
                requiredLines: 3,
                difficulty: 2,
                type: "quadrilateral"
            },
            {
                name: "Rectangle",
                description: "Please connect the stars to form a rectangle constellation",
                hint: "A rectangle has four 90-degree angles and opposite sides are equal.",
                checkFunction: isRectangle,
                presetLine: {from: {row: 3, col: 1}, to: {row: 3, col: 7}}, // horizontal line
                solutionPoints: [{row: 7, col: 1}, {row: 7, col: 7}], // the other two points of the rectangle
                congratsMessage: "Great! You successfully created a rectangle constellation!",
                requiredLines: 3,
                difficulty: 2,
                type: "quadrilateral"
            },
            
            // Parallelogram series
            {
                name: "Parallelogram",
                description: "Please connect the stars to form a parallelogram constellation",
                hint: "A parallelogram has two pairs of parallel opposite sides that are equal.",
                checkFunction: isParallelogram,
                presetLine: {from: {row: 3, col: 2}, to: {row: 3, col: 6}}, // horizontal line
                solutionPoints: [{row: 6, col: 4}, {row: 6, col: 8}], // the other two points of the parallelogram
                congratsMessage: "Outstanding! You successfully created a parallelogram constellation!",
                requiredLines: 3,
                difficulty: 3,
                type: "quadrilateral"
            },
            {
                name: "Parallelogram",
                description: "Please connect the stars to form a parallelogram constellation",
                hint: "A parallelogram has two pairs of parallel opposite sides that are equal.",
                checkFunction: isParallelogram,
                presetLine: {from: {row: 2, col: 2}, to: {row: 5, col: 2}}, // vertical line
                solutionPoints: [{row: 3, col: 6}, {row: 6, col: 6}], // the other two points of the parallelogram
                congratsMessage: "Outstanding! You successfully created a parallelogram constellation!",
                requiredLines: 3,
                difficulty: 3,
                type: "quadrilateral"
            },
            {
                name: "Parallelogram",
                description: "Please connect the stars to form a parallelogram constellation",
                hint: "A parallelogram has two pairs of parallel opposite sides that are equal.",
                checkFunction: isParallelogram,
                presetLine: {from: {row: 2, col: 2}, to: {row: 2, col: 6}}, // horizontal line
                solutionPoints: [{row: 5, col: 4}, {row: 5, col: 8}], // the other two points of the parallelogram
                congratsMessage: "Outstanding! You successfully created a parallelogram constellation!",
                requiredLines: 3,
                difficulty: 3,
                type: "quadrilateral"
            }
        ];
        
        // Âêà‰ΩµÊâÄÊúâÈóúÂç°
        let levels = [...triangleLevels];
        let currentLevels = [...triangleLevels]; // Áï∂Ââç‰ΩøÁî®ÁöÑÈóúÂç°ÈõÜ
        
        // ÂãïÁï´Âæ™Áí∞
        function animate() {
            // Êõ¥Êñ∞Á≤íÂ≠ê
            updateParticles();
            
            // ÁπºÁ∫åÂãïÁï´Âæ™Áí∞
            animationFrameId = requestAnimationFrame(animate);
        }
        
        // Êõ¥Êñ∞Á≤íÂ≠ê
        function updateParticles() {
            // Êõ¥Êñ∞Á≤íÂ≠ê‰ΩçÁΩÆÂíåÁîüÂëΩÈÄ±Êúü
            for (let i = particles.length - 1; i >= 0; i--) {
                const particle = particles[i];
                
                // Êõ¥Êñ∞‰ΩçÁΩÆ
                particle.x += particle.vx;
                particle.y += particle.vy;
                
                // Êõ¥Êñ∞ÁîüÂëΩ
                particle.life -= 0.02;
                
                // Â¶ÇÊûúÁ≤íÂ≠êÊ≠ª‰∫°ÔºåÁßªÈô§
                if (particle.life <= 0) {
                    particle.element.remove();
                    particles.splice(i, 1);
                } else {
                    // Êõ¥Êñ∞ÈÄèÊòéÂ∫¶
                    particle.element.style.opacity = particle.life;
                    
                    // Êõ¥Êñ∞‰ΩçÁΩÆ
                    particle.element.style.left = `${particle.x}px`;
                    particle.element.style.top = `${particle.y}px`;
                }
            }
            
            // Êõ¥Êñ∞ÊòüÊòüÈñÉÁàçÊïàÊûú
            for (const star of stars) {
                if (Math.random() < 0.005) {
                    const originalScale = parseFloat(star.element.getAttribute('data-scale') || 1);
                    const newScale = originalScale * (0.8 + Math.random() * 0.4);
                    star.element.style.transform = `scale(${newScale})`;
                    
                    setTimeout(() => {
                        if (star.element.parentNode) {
                            star.element.style.transform = `scale(${originalScale})`;
                        }
                    }, 300 + Math.random() * 700);
                }
            }
        }
        
        // ÂâµÂª∫ÊòüÊòüÊïàÊûú
        function createStar(x, y, size = 3, container = document.body) {
            // ÂâµÂª∫ÊòüÊòü
            const star = document.createElement('div');
            star.className = 'star';
            star.style.width = `${size}px`;
            star.style.height = `${size}px`;
            star.style.left = `${x}px`;
            star.style.top = `${y}px`;
            star.setAttribute('data-scale', '1');
            
            // ÂâµÂª∫ÁôºÂÖâÊïàÊûú
            const glow = document.createElement('div');
            glow.className = 'star-glow';
            glow.style.width = `${size * 6}px`;
            glow.style.height = `${size * 6}px`;
            glow.style.left = `${x - size * 2.5}px`;
            glow.style.top = `${y - size * 2.5}px`;
            
            // Èö®Ê©üÈñÉÁàçÊôÇÈñì
            glow.style.animationDelay = `${Math.random() * 2}s`;
            
            // Ê∑ªÂä†Âà∞ÂÆπÂô®
            container.appendChild(star);
            container.appendChild(glow);
            
            return {
                element: star,
                glow: glow,
                x: x,
                y: y,
                size: size
            };
        }
        
        // ÂâµÂª∫Á≤íÂ≠ê
        function createParticle(x, y, color = '#64FFDA') {
            const size = 1 + Math.random() * 2;
            const particle = document.createElement('div');
            particle.className = 'particle';
            particle.style.width = `${size}px`;
            particle.style.height = `${size}px`;
            particle.style.backgroundColor = color;
            particle.style.left = `${x}px`;
            particle.style.top = `${y}px`;
            
            document.body.appendChild(particle);
            
            // Á≤íÂ≠êÂ±¨ÊÄß
            const particleObj = {
                element: particle,
                x: x,
                y: y,
                vx: (Math.random() - 0.5) * 2,
                vy: (Math.random() - 0.5) * 2,
                size: size,
                life: 1 // Âæû1Ê∏õÂ∞ëÂà∞0
            };
            
            particles.push(particleObj);
            return particleObj;
        }
        
        // ÂâµÂª∫ÈÄ£Êé•Á∑öÊïàÊûú
        function createConstellationLine(fromX, fromY, toX, toY) {
            const dx = toX - fromX;
            const dy = toY - fromY;
            const length = Math.sqrt(dx * dx + dy * dy);
            const angle = Math.atan2(dy, dx);
            
            const line = document.createElement('div');
            line.className = 'constellation-line';
            line.style.width = `${length}px`;
            line.style.left = `${fromX}px`;
            line.style.top = `${fromY}px`;
            line.style.transform = `rotate(${angle}rad)`;
            
            document.body.appendChild(line);
            
            // Âú®Á∑öÊ¢ù‰∏äÊ∑ªÂä†Á≤íÂ≠êÊïàÊûú
            const particleCount = Math.max(5, Math.floor(length / 20));
            for (let i = 0; i < particleCount; i++) {
                const ratio = Math.random();
                const x = fromX + dx * ratio;
                const y = fromY + dy * ratio;
                createParticle(x, y, 'rgba(100, 255, 218, 0.8)');
            }
            
            constellationLines.push(line);
            return line;
        }
        
        // Ê∏ÖÈô§ÊïàÊûúÂÖÉÁ¥†
        function clearEffects() {
            // Ê∏ÖÈô§ÊòüÊòü
            stars.forEach(star => {
                if (star.element.parentNode) star.element.parentNode.removeChild(star.element);
                if (star.glow.parentNode) star.glow.parentNode.removeChild(star.glow);
            });
            stars = [];
            
            // Ê∏ÖÈô§Á≤íÂ≠ê
            particles.forEach(particle => {
                if (particle.element.parentNode) 
                    particle.element.parentNode.removeChild(particle.element);
            });
            particles = [];
            
            // Ê∏ÖÈô§ÈÄ£Êé•Á∑ö
            constellationLines.forEach(line => {
                if (line.parentNode) line.parentNode.removeChild(line);
            });
            constellationLines = [];
            
            // ÂèñÊ∂àÂãïÁï´
            if (animationFrameId) {
                cancelAnimationFrame(animationFrameId);
                animationFrameId = null;
            }
        }
        
        // ÂâµÂª∫ÈÄ£Êé•Á∑ö
        function createConnectionLine(fromPoint, toPoint) {
            // Ë®àÁÆóÁ∂≤Ê†ºÂ∞∫ÂØ∏ÊØî‰æãÂíåÂ∫ßÊ®ô
            const gridRatio = (canvas.width - 2 * offsetX) / (numCols * gridSize);
            const fromX = offsetX + fromPoint.col * gridSize * gridRatio;
            const fromY = offsetY + fromPoint.row * gridSize * gridRatio;
            const toX = offsetX + toPoint.col * gridSize * gridRatio;
            const toY = offsetY + toPoint.row * gridSize * gridRatio;
            
            // Áç≤ÂèñCanvasÁõ∏Â∞çÊñºË¶ñÁ™óÁöÑ‰ΩçÁΩÆ
            const rect = canvas.getBoundingClientRect();
            
            // ÂâµÂª∫ÈÄ£Êé•Á∑öÊïàÊûú
            createConstellationLine(
                rect.left + fromX, 
                rect.top + fromY, 
                rect.left + toX, 
                rect.top + toY
            );
            
            // Âú®Á∑öË∑Ø‰∏äÁîüÊàêÁ≤íÂ≠êÊïàÊûú
            const particleCount = 8 + Math.floor(Math.random() * 5);
            for (let i = 0; i < particleCount; i++) {
                setTimeout(() => {
                    const ratio = i / (particleCount - 1);
                    const x = rect.left + fromX + (toX - fromX) * ratio;
                    const y = rect.top + fromY + (toY - fromY) * ratio;
                    createParticle(x, y);
                }, i * 50);
            }
        }
        
        // ÂàùÂßãÂåñÈÅäÊà≤
        function init() {
            // ÂàùÂßãÂåñÈü≥Êïà
            initAudio();
            
            // ÂâµÂª∫ËÉåÊôØÊòüÊòü
            createBackgroundStars();
            
            // ÂïüÂãïÂãïÁï´Âæ™Áí∞
            animate();
            
            // Ê∑ªÂä†‰∫ã‰ª∂Áõ£ËÅΩÂô®
            document.getElementById('startGameBtn').addEventListener('click', startGame);
            document.getElementById('playAgainBtn').addEventListener('click', restartGame);
            document.getElementById('howToPlayBtn').addEventListener('click', toggleInstructions);
            
            canvas.addEventListener('mousedown', handleMouseDown);
            canvas.addEventListener('mousemove', handleMouseMove);
            document.addEventListener('mouseup', handleMouseUp);
            
            canvas.addEventListener('touchstart', handleTouchStart, {passive: false});
            canvas.addEventListener('touchmove', handleTouchMove, {passive: false});
            canvas.addEventListener('touchend', handleTouchEnd);
            
            // ÊåâÈàï‰∫ã‰ª∂
            document.getElementById('resetBtn').addEventListener('click', resetLines);
            document.getElementById('checkBtn').addEventListener('click', checkShape);
            document.getElementById('hintTextBtn').addEventListener('click', toggleTextHint);
            document.getElementById('hintVisualBtn').addEventListener('click', showVisualHint);
            
            // ÂΩ¢ÁãÄÈÅ∏Êìá‰∫ã‰ª∂
            const shapeOptions = document.querySelectorAll('input[name="shapeType"]');
            shapeOptions.forEach(option => {
                option.addEventListener('change', function() {
                    if (this.checked) {
                        selectedShapeType = this.value;
                    }
                });
            });
            
            // Ë™™ÊòéÈù¢ÊùøÊªæÂãï‰∫ã‰ª∂ËôïÁêÜ
            const instructionsPanel = document.getElementById('gameInstructions');
            instructionsPanel.addEventListener('touchstart', function(e) {
                e.stopPropagation();
            }, {passive: true});
            
            instructionsPanel.addEventListener('touchmove', function(e) {
                e.stopPropagation();
            }, {passive: true});
            
            instructionsPanel.addEventListener('wheel', function(e) {
                e.stopPropagation();
            }, {passive: true});
            
            // Èò≤Ê≠¢ËÉåÊôØÊªæÂãïÁ©øÈÄè - Êõ¥Á≤æÁ¢∫ÁöÑÊéßÂà∂
            document.addEventListener('touchmove', function(e) {
                const instructions = document.getElementById('gameInstructions');
                const startScreen = document.getElementById('startScreen');
                
                if (instructions.classList.contains('show')) {
                    const target = e.target;
                    const isInsideInstructions = instructions.contains(target);
                    const isInStartScreen = startScreen.contains(target);
                    
                    // Â¶ÇÊûúÂú®Ë™™ÊòéÈù¢ÊùøÂ§ñ‰ΩÜÂú®Ëµ∑ÂßãÁï´Èù¢ÂÖßÔºåÂÖÅË®±ÊªæÂãïËµ∑ÂßãÁï´Èù¢
                    if (!isInsideInstructions && isInStartScreen) {
                        // ÂÖÅË®±Ëµ∑ÂßãÁï´Èù¢ÊªæÂãï
                        return;
                    } else if (!isInsideInstructions) {
                        // Âú®Ë™™ÊòéÈù¢ÊùøÂíåËµ∑ÂßãÁï´Èù¢Â§ñÔºåÈòªÊ≠¢ÊªæÂãï
                        e.preventDefault();
                    }
                }
            }, {passive: false});
            
            // Ë¶ñÁ™óÂ§ßÂ∞èÊîπËÆäÊôÇÈáçÁï´
            window.addEventListener('resize', () => {
                resizeCanvas();
                createBackgroundStars();
            });
            resizeCanvas();
            
            // È†êËºâÂÖ•Á¨¨‰∏ÄÈóú‰ΩÜ‰∏çÈñãÂßãÈÅäÊà≤
            loadLevel(0);
            
            console.log("Game initialized, please click 'Begin Your Journey' button to start the game");
        }
        
        // ÈñãÂßãÈÅäÊà≤
        function startGame() {
            startScreen.style.display = 'none';
            
            // Ê†πÊìöÈÅ∏ÊìáÁöÑÂΩ¢ÁãÄÈ°ûÂûãË®≠ÁΩÆÈóúÂç°
            setLevelsByShapeType();
            
            // Update page title
            document.title = `Stellar Explorer - ${getShapeTypeName()} Learning`;
            document.querySelector('h1').textContent = `Stellar Explorer - ${getShapeTypeName()} Constellation Learning`;
            
            // Êõ¥Êñ∞‰ø°ÊÅØÊñáÂ≠ó
            updateShapeInfoText();
            
            // ÈáçÁΩÆÈÅäÊà≤ÁãÄÊÖã
            score = 0;
            streak = 0;
            solvedCount = 0;
            timeLeft = 60;
            isGameActive = true;
            
            // Ê∏ÖÁ©∫Êñ∞Ëß£ÈéñÁöÑÊàêÂ∞±ÂàóË°®
            newUnlocks = [];
            
            // ÈáçÁΩÆÊàêÂ∞±ÁãÄÊÖã
            for (const achievement of achievements) {
                achievement.unlocked = false;
            }
            
            // Èö®Ê©üÈÅ∏Êìá‰∏ÄÂÄãÈóúÂç°ÈñãÂßã
            loadRandomLevel();
            
            // Êõ¥Êñ∞UI
            updateScoreDisplay();
            
            // Reset difficulty
            currentDifficulty = "Normal";
            difficultyDisplay.textContent = `Difficulty: ${currentDifficulty}`;
            
            // ÂïüÂãïË®àÊôÇÂô®
            startTimer();
            
            // Êí≠ÊîæÈñãÂßãÈü≥Êïà
            playSound('click');
            
            // Ê∏ÖÈô§ÁèæÊúâÊïàÊûú
            clearEffects();
            
            // ÈáçÂïüÂãïÁï´Âæ™Áí∞
            if (!animationFrameId) {
                animate();
            }
            
            // ÂïüÂãïÁí∞Â¢ÉÈü≥Ê®Ç
            setTimeout(() => {
                createAmbientMusic();
                fadeInAmbientMusic();
            }, 1000); // 1ÁßíÂæåÈñãÂßãÔºåËÆìÈñãÂßãÈü≥ÊïàÂÖàÊí≠Êîæ
            
            console.log("Game started");
        }
        
        // Ë®≠ÁΩÆÈóúÂç°Ê†πÊìöÂΩ¢ÁãÄÈ°ûÂûã
        function setLevelsByShapeType() {
            switch(selectedShapeType) {
                case "triangles":
                    currentLevels = [...triangleLevels];
                    break;
                case "quadrilaterals":
                    currentLevels = [...quadrilateralLevels];
                    break;
                case "all":
                    currentLevels = [...triangleLevels, ...quadrilateralLevels];
                    break;
                default:
                    currentLevels = [...triangleLevels];
            }
            // Á¢∫‰øùlevelsÊï∏ÁµÑÂºïÁî®currentLevelsÁöÑÊï∏Êìö
            levels = currentLevels;
            
            if (debugMode) {
                console.log(`Ë®≠ÁΩÆÈóúÂç°È°ûÂûã: ${selectedShapeType}`);
                console.log(`Á∏ΩÈóúÂç°Êï∏: ${levels.length}`);
            }
        }
        
        // Get shape type name
        function getShapeTypeName() {
            switch(selectedShapeType) {
                case "triangles": return "Triangle";
                case "quadrilaterals": return "Quadrilateral";
                case "all": return "Geometric Shapes";
                default: return "Geometric Shapes";
            }
        }
        
        // Update shape info text
        function updateShapeInfoText() {
            let infoText = "";
            switch(selectedShapeType) {
                case "triangles":
                    infoText = "Connect the shining stars to form the specified triangle constellation type";
                    break;
                case "quadrilaterals":
                    infoText = "Connect the shining stars to form the specified quadrilateral constellation type";
                    break;
                case "all":
                    infoText = "Connect the shining stars to form the specified geometric constellation type";
                    break;
                default:
                    infoText = "Connect the shining stars to form the specified geometric constellation type";
            }
            shapeInfo.textContent = infoText;
        }
        
        // ÈáçÊñ∞ÈñãÂßãÈÅäÊà≤
        function restartGame() {
            resultScreen.style.display = 'none';
            startGame();
        }
        
        // ÂàáÊèõÈÅäÊà≤Ë™™ÊòéÈ°ØÁ§∫
        function toggleInstructions() {
            const instructions = document.getElementById('gameInstructions');
            const arrow = document.querySelector('.btn-arrow');
            const startScreen = document.getElementById('startScreen');
            
            // Êí≠ÊîæÈªûÊìäÈü≥Êïà
            playSound('click');
            
            if (instructions.classList.contains('show')) {
                // Èö±ËóèË™™Êòé
                instructions.classList.remove('show');
                arrow.textContent = '‚Üì';
                arrow.style.transform = 'translateY(0)';
                // ÊÅ¢Âæ©Ê≠£Â∏∏ÊªæÂãï
                startScreen.style.overflow = '';
                startScreen.style.height = '';
            } else {
                // È°ØÁ§∫Ë™™Êòé
                instructions.classList.add('show');
                arrow.textContent = '‚Üë';
                arrow.style.transform = 'translateY(-2px)';
                // ÂÖÅË®±Êï¥ÂÄãËµ∑ÂßãÁï´Èù¢ÊªæÂãï
                startScreen.style.overflow = 'auto';
                startScreen.style.height = '100vh';
                
                // Á¢∫‰øùË™™ÊòéÈù¢ÊùøÂèØ‰ª•ÊªæÂãï
                setTimeout(() => {
                    const instructionContent = instructions.querySelector('.instruction-content');
                    if (instructionContent) {
                        instructionContent.scrollTop = 0;
                    }
                }, 100);
            }
        }
        
        // È°ØÁ§∫Ë¶ñË¶∫ÊèêÁ§∫
        function showVisualHint() {
            if (!isGameActive) return;
            
            playSound('hint');
            
            const level = levels[currentLevelIndex];
            
            // Ë®àÁÆóÁ∂≤Ê†ºÂ∞∫ÂØ∏ÊØî‰æã
            const gridRatio = (canvas.width - 2 * offsetX) / (numCols * gridSize);
            
            // Ê†πÊìöÈóúÂç°È°ûÂûãÈ°ØÁ§∫ÊèêÁ§∫
            if (level.type === "triangle") {
                const solutionPoint = level.solutionPoint;
                const x = offsetX + solutionPoint.col * gridSize * gridRatio;
                const y = offsetY + solutionPoint.row * gridSize * gridRatio;
                
                // Áπ™Ë£ΩÈñÉÁàçÊèêÁ§∫ÊïàÊûú
                ctx.beginPath();
                ctx.arc(x, y, pointRadius * 2.5 * gridRatio, 0, Math.PI * 2);
                
                // ÂâµÂª∫Êº∏ËÆä
                const gradient = ctx.createRadialGradient(
                    x, y, 0, 
                    x, y, pointRadius * 3 * gridRatio
                );
                gradient.addColorStop(0, 'rgba(100, 255, 218, 0.7)');
                gradient.addColorStop(1, 'rgba(100, 255, 218, 0)');
                
                ctx.fillStyle = gradient;
                ctx.fill();
                
                // Áç≤ÂèñCanvasÁõ∏Â∞çÊñºË¶ñÁ™óÁöÑ‰ΩçÁΩÆ
                const rect = canvas.getBoundingClientRect();
                
                // ÂâµÂª∫ÈñÉÁàçÁ≤íÂ≠êÊïàÊûú
                for (let i = 0; i < 15; i++) {
                    setTimeout(() => {
                        const angle = Math.random() * Math.PI * 2;
                        const distance = Math.random() * 30;
                        const px = rect.left + x + Math.cos(angle) * distance;
                        const py = rect.top + y + Math.sin(angle) * distance;
                        createParticle(px, py, 'rgba(100, 255, 218, 0.8)');
                    }, i * 100);
                }
            } else if (level.type === "quadrilateral") {
                // Â∞çÊñºÂõõÈÇäÂΩ¢ÔºåÈ°ØÁ§∫ÂÖ©ÂÄãËß£Èªû
                for (const solutionPoint of level.solutionPoints) {
                    const x = offsetX + solutionPoint.col * gridSize * gridRatio;
                    const y = offsetY + solutionPoint.row * gridSize * gridRatio;
                    
                    // Áπ™Ë£ΩÈñÉÁàçÊèêÁ§∫ÊïàÊûú
                    ctx.beginPath();
                    ctx.arc(x, y, pointRadius * 2.5 * gridRatio, 0, Math.PI * 2);
                    
                    // ÂâµÂª∫Êº∏ËÆä
                    const gradient = ctx.createRadialGradient(
                        x, y, 0, 
                        x, y, pointRadius * 3 * gridRatio
                    );
                    gradient.addColorStop(0, 'rgba(100, 255, 218, 0.7)');
                    gradient.addColorStop(1, 'rgba(100, 255, 218, 0)');
                    
                    ctx.fillStyle = gradient;
                    ctx.fill();
                    
                    // Áç≤ÂèñCanvasÁõ∏Â∞çÊñºË¶ñÁ™óÁöÑ‰ΩçÁΩÆ
                    const rect = canvas.getBoundingClientRect();
                    
                    // ÂâµÂª∫ÈñÉÁàçÁ≤íÂ≠êÊïàÊûú
                    for (let i = 0; i < 10; i++) {
                        setTimeout(() => {
                            const angle = Math.random() * Math.PI * 2;
                            const distance = Math.random() * 30;
                            const px = rect.left + x + Math.cos(angle) * distance;
                            const py = rect.top + y + Math.sin(angle) * distance;
                            createParticle(px, py, 'rgba(100, 255, 218, 0.8)');
                        }, i * 100);
                    }
                }
            }
            
            // 2ÁßíÂæåÊ∂àÂ§±
            setTimeout(() => drawGame(), 2000);
        }
        
        // È°ØÁ§∫ÊñáÂ≠óÊèêÁ§∫
        function toggleTextHint() {
            if (hintBox.style.display === 'none') {
                hintBox.style.display = 'block';
                playSound('hint');
                
                // Ê∑ªÂä†Ê∑°ÂÖ•ÊïàÊûú
                hintBox.style.opacity = 0;
                setTimeout(() => {
                    hintBox.style.transition = 'opacity 0.5s';
                    hintBox.style.opacity = 1;
                }, 10);
            } else {
                // Ê∑ªÂä†Ê∑°Âá∫ÊïàÊûú
                hintBox.style.transition = 'opacity 0.5s';
                hintBox.style.opacity = 0;
                
                setTimeout(() => {
                    hintBox.style.display = 'none';
                    hintBox.style.transition = '';
                }, 500);
            }
        }
        
        // ÂïüÂãïË®àÊôÇÂô®
        function startTimer() {
            updateTimerDisplay();
            
            timerInterval = setInterval(() => {
                timeLeft--;
                updateTimerDisplay();
                
                // ÈñÉÁàçÊïàÊûúÁï∂ÊôÇÈñìÂ∞ëÊñº10Áßí
                if (timeLeft <= 10 && timeLeft > 0) {
                    timerDisplay.classList.add('pulse-animation');
                    setTimeout(() => timerDisplay.classList.remove('pulse-animation'), 500);
                }
                
                if (timeLeft <= 0) {
                    endGame();
                }
            }, 1000);
        }
        
        // Êõ¥Êñ∞Ë®àÊôÇÂô®È°ØÁ§∫
        function updateTimerDisplay() {
            const minutes = Math.floor(timeLeft / 60);
            const seconds = timeLeft % 60;
            timerDisplay.textContent = `${minutes.toString().padStart(2, '0')}:${seconds.toString().padStart(2, '0')}`;
            
            // ÊôÇÈñìÂ∞ëÊñº10ÁßíÊôÇËÆäÁ¥Ö
            if (timeLeft <= 10) {
                timerDisplay.style.color = '#FF6464';
                timerDisplay.style.textShadow = '0 0 8px rgba(255, 100, 100, 0.7)';
            } else {
                timerDisplay.style.color = '#FFD700';
                timerDisplay.style.textShadow = '0 0 8px rgba(255, 215, 0, 0.5)';
            }
        }
        
        // ÁµêÊùüÈÅäÊà≤
        function endGame() {
            clearInterval(timerInterval);
            isGameActive = false;
            
            // Ê™¢Êü•‰∏¶Êõ¥Êñ∞ÊúÄÁµÇÊàêÂ∞±
            checkAchievements();
            
            // Êõ¥Êñ∞ÊàêÂ∞±È°ØÁ§∫
            updateAchievementDisplay();
            
            // Show result screen
            document.getElementById('finalScore').textContent = `${solvedCount} Constellations`;
            document.getElementById('finalTotalScore').textContent = score;
            resultScreen.style.display = 'flex';
            
            // ÂâµÂª∫ÊòüÈªûÁ≤íÂ≠êÊïàÊûú
            const numParticles = Math.min(100, solvedCount * 20);
            for (let i = 0; i < numParticles; i++) {
                setTimeout(() => {
                    const x = Math.random() * window.innerWidth;
                    const y = Math.random() * window.innerHeight * 0.7;
                    createParticle(x, y, `hsl(${Math.random() * 60 + 180}, 100%, 70%)`);
                }, i * 20);
            }
            
            // ÁÇ∫Â∑≤Ëß£ÈéñÁöÑÊàêÂ∞±Ê∑ªÂä†ÁâπÊïà
            if (newUnlocks.length > 0) {
                setTimeout(() => {
                    const achievementContainers = document.querySelectorAll('.achievement-badge.new-unlock');
                    achievementContainers.forEach((badge, index) => {
                        // ÁÇ∫ÊØèÂÄãÊñ∞Ëß£ÈéñÁöÑÊàêÂ∞±ÂâµÂª∫ÁôºÂÖâÊïàÊûú
                        setTimeout(() => {
                            // ÂâµÂª∫Á≤íÂ≠êÊïàÊûú
                            const rect = badge.getBoundingClientRect();
                            const centerX = rect.left + rect.width / 2;
                            const centerY = rect.top + rect.height / 2;
                            
                            for (let i = 0; i < 20; i++) {
                                setTimeout(() => {
                                    const angle = Math.random() * Math.PI * 2;
                                    const distance = Math.random() * 50 + 20;
                                    const x = centerX + Math.cos(angle) * distance;
                                    const y = centerY + Math.sin(angle) * distance;
                                    createParticle(x, y, '#FFD700');
                                }, i * 50);
                            }
                        }, index * 300);
                    });
                }, 500);
            }
            
            console.log("Game ended");
        }
        
        // Èö®Ê©üÈÅ∏ÊìáÈóúÂç°
        function loadRandomLevel() {
            // Ê†πÊìöÈÄ£ÂãùË™øÊï¥Èõ£Â∫¶
            let levelPool = levels;
            
            if (streak >= 5) {
                // ÂæûÈóúÂç°‰∏≠ÁØ©ÈÅ∏Âá∫Âõ∞Èõ£ÁöÑ
                const hardLevels = levels.filter(l => l.difficulty >= 3);
                if (hardLevels.length > 0) {
                    levelPool = hardLevels;
                    
                    if (currentDifficulty !== "Hard") {
                        currentDifficulty = "Hard";
                        difficultyDisplay.textContent = `Difficulty: ${currentDifficulty}`;
                    }
                }
            }
            
            // Á¢∫‰øù‰∏çÈáçË§á‰∏ä‰∏ÄÂÄãÈóúÂç°
            let newIndex;
            do {
                if (levelPool.length === 1) {
                    newIndex = 0; // Âè™Êúâ‰∏ÄÂÄãÈóúÂç°ÊôÇÁõ¥Êé•ÈÅ∏Êìá
                    break;
                }
                
                if (levelPool !== levels) {
                    // ÂæûÂõ∞Èõ£ÈóúÂç°‰∏≠ÈÅ∏Êìá
                    const hardIndex = Math.floor(Math.random() * levelPool.length);
                    // ÊâæÂà∞Âú®ÂéüÂßãÈóúÂç°Èô£Âàó‰∏≠ÁöÑÁ¥¢Âºï
                    newIndex = levels.findIndex(level => 
                        level.name === levelPool[hardIndex].name && 
                        level.presetLine.from.row === levelPool[hardIndex].presetLine.from.row &&
                        level.presetLine.from.col === levelPool[hardIndex].presetLine.from.col
                    );
                } else {
                    // ÂæûÊâÄÊúâÈóúÂç°‰∏≠ÈÅ∏Êìá
                    newIndex = Math.floor(Math.random() * levels.length);
                }
            } while (newIndex === currentLevelIndex && levels.length > 1);
            
            currentLevelIndex = newIndex;
            loadLevel(currentLevelIndex);
        }
        
        // Ë™øÊï¥CanvasÂ§ßÂ∞è
        function resizeCanvas() {
            // Áç≤ÂèñÂÆπÂô®Â§ßÂ∞è
            const containerWidth = Math.min(450, window.innerWidth - 40);
            canvas.width = containerWidth;
            canvas.height = containerWidth;
            canvas.style.width = containerWidth + 'px';
            canvas.style.height = containerWidth + 'px';
            
            drawGame();
        }
        
        // ËºâÂÖ•ÈóúÂç°
        function loadLevel(index) {
            // Ê∏ÖÈô§ÊâÄÊúâÊïàÊûú
            clearEffects();
            
            currentLevelIndex = index;
            
            if (!levels[currentLevelIndex]) {
                console.error("ÈóúÂç°ËºâÂÖ•ÈåØË™§ÔºöÊâæ‰∏çÂà∞ÈóúÂç°", index);
                if (levels.length > 0) {
                    currentLevelIndex = 0;
                } else {
                    console.error("Ê≤íÊúâÂèØÁî®ÈóúÂç°ÔºÅ");
                    return;
                }
            }
            
            const level = levels[currentLevelIndex];
            
            if (debugMode) {
                console.log(`ËºâÂÖ•ÈóúÂç°: ${level.name} (Á¥¢Âºï: ${currentLevelIndex})`);
                console.log(`ÈóúÂç°È°ûÂûã: ${level.type}`);
            }
            
            // Update UI
            document.getElementById('task').textContent = level.description;
            const requiredLines = level.requiredLines || 2; // Default triangles is 2 lines, quadrilaterals is 3 lines
            document.getElementById('status').textContent = `Connected: 0 lines (need to connect ${requiredLines} lines)`;
            hintBox.style.display = 'none';
            hintBox.textContent = level.hint;
            
            // Èö±ËóèÁµêÊûúË®äÊÅØ
            resultMessage.style.display = 'none';
            
            // ÈáçÁΩÆÈÅäÊà≤ÁãÄÊÖã
            userLines = [];
            selectedPoint = null;
            isComplete = false;
            
            // Áπ™Ë£ΩÈÅäÊà≤
            drawGame();
            
            // ÈáçÂïüÂãïÁï´Âæ™Áí∞ÔºàÂ¶ÇÊûúÈÇÑÊ≤íÂïüÂãïÔºâ
            if (!animationFrameId) {
                animate();
            }
        }
        
        // Áπ™Ë£ΩÈÅäÊà≤
        function drawGame() {
            // Ê∏ÖÈô§Áï´Â∏É
            ctx.clearRect(0, 0, canvas.width, canvas.height);
            
            // Áπ™Ë£ΩËÉåÊôØ
            const gradient = ctx.createLinearGradient(0, 0, 0, canvas.height);
            gradient.addColorStop(0, '#0B0E2E');
            gradient.addColorStop(1, '#1A1B4B');
            ctx.fillStyle = gradient;
            ctx.fillRect(0, 0, canvas.width, canvas.height);
            
            // Áπ™Ë£ΩËÉåÊôØÊòüÊòü - Â∞èÈªû
            ctx.fillStyle = 'rgba(255, 255, 255, 0.5)';
            
            // Èö®Ê©üÁ®ÆÂ≠êÔºå‰ΩøÊòüÊòü‰ΩçÁΩÆ‰øùÊåÅ‰∏ÄËá¥
            const levelSeed = currentLevelIndex * 10000;
            const pseudoRandom = (seed) => {
                return ((seed * 9301 + 49297) % 233280) / 233280;
            };
            
            // Áπ™Ë£ΩÂ∞èÂûãÊòüÊòü
            for (let i = 0; i < 50; i++) {
                const seed = levelSeed + i;
                const x = pseudoRandom(seed) * canvas.width;
                const y = pseudoRandom(seed + 1) * canvas.height;
                const size = pseudoRandom(seed + 2) * 1.5;
                
                ctx.beginPath();
                ctx.arc(x, y, size, 0, Math.PI * 2);
                ctx.fill();
            }
            
            // Áπ™Ë£ΩÊòüÈõ≤ÊïàÊûú
            ctx.save();
            for (let i = 0; i < 3; i++) {
                const seed = levelSeed + i * 1000;
                const x = pseudoRandom(seed) * canvas.width;
                const y = pseudoRandom(seed + 1) * canvas.height;
                const radius = 50 + pseudoRandom(seed + 2) * 100;
                
                const nebulaGradient = ctx.createRadialGradient(x, y, 0, x, y, radius);
                nebulaGradient.addColorStop(0, `rgba(${50 + i * 20}, ${80 + i * 10}, ${150 + i * 20}, 0.03)`);
                nebulaGradient.addColorStop(0.5, `rgba(${40 + i * 20}, ${60 + i * 10}, ${120 + i * 20}, 0.02)`);
                nebulaGradient.addColorStop(1, 'rgba(20, 30, 80, 0)');
                
                ctx.fillStyle = nebulaGradient;
                ctx.beginPath();
                ctx.arc(x, y, radius, 0, Math.PI * 2);
                ctx.fill();
            }
            ctx.restore();
            
            // Ë®àÁÆóÁ∂≤Ê†ºÂ∞∫ÂØ∏ÊØî‰æã
            const gridRatio = (canvas.width - 2 * offsetX) / (numCols * gridSize);
            
            // Áπ™Ë£ΩÁ∂≤Ê†ºÁ∑öÔºàÊ∑°Ôºâ
            ctx.strokeStyle = 'rgba(255, 255, 255, 0.05)';
            ctx.lineWidth = 1;
            
            // ÂûÇÁõ¥Á∑ö
            for (let col = 0; col <= numCols; col++) {
                const x = offsetX + col * gridSize * gridRatio;
                ctx.beginPath();
                ctx.moveTo(x, offsetY);
                ctx.lineTo(x, offsetY + numRows * gridSize * gridRatio);
                ctx.stroke();
            }
            
            // Ê∞¥Âπ≥Á∑ö
            for (let row = 0; row <= numRows; row++) {
                const y = offsetY + row * gridSize * gridRatio;
                ctx.beginPath();
                ctx.moveTo(offsetX, y);
                ctx.lineTo(offsetX + numCols * gridSize * gridRatio, y);
                ctx.stroke();
            }
            
            // È†êË®≠Á∑ö
            if (!levels[currentLevelIndex]) return; // ÈÅøÂÖçÂàùÂßãÂåñÂïèÈ°å
            
            const level = levels[currentLevelIndex];
            const presetLine = level.presetLine;
            
            // ËΩâÊèõÈ†êË®≠Á∑öÁöÑÂ∫ßÊ®ô
            const fromX = offsetX + presetLine.from.col * gridSize * gridRatio;
            const fromY = offsetY + presetLine.from.row * gridSize * gridRatio;
            const toX = offsetX + presetLine.to.col * gridSize * gridRatio;
            const toY = offsetY + presetLine.to.row * gridSize * gridRatio;
            
            // Áπ™Ë£ΩÈ†êË®≠Á∑ö
            ctx.beginPath();
            ctx.moveTo(fromX, fromY);
            ctx.lineTo(toX, toY);
            
            // ‰ΩøÁî®Êº∏ËÆä
            const lineGradient = ctx.createLinearGradient(fromX, fromY, toX, toY);
            lineGradient.addColorStop(0, '#8A9EFF');
            lineGradient.addColorStop(0.5, '#ADC2FF');
            lineGradient.addColorStop(1, '#8A9EFF');
            
            ctx.strokeStyle = lineGradient;
            ctx.lineWidth = 3;
            ctx.stroke();
            
            // Ê∑ªÂä†ÁôºÂÖâÊïàÊûú
            ctx.shadowColor = 'rgba(138, 158, 255, 0.5)';
            ctx.shadowBlur = 10;
            
            ctx.beginPath();
            ctx.moveTo(fromX, fromY);
            ctx.lineTo(toX, toY);
            ctx.stroke();
            
            // ÁßªÈô§Èô∞ÂΩ±‰ª•Èò≤ÂΩ±ÈüøÂÖ∂‰ªñÁπ™Ë£Ω
            ctx.shadowColor = 'transparent';
            ctx.shadowBlur = 0;
            
            // Áπ™Ë£ΩÁî®Êà∂ÈÄ£Êé•ÁöÑÁ∑öÊ¢ù
            for (const line of userLines) {
                const fromX = offsetX + line.from.col * gridSize * gridRatio;
                const fromY = offsetY + line.from.row * gridSize * gridRatio;
                const toX = offsetX + line.to.col * gridSize * gridRatio;
                const toY = offsetY + line.to.row * gridSize * gridRatio;
                
                // Ë®àÁÆóÁ∑öÁöÑÊº∏ËÆä
                const lineGradient = ctx.createLinearGradient(fromX, fromY, toX, toY);
                lineGradient.addColorStop(0, '#64FFDA');
                lineGradient.addColorStop(0.5, '#A0FFE6');
                lineGradient.addColorStop(1, '#64FFDA');
                
                // ÁôºÂÖâÊïàÊûú
                ctx.shadowColor = 'rgba(100, 255, 218, 0.5)';
                ctx.shadowBlur = 10;
                
                ctx.beginPath();
                ctx.moveTo(fromX, fromY);
                ctx.lineTo(toX, toY);
                ctx.strokeStyle = lineGradient;
                ctx.lineWidth = 3;
                ctx.stroke();
                
                // ÁßªÈô§Èô∞ÂΩ±
                ctx.shadowBlur = 0;
                ctx.shadowColor = 'transparent';
            }
            
            // Áπ™Ë£ΩÁï∂ÂâçÊãñÂãïÁöÑÁ∑ö
            if (selectedPoint !== null) {
                const fromX = offsetX + selectedPoint.col * gridSize * gridRatio;
                const fromY = offsetY + selectedPoint.row * gridSize * gridRatio;
                
                // Êº∏ËÆäÈ°èËâ≤ÁöÑËôõÁ∑ö
                const dashLineGradient = ctx.createLinearGradient(fromX, fromY, lastMouseX, lastMouseY);
                dashLineGradient.addColorStop(0, 'rgba(255, 255, 255, 0.8)');
                dashLineGradient.addColorStop(1, 'rgba(255, 255, 255, 0.1)');
                
                ctx.beginPath();
                ctx.moveTo(fromX, fromY);
                ctx.lineTo(lastMouseX, lastMouseY);
                ctx.strokeStyle = dashLineGradient;
                ctx.lineWidth = 2;
                ctx.setLineDash([5, 5]); // ËôõÁ∑öÊïàÊûú
                ctx.stroke();
                ctx.setLineDash([]); // ÈáçÁΩÆÁÇ∫ÂØ¶Á∑ö
            }
            
            // ÂâµÂª∫ÊòüÊòüÊò†Â∞ÑÔºåÈÅøÂÖçÈáçË§áÂâµÂª∫
            const starMap = new Map();
            
            // Ê∏ÖÈô§ÁèæÊúâÁöÑDOMÊòüÊòü
            clearEffects();
            
            // ÂàùÂßãÂåñÊòüÊòüÈô£Âàó
            stars = [];
            
            // Áπ™Ë£ΩÊâÄÊúâÁ∂≤Ê†ºÈªû
            for (let row = 0; row <= numRows; row++) {
                for (let col = 0; col <= numCols; col++) {
                    const x = offsetX + col * gridSize * gridRatio;
                    const y = offsetY + row * gridSize * gridRatio;
                    
                    // Á¢∫ÂÆöÈªûÁöÑÈ°èËâ≤ÂíåÂ§ßÂ∞èÔºàÈ†êË®≠Á∑öÁ´ØÈªû„ÄÅÁî®Êà∂Á∑öÁ´ØÈªû„ÄÅÊôÆÈÄöÈªûÔºâ
                    let isSpecialPoint = false;
                    
                    // Ê™¢Êü•ÊòØÂê¶ÁÇ∫È†êË®≠Á∑öÁ´ØÈªû
                    if ((row === presetLine.from.row && col === presetLine.from.col) ||
                        (row === presetLine.to.row && col === presetLine.to.col)) {
                        isSpecialPoint = true;
                    }
                    
                    // Ê™¢Êü•ÊòØÂê¶ÁÇ∫Áî®Êà∂Á∑öÁ´ØÈªû
                    for (const line of userLines) {
                        if ((row === line.from.row && col === line.from.col) ||
                            (row === line.to.row && col === line.to.col)) {
                            isSpecialPoint = true;
                            break;
                        }
                    }
                    
                    // Ê™¢Êü•ÊòØÂê¶ÁÇ∫ÈÅ∏‰∏≠ÊàñÊá∏ÂÅúÁöÑÈªû
                    const isSelected = selectedPoint && row === selectedPoint.row && col === selectedPoint.col;
                    const isHovered = hoveredPoint && row === hoveredPoint.row && col === hoveredPoint.col;
                    
                    // Ê±∫ÂÆöÈªûÁöÑÁπ™Ë£ΩÊñπÂºè
                    if (isSpecialPoint || isSelected || isHovered) {
                        // ÊòüÈªûÈñÉÁàçÊïàÊûú
                        const pulseSize = (Math.sin(Date.now() / 300) * 0.2 + 1);
                        
                        // ÁôºÂÖâÊïàÊûú
                        ctx.beginPath();
                        ctx.arc(x, y, pointRadius * 2 * gridRatio * pulseSize, 0, Math.PI * 2);
                        const gradient = ctx.createRadialGradient(
                            x, y, 0,
                            x, y, pointRadius * 2 * gridRatio * pulseSize
                        );
                        gradient.addColorStop(0, 'rgba(255, 215, 0, 0.8)');
                        gradient.addColorStop(1, 'rgba(255, 215, 0, 0)');
                        ctx.fillStyle = gradient;
                        ctx.fill();
                        
                        // ‰∏ªÊòüÈªû
                        ctx.beginPath();
                        ctx.arc(x, y, pointRadius * gridRatio * pulseSize, 0, Math.PI * 2);
                        ctx.fillStyle = '#FFD700';
                        ctx.fill();
                        
                        // Ê∑ªÂä†ÊòüÂÖâÊïàÊûú
                        ctx.beginPath();
                        ctx.arc(x, y, pointRadius * 0.8 * gridRatio * pulseSize, 0, Math.PI * 2);
                        ctx.fillStyle = '#FFFFFF';
                        ctx.fill();
                        
                        // Áç≤ÂèñCanvasÁõ∏Â∞çÊñºË¶ñÁ™óÁöÑ‰ΩçÁΩÆ
                        const rect = canvas.getBoundingClientRect();
                        
                        // Âú®DOM‰∏≠ÂâµÂª∫ÊòüÂÖâÊïàÊûú
                        if (!starMap.has(`${row},${col}`)) {
                            const star = createStar(
                                rect.left + x, 
                                rect.top + y, 
                                pointRadius * 1.5 * gridRatio
                            );
                            stars.push(star);
                            starMap.set(`${row},${col}`, star);
                        }
                    } else {
                        // ÊôÆÈÄöÈªû
                        ctx.beginPath();
                        ctx.arc(x, y, pointRadius * 0.7 * gridRatio, 0, Math.PI * 2);
                        ctx.fillStyle = 'rgba(255, 255, 255, 0.4)';
                        ctx.fill();
                    }
                    
                    // ÈÅ∏‰∏≠ÊàñÊá∏ÂÅúÁöÑÈªûÈ´ò‰∫Æ
                    if (isSelected || isHovered) {
                        ctx.beginPath();
                        ctx.arc(x, y, pointRadius * 1.2 * gridRatio, 0, Math.PI * 2);
                        ctx.strokeStyle = isSelected ? '#ffffff' : 'rgba(255, 255, 255, 0.7)';
                        ctx.lineWidth = 2;
                        ctx.stroke();
                    }
                }
            }
            
            // Êõ¥Êñ∞ÁãÄÊÖã
            const requiredLines = levels[currentLevelIndex].requiredLines || 2;
            document.getElementById('status').textContent = `Connected: ${userLines.length} lines (need to connect ${requiredLines} lines)`;
        }
        
        // Êü•ÊâæÈªûÊìä‰ΩçÁΩÆÁöÑÁ∂≤Ê†ºÈªû
        function findGridPoint(x, y) {
            const gridRatio = (canvas.width - 2 * offsetX) / (numCols * gridSize);
            
            for (let row = 0; row <= numRows; row++) {
                for (let col = 0; col <= numCols; col++) {
                    const pointX = offsetX + col * gridSize * gridRatio;
                    const pointY = offsetY + row * gridSize * gridRatio;
                    
                    const distance = Math.sqrt(
                        Math.pow(x - pointX, 2) + Math.pow(y - pointY, 2)
                    );
                    
                    if (distance <= pointRadius * 2 * gridRatio) {
                        return { row, col };
                    }
                }
            }
            
            return null;
        }
        
        // Ê™¢Êü•ÊòØÂê¶ÂèØ‰ª•ÈÄ£Êé•ÂÖ©ÂÄãÈªû
        function canConnectPoints(fromPoint, toPoint) {
            // Ê™¢Êü•ÊòØÂê¶Â∑≤Á∂ìÈÄ£Êé•
            for (const line of userLines) {
                if ((line.from.row === fromPoint.row && line.from.col === fromPoint.col &&
                     line.to.row === toPoint.row && line.to.col === toPoint.col) ||
                    (line.from.row === toPoint.row && line.from.col === toPoint.col &&
                     line.to.row === fromPoint.row && line.to.col === fromPoint.col)) {
                    return false;
                }
            }
            
            // Ê™¢Êü•ÊòØÂê¶ËàáÈ†êË®≠Á∑öÈáçË§á
            const presetLine = levels[currentLevelIndex].presetLine;
            if ((fromPoint.row === presetLine.from.row && fromPoint.col === presetLine.from.col &&
                 toPoint.row === presetLine.to.row && toPoint.col === presetLine.to.col) ||
                (fromPoint.row === presetLine.to.row && fromPoint.col === presetLine.to.col &&
                 toPoint.row === presetLine.from.row && toPoint.col === presetLine.from.col)) {
                return false;
            }
            
            return true;
        }
        
        // Update score display
        function updateScoreDisplay() {
            document.getElementById('scoreDisplay').textContent = `Score: ${score}`;
            document.getElementById('streakDisplay').textContent = `Streak: ${streak}`;
            document.getElementById('solvedDisplay').textContent = `Solved: ${solvedCount}`;
        }
        
        // Âä†ÂàÜ
        function addPoints(points) {
            const scoreDisplay = document.getElementById('scoreDisplay');
            
            // Ë®òÈåÑÂéüÂßãÂàÜÊï∏
            const oldScore = score;
            
            // Â¢ûÂä†ÂàÜÊï∏
            score += points;
            
            // Êõ¥Êñ∞ÂàÜÊï∏È°ØÁ§∫
            updateScoreDisplay();
            
            // Ê∑ªÂä†Ë¶ñË¶∫ÊïàÊûú
            scoreDisplay.classList.add('pulse-animation');
            setTimeout(() => {
                scoreDisplay.classList.remove('pulse-animation');
            }, 500);
            
            return score - oldScore; // ËøîÂõûÂ¢ûÂä†ÁöÑÂàÜÊï∏
        }
        
        // Ê™¢Êü•ÂΩ¢ÁãÄ
        function checkShape() {
            if (!isGameActive) return;
            
            const level = levels[currentLevelIndex];
            const requiredLines = level.requiredLines || 2; // È†êË®≠ÁÇ∫‰∏âËßíÂΩ¢(2Ê¢ùÁ∑ö)
            
            // Check connected line count
            if (userLines.length !== requiredLines) {
                showResultMessage(`You need to connect exactly ${requiredLines} lines to complete the ${level.name} constellation!`, false);
                playSound('wrong');
                return;
            }
            
            const result = level.checkFunction();
            
            if (result) {
                handleCorrectShape(level);
            } else {
                // Â§±Êïó - ÈáçÁΩÆÈÄ£Âãù
                streak = 0;
                updateScoreDisplay();
                
                // Êí≠ÊîæÈåØË™§Èü≥Êïà
                playSound('wrong');
                
                // Show failure message
                showResultMessage("Not quite the correct " + level.name + " constellation! Please try again.", false);
            }
        }
        
        // ËôïÁêÜÊ≠£Á¢∫ÁöÑÂΩ¢ÁãÄ
        function handleCorrectShape(level) {
            // ÂÆåÊàêÔºÅ
            isComplete = true;
            
            // Êí≠ÊîæÊ≠£Á¢∫Èü≥Êïà
            playSound('correct');
            
            // Â¢ûÂä†ÈÄ£Âãù
            streak++;
            
            // Â¢ûÂä†Â∑≤Ëß£È°åÊï∏
            solvedCount++;
            
            // Ë®àÁÆóÂàÜÊï∏ - Âü∫ÊñºÈõ£Â∫¶ÂíåÈÄ£Âãù
            const basePoints = level.difficulty * 10;
            const streakBonus = streak > 1 ? streak * 5 : 0;
            const totalPoints = basePoints + streakBonus;
            
            // Âä†ÂàÜ
            const pointsAdded = addPoints(totalPoints);
            
            // Êõ¥Êñ∞ÁãÄÊÖãÂíåÈ°ØÁ§∫
            const statusText = `${level.congratsMessage} +${pointsAdded} points`;
            showResultMessage(statusText, true);
            
            // Ê™¢Êü•ÊòØÂê¶Ëß£ÈéñÊñ∞ÊàêÂ∞±
            checkAchievements();
            
            // ÂâµÂª∫ÊòüÈªûÈÄ£Êé•ÁâπÊïà
            createConnectionEffects();
            
            // Êº∏ËÆäÂÖâËäíÊïàÊûú
            const rect = canvas.getBoundingClientRect();
            ctx.fillStyle = 'rgba(255, 255, 255, 0.1)';
            ctx.fillRect(0, 0, canvas.width, canvas.height);
            
            // ÂâµÂª∫ÂÆåÊàêÁ≤íÂ≠êÊïàÊûú
            const centerX = rect.left + canvas.width / 2;
            const centerY = rect.top + canvas.height / 2;
            
            for (let i = 0; i < 40; i++) {
                setTimeout(() => {
                    const angle = Math.random() * Math.PI * 2;
                    const distance = Math.random() * canvas.width * 0.5;
                    const x = centerX + Math.cos(angle) * distance;
                    const y = centerY + Math.sin(angle) * distance;
                    createParticle(x, y, `rgba(${Math.random() * 100 + 155}, ${Math.random() * 100 + 155}, 255, 0.8)`);
                }, i * 50);
            }
            
            // 1.5ÁßíÂæåËá™ÂãïÈÄ≤ÂÖ•‰∏ã‰∏ÄÈ°å
            setTimeout(() => {
                if (isGameActive) {
                    loadRandomLevel();
                }
            }, 1500);
        }
        
        // Ê™¢Êü•ÊòØÂê¶Ëß£ÈéñÊàêÂ∞±
        function checkAchievements() {
            // Ê™¢Êü•ÊØèÂÄãÊàêÂ∞±ÁöÑËß£ÈéñÊ¢ù‰ª∂
            for (let i = 0; i < achievements.length; i++) {
                const achievement = achievements[i];
                
                if (!achievement.unlocked && solvedCount >= achievement.level) {
                    // Ëß£ÈéñÊàêÂ∞±
                    achievement.unlocked = true;
                    
                    // Ê∑ªÂä†Âà∞Êñ∞Ëß£ÈéñÂàóË°®
                    newUnlocks.push(achievement);
                    
                    // È°ØÁ§∫ÈÄöÁü•
                    setTimeout(() => {
                        showAchievementPopup(achievement);
                    }, 100 + i * 400); // Âø´ÈÄüÈüøÊáâÔºåÂ¶ÇÊûúÈÄ£Á∫åËß£ÈéñÂ§öÂÄãÊàêÂ∞±ÔºåÂàÜÈñãÊôÇÈñìÈ°ØÁ§∫
                }
            }
        }
        
        // È°ØÁ§∫ÊàêÂ∞±Ëß£ÈéñÂΩàÁ™ó
        function showAchievementPopup(achievement) {
            const popup = document.getElementById('achievementPopup');
            const iconEl = popup.querySelector('.achievement-icon-large');
            const titleEl = popup.querySelector('.achievement-popup-title');
            const descEl = popup.querySelector('.achievement-popup-desc');
            
            // Ë®≠ÁΩÆÂÖßÂÆπ
            iconEl.textContent = achievement.icon;
            titleEl.textContent = `Achievement Unlocked: ${achievement.name}`;
            descEl.textContent = achievement.description;
            
            // È°ØÁ§∫ÂΩàÁ™ó
            popup.classList.add('show');
            
            // Êí≠ÊîæËß£ÈéñÊàêÂ∞±Èü≥Êïà
            playAchievementSound();
            
            // 2ÁßíÂæåÈö±Ëóè (Á∏ÆÁü≠È°ØÁ§∫ÊôÇÈñì)
            setTimeout(() => {
                popup.classList.remove('show');
            }, 2000);
        }
        
        // Êí≠ÊîæÊàêÂ∞±Ëß£ÈéñÈü≥Êïà
        function playAchievementSound() {
            if (!audioContext || !soundToggle.checked) return;
            
            try {
                // ÁâπÊÆäÁöÑÊàêÂ∞±Ëß£ÈéñÈü≥Êïà - Âçé‰∏ΩÁöÑ‰∏äÂçáÈü≥
                const oscillator1 = audioContext.createOscillator();
                const oscillator2 = audioContext.createOscillator();
                const gainNode = audioContext.createGain();
                
                oscillator1.type = 'sine';
                oscillator2.type = 'triangle';
                
                oscillator1.connect(gainNode);
                oscillator2.connect(gainNode);
                gainNode.connect(audioContext.destination);
                
                // Á¨¨‰∏ÄÂÄãÈü≥Ë™øËªåË∑°
                oscillator1.frequency.setValueAtTime(523.25, audioContext.currentTime); // C5
                oscillator1.frequency.linearRampToValueAtTime(783.99, audioContext.currentTime + 0.2); // G5
                oscillator1.frequency.linearRampToValueAtTime(1046.50, audioContext.currentTime + 0.4); // C6
                
                // Á¨¨‰∫åÂÄãÈü≥Ë™øËªåË∑° (Á®çÂæÆÂª∂ÈÅ≤ÔºåÊ∑ªÂä†ÂíåËÅ≤ÊïàÊûú)
                oscillator2.frequency.setValueAtTime(659.25, audioContext.currentTime + 0.05); // E5
                oscillator2.frequency.linearRampToValueAtTime(987.77, audioContext.currentTime + 0.25); // B5
                oscillator2.frequency.linearRampToValueAtTime(1318.51, audioContext.currentTime + 0.45); // E6
                
                // Êº∏ËÆäÈü≥Èáè
                gainNode.gain.setValueAtTime(0, audioContext.currentTime);
                gainNode.gain.linearRampToValueAtTime(0.3, audioContext.currentTime + 0.1);
                gainNode.gain.exponentialRampToValueAtTime(0.01, audioContext.currentTime + 0.8);
                
                oscillator1.start();
                oscillator2.start();
                oscillator1.stop(audioContext.currentTime + 0.8);
                oscillator2.stop(audioContext.currentTime + 0.8);
            } catch(e) {
                console.warn('Error playing achievement sound:', e);
            }
        }
        
        // Êõ¥Êñ∞ÊàêÂ∞±È°ØÁ§∫
        function updateAchievementDisplay() {
            const container = document.getElementById('achievementsContainer');
            container.innerHTML = '';
            
            // ÂÖàÊ∑ªÂä†ÊâÄÊúâËß£ÈéñÁöÑÊàêÂ∞±
            for (const achievement of achievements) {
                const badge = document.createElement('div');
                badge.className = 'achievement-badge' + (achievement.unlocked ? ' unlocked' : ' locked');
                
                // Ê™¢Êü•ÊòØÂê¶ÁÇ∫Êú¨Ê¨°ÈÅäÊà≤Êñ∞Ëß£Èéñ
                if (newUnlocks.includes(achievement)) {
                    badge.classList.add('new-unlock');
                }
                
                const icon = document.createElement('span');
                icon.className = 'icon';
                icon.textContent = achievement.icon;
                
                const tooltip = document.createElement('div');
                tooltip.className = 'achievement-tooltip';
                tooltip.textContent = achievement.unlocked 
                    ? `${achievement.name}: ${achievement.description}` 
                    : `????: Complete ${achievement.level} constellations to unlock`;
                
                badge.appendChild(icon);
                badge.appendChild(tooltip);
                container.appendChild(badge);
            }
        }
        
        // ÂâµÂª∫ÈÄ£Êé•ÁâπÊïà
        function createConnectionEffects() {
            // Áç≤ÂèñCanvas‰ΩçÁΩÆ
            const rect = canvas.getBoundingClientRect();
            const gridRatio = (canvas.width - 2 * offsetX) / (numCols * gridSize);
            
            // È†êË®≠Á∑öÁöÑÂÖ©ÂÄãÁ´ØÈªû
            const presetLine = levels[currentLevelIndex].presetLine;
            const p1 = {
                x: rect.left + offsetX + presetLine.from.col * gridSize * gridRatio,
                y: rect.top + offsetY + presetLine.from.row * gridSize * gridRatio
            };
            const p2 = {
                x: rect.left + offsetX + presetLine.to.col * gridSize * gridRatio,
                y: rect.top + offsetY + presetLine.to.row * gridSize * gridRatio
            };
            
            // ÂâµÂª∫È†êË®≠Á∑öÁöÑÈÄ£Êé•ÊïàÊûú
            createConstellationLine(p1.x, p1.y, p2.x, p2.y);
            
            // ÂâµÂª∫Áî®Êà∂Á∑öÁöÑÈÄ£Êé•ÊïàÊûú
            for (const line of userLines) {
                const fromX = rect.left + offsetX + line.from.col * gridSize * gridRatio;
                const fromY = rect.top + offsetY + line.from.row * gridSize * gridRatio;
                const toX = rect.left + offsetX + line.to.col * gridSize * gridRatio;
                const toY = rect.top + offsetY + line.to.row * gridSize * gridRatio;
                
                createConstellationLine(fromX, fromY, toX, toY);
            }
        }
        
        // È°ØÁ§∫ÁµêÊûúÊ∂àÊÅØ
        function showResultMessage(message, isSuccess) {
            resultMessage.textContent = message;
            resultMessage.style.display = 'block';
            
            // Ë®≠ÁΩÆÊ®£Âºè
            resultMessage.className = isSuccess ? 
                'result-message result-success' : 
                'result-message result-fail';
                
            // ÊïàÊûú
            resultMessage.classList.add('pulse-animation');
            setTimeout(() => {
                resultMessage.classList.remove('pulse-animation');
            }, 500);
            
            // Ê∑ªÂä†Ê∑°ÂÖ•ÊïàÊûú
            resultMessage.style.opacity = 0;
            setTimeout(() => {
                resultMessage.style.transition = 'opacity 0.3s';
                resultMessage.style.opacity = 1;
            }, 10);
        }
        
        // ÈáçÁΩÆÁ∑öÊ¢ù
        function resetLines() {
            userLines = [];
            selectedPoint = null;
            isComplete = false;
            
            const requiredLines = levels[currentLevelIndex].requiredLines || 2;
            document.getElementById('status').textContent = `Connected: 0 lines (need to connect ${requiredLines} lines)`;
            
            // Èö±ËóèÁµêÊûúË®äÊÅØ
            resultMessage.style.display = 'none';
            
            // Êí≠ÊîæÈªûÊìäÈü≥Êïà
            playSound('click');
            
            // Ê∏ÖÈô§ÊïàÊûú
            clearEffects();
            
            drawGame();
        }
        
        // Áç≤ÂèñÈªûÈõÜÂêàÔºàÂåÖÊã¨È†êË®≠Á∑öÁ´ØÈªûÂíåÁî®Êà∂ÈÄ£Á∑öÁ´ØÈªûÔºâ
        function getShapePoints() {
            const level = levels[currentLevelIndex];
            const requiredLines = level.requiredLines || 2;
            
            if (userLines.length !== requiredLines) return null;
            
            const presetLine = level.presetLine;
            const points = new Set();
            
            // Ê∑ªÂä†È†êË®≠Á∑öÁöÑÂÖ©ÂÄãÁ´ØÈªû
            points.add(JSON.stringify(presetLine.from));
            points.add(JSON.stringify(presetLine.to));
            
            // Ê∑ªÂä†Áî®Êà∂ÈÄ£Á∑öÁöÑÊâÄÊúâÈªû
            for (const line of userLines) {
                points.add(JSON.stringify(line.from));
                points.add(JSON.stringify(line.to));
            }
            
            // ËΩâÊèõÂõûÂ∞çË±°Ê†ºÂºè
            const shapePoints = Array.from(points).map(p => JSON.parse(p));
            
            // ‰∏âËßíÂΩ¢ÈúÄË¶Å3ÂÄãÈªûÔºåÂõõÈÇäÂΩ¢ÈúÄË¶Å4ÂÄãÈªû
            const expectedPointCount = level.type === "triangle" ? 3 : 4;
            
            if (shapePoints.length !== expectedPointCount) {
                if (debugMode) {
                    console.warn(`ÈªûÊï∏Èáè‰∏çÁ¨¶: ÊúüÊúõ${expectedPointCount}ÂÄãÈªû, ÂØ¶Èöõ${shapePoints.length}ÂÄãÈªû`);
                }
                return null;
            }
            
            return shapePoints;
        }
        
        // Áç≤Âèñ‰∏âËßíÂΩ¢ÁöÑ‰∏âÂÄãÈªû
        function getTrianglePoints() {
            if (userLines.length !== 2) return null;
            
            const presetLine = levels[currentLevelIndex].presetLine;
            const presetPoints = [presetLine.from, presetLine.to];
            
            // ÊâæÂá∫Á¨¨‰∏âÂÄãÈªûÔºà‰∏çÂú®È†êË®≠Á∑ö‰∏äÁöÑÈªûÔºâ
            let thirdPoint = null;
            
            for (const line of userLines) {
                if (!isPointInArray(line.from, presetPoints)) {
                    thirdPoint = line.from;
                    break;
                }
                if (!isPointInArray(line.to, presetPoints)) {
                    thirdPoint = line.to;
                    break;
                }
            }
            
            if (!thirdPoint) return null;
            
            return {
                p1: presetLine.from,
                p2: presetLine.to,
                p3: thirdPoint
            };
        }
        
        // Áç≤ÂèñÂõõÈÇäÂΩ¢ÁöÑÂõõÂÄãÈªûÔºàÊåâÁÖßÈ†ÜÊôÇÈáùÊàñÈÄÜÊôÇÈáùÈ†ÜÂ∫èÔºâ
        function getQuadrilateralPoints() {
            const points = getShapePoints();
            if (!points || points.length !== 4) return null;
            
            // ÊâæÂá∫‰∏≠ÂøÉÈªû
            const centerX = points.reduce((sum, p) => sum + p.col, 0) / 4;
            const centerY = points.reduce((sum, p) => sum + p.row, 0) / 4;
            
            // ÊåâÁÖßËßíÂ∫¶ÊéíÂ∫èÔºàÈ†ÜÊôÇÈáùÊàñÈÄÜÊôÇÈáùÈÉΩÂèØ‰ª•Ôºâ
            points.sort((a, b) => {
                const angleA = Math.atan2(a.row - centerY, a.col - centerX);
                const angleB = Math.atan2(b.row - centerY, b.col - centerX);
                return angleA - angleB;
            });
            
            if (debugMode) {
                console.log("ÊéíÂ∫èÂæåÁöÑÂõõÈÇäÂΩ¢È†ÇÈªû:", 
                    points.map(p => `(${p.row},${p.col})`).join(' -> '));
            }
            
            // ËøîÂõûÊéíÂ∫èÂæåÁöÑÂõõÂÄãÈªû
            return {
                p1: points[0],
                p2: points[1],
                p3: points[2],
                p4: points[3]
            };
        }
        
        // Ê™¢Êü•ÈªûÊòØÂê¶Âú®Êï∏ÁµÑ‰∏≠
        function isPointInArray(point, pointArray) {
            return pointArray.some(p => p.row === point.row && p.col === point.col);
        }
        
        // Ë®àÁÆóÂÖ©Èªû‰πãÈñìÁöÑË∑ùÈõ¢
        function calculateDistance(p1, p2) {
            return Math.sqrt(
                Math.pow((p1.col - p2.col), 2) + 
                Math.pow((p1.row - p2.row), 2)
            );
        }
        
        // Ë®àÁÆóÊñúÁéá
        function calculateSlope(p1, p2) {
            // ÈÅøÂÖçÈô§‰ª•Èõ∂ÁöÑÊÉÖÊ≥Å
            if (p1.col === p2.col) return Infinity;
            return (p1.row - p2.row) / (p1.col - p2.col);
        }
        
        // Ë®àÁÆóÂêëÈáè
        function calculateVector(p1, p2) {
            return {
                x: p2.col - p1.col,
                y: p2.row - p1.row
            };
        }
        
        // Ë®àÁÆóÂêëÈáèÁöÑÈªûÁ©ç
        function dotProduct(v1, v2) {
            return v1.x * v2.x + v1.y * v2.y;
        }
        
        // Ë®àÁÆóÂêëÈáèÁöÑÊ®°ÔºàÈï∑Â∫¶Ôºâ
        function vectorMagnitude(v) {
            return Math.sqrt(v.x * v.x + v.y * v.y);
        }
        
        // Ë®àÁÆóÂÖ©ÂÄãÂêëÈáè‰πãÈñìÁöÑËßíÂ∫¶ÔºàÂºßÂ∫¶Ôºâ
        function calculateAngle(v1, v2) {
            const dot = dotProduct(v1, v2);
            const mag1 = vectorMagnitude(v1);
            const mag2 = vectorMagnitude(v2);
            
            // Èò≤Ê≠¢Èô§‰ª•Èõ∂ÊàñË®àÁÆóË™§Â∑Æ
            if (mag1 === 0 || mag2 === 0) return 0;
            
            // Á¢∫‰øùÂÄºÂú®-1Âà∞1‰πãÈñì‰ª•ÈÅøÂÖçÂõ†Ë®àÁÆóË™§Â∑ÆÂ∞éËá¥ÁöÑacosÈåØË™§
            const cosTheta = Math.max(-1, Math.min(1, dot / (mag1 * mag2)));
            return Math.acos(cosTheta);
        }
        
        // Ê™¢Êü•ÂÖ©Ê¢ùÁ∑öÊòØÂê¶Âπ≥Ë°å
        function areLinesParallel(line1Start, line1End, line2Start, line2End) {
            const v1 = calculateVector(line1Start, line1End);
            const v2 = calculateVector(line2Start, line2End);
            
            // Âπ≥Ë°åÂêëÈáèÁöÑÂèâÁ©çÁÇ∫Èõ∂
            const crossProduct = v1.x * v2.y - v1.y * v2.x;
            
            // ËÄÉÊÖÆÊµÆÈªûÊï∏Ë™§Â∑ÆÔºå‰ΩøÁî®ËºÉÂØ¨È¨ÜÁöÑÊ®ôÊ∫ñ
            const tolerance = 0.15 * vectorMagnitude(v1) * vectorMagnitude(v2);
            return Math.abs(crossProduct) < tolerance;
        }
        
        // Ê™¢Êü•ÂÖ©Ê¢ùÁ∑öÊòØÂê¶ÂûÇÁõ¥
        function areLinesOrthogonal(line1Start, line1End, line2Start, line2End) {
            const v1 = calculateVector(line1Start, line1End);
            const v2 = calculateVector(line2Start, line2End);
            
            // ÂûÇÁõ¥ÂêëÈáèÁöÑÈªûÁ©çÁÇ∫Èõ∂
            const dot = dotProduct(v1, v2);
            
            // ËÄÉÊÖÆÊµÆÈªûÊï∏Ë™§Â∑Æ
            const tolerance = 0.15 * vectorMagnitude(v1) * vectorMagnitude(v2);
            return Math.abs(dot) < tolerance;
        }
        
        // Ê™¢Êü•ÊòØÂê¶ÁÇ∫Á≠âËÖ∞‰∏âËßíÂΩ¢
        function isIsoscelesTriangle() {
            const points = getTrianglePoints();
            if (!points) return false;
            
            // Ë®àÁÆó‰∏âÊ¢ùÈÇäÁöÑÈï∑Â∫¶
            const d1 = calculateDistance(points.p1, points.p2);
            const d2 = calculateDistance(points.p2, points.p3);
            const d3 = calculateDistance(points.p3, points.p1);
            
            // ‰ΩøÁî®ËºÉÂö¥Ê†ºÁöÑÂÆπÂ∑Æ
            const tolerance = 0.08; // Êõ¥Âö¥Ê†ºÁöÑÂÆπÂ∑Æ‰æÜÂà§Êñ∑Áõ∏Á≠â
            const notEqualTolerance = 0.15; // Âà§Êñ∑‰∏çÁõ∏Á≠âÁöÑÂÆπÂ∑Æ
            
            // ‰ΩøÁî®ÊØîÁéáËÄå‰∏çÊòØÁµïÂ∞çÂ∑ÆÂÄº‰æÜËôïÁêÜËºÉÂ§ßÁöÑ‰∏âËßíÂΩ¢
            const ratio12 = Math.abs(d1 - d2) / Math.max(d1, d2);
            const ratio23 = Math.abs(d2 - d3) / Math.max(d2, d3);
            const ratio31 = Math.abs(d3 - d1) / Math.max(d3, d1);
            
            if (debugMode) {
                console.log(`Á≠âËÖ∞Ê™¢Ê∏¨: ÈÇäÈï∑ ${d1.toFixed(2)}, ${d2.toFixed(2)}, ${d3.toFixed(2)}`);
                console.log(`ÊØîÁéá: ${ratio12.toFixed(4)}, ${ratio23.toFixed(4)}, ${ratio31.toFixed(4)}`);
                console.log(`Áõ∏Á≠âÈñæÂÄº: ${tolerance}, ‰∏çÁõ∏Á≠âÈñæÂÄº: ${notEqualTolerance}`);
            }
            
            // Á≠âËÖ∞‰∏âËßíÂΩ¢ÂøÖÈ†àÊÅ∞Â•ΩÊúâÂÖ©Ê¢ùÈÇäÁõ∏Á≠âÔºåÁ¨¨‰∏âÊ¢ùÈÇä‰∏çÁ≠âÊñºÂÖ∂‰ªñÂÖ©Ê¢ù
            const sides12Equal = ratio12 < tolerance;
            const sides23Equal = ratio23 < tolerance;
            const sides31Equal = ratio31 < tolerance;
            
            // Ê™¢Êü•ÊòØÂê¶ÁÇ∫Á≠âÈÇä‰∏âËßíÂΩ¢Ôºà‰∏âÊ¢ùÈÇäÈÉΩÁõ∏Á≠âÔºâ
            const isEquilateral = sides12Equal && sides23Equal && sides31Equal;
            
            // ËøîÂõûtrueÂè™ÊúâÂú®ÊÅ∞Â•ΩÂÖ©Ê¢ùÈÇäÁõ∏Á≠â‰∏¶‰∏î‰∏çÊòØÁ≠âÈÇä‰∏âËßíÂΩ¢ÁöÑÊÉÖÊ≥Å
            return !isEquilateral && (
                (sides12Equal && !sides23Equal && !sides31Equal) ||
                (!sides12Equal && sides23Equal && !sides31Equal) ||
                (!sides12Equal && !sides23Equal && sides31Equal)
            );
        }
        
        // Ê™¢Êü•ÊòØÂê¶ÁÇ∫Á≠âÈÇä‰∏âËßíÂΩ¢
        function isEquilateralTriangle() {
            const points = getTrianglePoints();
            if (!points) return false;
            
            // Ë®àÁÆó‰∏âÊ¢ùÈÇäÁöÑÈï∑Â∫¶
            const d1 = calculateDistance(points.p1, points.p2);
            const d2 = calculateDistance(points.p2, points.p3);
            const d3 = calculateDistance(points.p3, points.p1);
            
            // ‰ΩøÁî®Êõ¥ÂØ¨È¨ÜÁöÑÂÆπÂ∑ÆÔºåËÆìÊõ¥Â§öË¶ñË¶∫‰∏äÊ≠£Á¢∫ÁöÑ‰∏âËßíÂΩ¢ËÉΩË¢´Êé•Âèó
            const tolerance = 0.15; // Â¢ûÂä†ÂÆπÂ∑ÆÂà∞15%
            
            // ‰ΩøÁî®Â§öÁ®ÆÊ™¢Ê∏¨ÊñπÊ≥ïÁµêÂêàÂà§Êñ∑
            
            // ÊñπÊ≥ï1: ÈÇäÈï∑ÊØîÁéáÊ™¢Ê∏¨
            const ratio12 = Math.abs(d1 - d2) / Math.max(d1, d2);
            const ratio23 = Math.abs(d2 - d3) / Math.max(d2, d3);
            const ratio31 = Math.abs(d3 - d1) / Math.max(d3, d1);
            
            // Ë®àÁÆóÊúÄÂ§ßÂÅèÂ∑Æ
            const maxRatio = Math.max(ratio12, ratio23, ratio31);
            const edgeRatioCheck = maxRatio < tolerance;
            
            // ÊñπÊ≥ï2: ËßíÂ∫¶Ê™¢Ê∏¨ (60Â∫¶ËßíÊ™¢Ê∏¨)
            // Ë®àÁÆó‰∏âÂÄãÂêëÈáè
            const v1 = calculateVector(points.p1, points.p2);
            const v2 = calculateVector(points.p2, points.p3);
            const v3 = calculateVector(points.p3, points.p1);
            
            // Ë®àÁÆóÂ§æËßí (ÁêÜÊÉ≥ÊÉÖÊ≥ÅÊòØ60Â∫¶ÔºåÂç≥œÄ/3ÂºßÂ∫¶)
            const angle1 = calculateAngle({x: -v3.x, y: -v3.y}, v1);
            const angle2 = calculateAngle({x: -v1.x, y: -v1.y}, v2);
            const angle3 = calculateAngle({x: -v2.x, y: -v2.y}, v3);
            
            // Ê™¢Êü•ËßíÂ∫¶ÊòØÂê¶Êé•Ëøë60Â∫¶(œÄ/3)
            const angleTolerance = 0.15; // ËßíÂ∫¶ÂÆπÂ∑Æ
            const angleCheck = (
                Math.abs(angle1 - Math.PI/3) < angleTolerance * Math.PI/3 &&
                Math.abs(angle2 - Math.PI/3) < angleTolerance * Math.PI/3 &&
                Math.abs(angle3 - Math.PI/3) < angleTolerance * Math.PI/3
            );
            
            // ÊñπÊ≥ï3: ‰ΩøÁî®È†êË®≠Ëß£Ê≥ïÊ™¢Ê∏¨ (ÊØîËºÉËàáËß£Á≠îÈªûÁöÑËøë‰ººÂ∫¶)
            let solutionCheck = false;
            const level = levels[currentLevelIndex];
            if (level.solutionPoint) {
                // Ê™¢Êü•Á¨¨‰∏âÈªûÊòØÂê¶Êé•ËøëÈ†êË®≠ÁöÑËß£Á≠îÈªû
                const solutionDist = calculateDistance(points.p3, level.solutionPoint);
                solutionCheck = solutionDist < 1.5; // Â¶ÇÊûúÈªûÂú®Ëß£Á≠îÈôÑËøëÔºå‰πüË™çÁÇ∫Ê≠£Á¢∫
            }
            
            if (debugMode) {
                console.log(`Á≠âÈÇäÊ™¢Ê∏¨: ÈÇäÈï∑ ${d1.toFixed(2)}, ${d2.toFixed(2)}, ${d3.toFixed(2)}`);
                console.log(`ÈÇäÈï∑ÊØîÁéá: ${ratio12.toFixed(4)}, ${ratio23.toFixed(4)}, ${ratio31.toFixed(4)}`);
                console.log(`ÊúÄÂ§ßÂÅèÂ∑Æ: ${maxRatio.toFixed(4)}, ÈñæÂÄº: ${tolerance}`);
                console.log(`ËßíÂ∫¶Ê™¢Ê∏¨: ${angleCheck}, Ëß£Á≠îÊ™¢Ê∏¨: ${solutionCheck}`);
            }
            
            // ÊîæÂØ¨Ê®ôÊ∫ñÔºöÂè™Ë¶ÅÊªøË∂≥ÈÇäÈï∑ÊØî‰æãÊàñËßíÂ∫¶Ê™¢Ê∏¨ÁöÑ‰ªª‰∏ÄÈ†ÖÔºåÂ∞±Ë™çÁÇ∫ÊòØÁ≠âÈÇä‰∏âËßíÂΩ¢
            return edgeRatioCheck || angleCheck || solutionCheck;
        }
        
        // Ê™¢Êü•ÊòØÂê¶ÁÇ∫Áõ¥Ëßí‰∏âËßíÂΩ¢
        function isRightTriangle() {
            const points = getTrianglePoints();
            if (!points) return false;
            
            // Ë®àÁÆó‰∏âÈÇäÈï∑Âπ≥Êñπ
            const sides = [
                {
                    squared: Math.pow(points.p1.col - points.p2.col, 2) + Math.pow(points.p1.row - points.p2.row, 2),
                    points: [points.p1, points.p2]
                },
                {
                    squared: Math.pow(points.p2.col - points.p3.col, 2) + Math.pow(points.p2.row - points.p3.row, 2),
                    points: [points.p2, points.p3]
                },
                {
                    squared: Math.pow(points.p3.col - points.p1.col, 2) + Math.pow(points.p3.row - points.p1.row, 2),
                    points: [points.p3, points.p1]
                }
            ].sort((a, b) => a.squared - b.squared);
            
            // Ê™¢Êü•Áï¢Ê∞èÂÆöÁêÜ a¬≤ + b¬≤ = c¬≤
            const tolerance = 0.15; // ‰ΩøÁî®ËºÉÂØ¨È¨ÜÁöÑÂÆπÂ∑Æ
            const pythagoreanRatio = sides[2].squared / (sides[0].squared + sides[1].squared);
            
            // ‰ΩøÁî®ÂêëÈáèÊñπÊ≥ïÈ©óË≠â
            const v1 = calculateVector(sides[0].points[0], sides[0].points[1]);
            const v2 = calculateVector(sides[1].points[0], sides[1].points[1]);
            const dotProduct = v1.x * v2.x + v1.y * v2.y;
            
            // Ê≠£‰∫§ÂêëÈáèÁöÑÈªûÁ©çÊáâÊé•ËøëÊñºÈõ∂
            const orthogonalCheck = Math.abs(dotProduct) / (vectorMagnitude(v1) * vectorMagnitude(v2)) < 0.15;
            
            if (debugMode) {
                console.log(`Áõ¥ËßíÊ™¢Ê∏¨: Áï¢Ê∞èÊØîÁéá ${pythagoreanRatio.toFixed(4)}`);
                console.log(`Ê≠£‰∫§Ê™¢Êü•: ${orthogonalCheck}`);
            }
            
            return Math.abs(pythagoreanRatio - 1) < tolerance || orthogonalCheck;
        }
        
        // Ê™¢Êü•ÊòØÂê¶ÁÇ∫Áõ¥ËßíÁ≠âËÖ∞‰∏âËßíÂΩ¢
        function isRightIsoscelesTriangle() {
            const points = getTrianglePoints();
            if (!points) return false;
            
            // Ë®àÁÆó‰∏âÊ¢ùÈÇäÁöÑÈï∑Â∫¶ÂíåÂπ≥Êñπ
            const sides = [
                {
                    length: calculateDistance(points.p1, points.p2),
                    squared: Math.pow(points.p1.col - points.p2.col, 2) + Math.pow(points.p1.row - points.p2.row, 2),
                    points: [points.p1, points.p2]
                },
                {
                    length: calculateDistance(points.p2, points.p3),
                    squared: Math.pow(points.p2.col - points.p3.col, 2) + Math.pow(points.p2.row - points.p3.row, 2),
                    points: [points.p2, points.p3]
                },
                {
                    length: calculateDistance(points.p3, points.p1),
                    squared: Math.pow(points.p3.col - points.p1.col, 2) + Math.pow(points.p3.row - points.p1.row, 2),
                    points: [points.p3, points.p1]
                }
            ].sort((a, b) => a.squared - b.squared);
            
            // ÂÖ©Ê¢ùÁü≠ÈÇäÁöÑÊØî‰æã
            const tolerance = 0.15; // ‰ΩøÁî®ËºÉÂØ¨È¨ÜÁöÑÂÆπÂ∑Æ
            const isoscelesRatio = Math.abs(sides[0].length - sides[1].length) / Math.max(sides[0].length, sides[1].length);
            
            // Áï¢Ê∞èÂÆöÁêÜÊ™¢Êü•
            const pythagoreanRatio = sides[2].squared / (sides[0].squared + sides[1].squared);
            
            if (debugMode) {
                console.log(`Áõ¥ËßíÁ≠âËÖ∞Ê™¢Ê∏¨: Á≠âËÖ∞ÊØîÁéá ${isoscelesRatio.toFixed(4)}, Áï¢Ê∞èÊØîÁéá ${pythagoreanRatio.toFixed(4)}`);
            }
            
            return isoscelesRatio < tolerance && Math.abs(pythagoreanRatio - 1) < tolerance;
        }
        
        // Ê™¢Êü•ÊòØÂê¶ÁÇ∫‰∏çÁ≠âÈÇä‰∏âËßíÂΩ¢
        function isScaleneTriangle() {
            const points = getTrianglePoints();
            if (!points) return false;
            
            // Ë®àÁÆó‰∏âÊ¢ùÈÇäÁöÑÈï∑Â∫¶
            const d1 = calculateDistance(points.p1, points.p2);
            const d2 = calculateDistance(points.p2, points.p3);
            const d3 = calculateDistance(points.p3, points.p1);
            
            // Ê™¢Êü•ÊâÄÊúâÈÇäÁöÑÊØî‰æã‰∏çÁõ∏Á≠â
            const tolerance = 0.15; // ‰ΩøÁî®ËºÉÂØ¨È¨ÜÁöÑÂÆπÂ∑Æ
            
            // ‰ΩøÁî®ÊØîÁéáÊ™¢Êü•
            const ratio12 = Math.abs(d1 - d2) / Math.max(d1, d2);
            const ratio23 = Math.abs(d2 - d3) / Math.max(d2, d3);
            const ratio31 = Math.abs(d3 - d1) / Math.max(d3, d1);
            
            if (debugMode) {
                console.log(`‰∏çÁ≠âÈÇäÊ™¢Ê∏¨: ÈÇäÈï∑ ${d1.toFixed(2)}, ${d2.toFixed(2)}, ${d3.toFixed(2)}`);
                console.log(`ÊØîÁéá: ${ratio12.toFixed(4)}, ${ratio23.toFixed(4)}, ${ratio31.toFixed(4)}`);
            }
            
            // ÊâÄÊúâÈÇäÈÉΩ‰∏çÁõ∏Á≠âÔºå‰πüÂ∞±ÊòØÊ≤íÊúâÂÖ©Ê¢ùÈÇäÁõ∏Á≠â
            return ratio12 > tolerance && ratio23 > tolerance && ratio31 > tolerance;
        }
        
        // Ê™¢Êü•ÊòØÂê¶ÁÇ∫Ê≠£ÊñπÂΩ¢
        function isSquare() {
            const points = getQuadrilateralPoints();
            if (!points) return false;
            
            // Áç≤ÂèñÂõõÈÇä
            const edges = [
                {
                    length: calculateDistance(points.p1, points.p2),
                    vector: calculateVector(points.p1, points.p2)
                },
                {
                    length: calculateDistance(points.p2, points.p3),
                    vector: calculateVector(points.p2, points.p3)
                },
                {
                    length: calculateDistance(points.p3, points.p4),
                    vector: calculateVector(points.p3, points.p4)
                },
                {
                    length: calculateDistance(points.p4, points.p1),
                    vector: calculateVector(points.p4, points.p1)
                }
            ];
            
            // Ë®àÁÆóÂ∞çËßíÁ∑ö
            const diag1 = calculateDistance(points.p1, points.p3);
            const diag2 = calculateDistance(points.p2, points.p4);
            
            // Ê™¢Êü•ÊâÄÊúâÈÇäÊòØÂê¶Âö¥Ê†ºÁõ∏Á≠â - ‰ΩøÁî®Êõ¥Âö¥Ê†ºÁöÑÂÆπÂ∑Æ
            const tolerance = 0.06; // Êõ¥Âö¥Ê†ºÁöÑÂÆπÂ∑ÆÔºå‰∏ÄËà¨Èï∑ÊñπÂΩ¢‰∏çÊúÉÈÄöÈÅéÊ≠§Ê™¢Êü•
            const avgLength = edges.reduce((sum, edge) => sum + edge.length, 0) / 4;
            
            // Ê™¢Êü•ÊØèÊ¢ùÈÇäËàáÂπ≥ÂùáÂÄºÁöÑÂÅèÂ∑Æ
            const edgeDeviations = edges.map(edge => 
                Math.abs(edge.length - avgLength) / avgLength
            );
            
            const maxDeviation = Math.max(...edgeDeviations);
            const allSidesEqual = maxDeviation < tolerance;
            
            if (debugMode) {
                console.log(`Ê≠£ÊñπÂΩ¢Ê™¢Ê∏¨ - ÊúÄÂ§ßÈÇäÈï∑ÂÅèÂ∑ÆÁéá: ${maxDeviation.toFixed(4)}, ÈñæÂÄº: ${tolerance}`);
                console.log(`Ê≠£ÊñπÂΩ¢Ê™¢Ê∏¨ - ÂõõÈÇäÈï∑Â∫¶: ${edges.map(e => e.length.toFixed(2)).join(', ')}`);
            }
            
            // Ê™¢Êü•Â∞çËßíÁ∑öÊòØÂê¶Ëøë‰ººÁõ∏Á≠â
            const diagRatio = Math.abs(diag1 - diag2) / Math.max(diag1, diag2);
            const diagEqual = diagRatio < tolerance;
            
            if (debugMode) {
                console.log(`Ê≠£ÊñπÂΩ¢Ê™¢Ê∏¨ - Â∞çËßíÁ∑öÊØîÁéá: ${diagRatio.toFixed(4)}, ÈñæÂÄº: ${tolerance}`);
            }
            
            // Ê™¢Êü•Áõ∏ÈÑ∞ÈÇäÊòØÂê¶Âö¥Ê†ºÂûÇÁõ¥
            const anglesTolerance = 0.08; // Êõ¥Âö¥Ê†ºÁöÑËßíÂ∫¶ÂÆπÂ∑Æ
            const rightAngles = [
                Math.abs(Math.PI/2 - calculateAngle(edges[0].vector, edges[1].vector)),
                Math.abs(Math.PI/2 - calculateAngle(edges[1].vector, edges[2].vector)),
                Math.abs(Math.PI/2 - calculateAngle(edges[2].vector, edges[3].vector)),
                Math.abs(Math.PI/2 - calculateAngle(edges[3].vector, edges[0].vector))
            ];
            
            const maxAngleDeviation = Math.max(...rightAngles);
            const hasRightAngles = maxAngleDeviation < anglesTolerance;
            
            if (debugMode) {
                console.log(`Ê≠£ÊñπÂΩ¢Ê™¢Ê∏¨ - ÊúÄÂ§ßËßíÂ∫¶ÂÅèÂ∑Æ: ${(maxAngleDeviation * 180 / Math.PI).toFixed(2)}Â∫¶, ÈñæÂÄº: ${(anglesTolerance * 180 / Math.PI).toFixed(2)}Â∫¶`);
            }
            
            // ÈÄô‰∏âÂÄãÊ¢ù‰ª∂ÂøÖÈ†àÂêåÊôÇÊªøË∂≥
            return allSidesEqual && diagEqual && hasRightAngles;
        }
        
        // Ê™¢Êü•ÊòØÂê¶ÁÇ∫Èï∑ÊñπÂΩ¢
        function isRectangle() {
            const points = getQuadrilateralPoints();
            if (!points) return false;
            
            // Áç≤ÂèñÂõõÈÇä
            const edges = [
                {
                    length: calculateDistance(points.p1, points.p2),
                    vector: calculateVector(points.p1, points.p2)
                },
                {
                    length: calculateDistance(points.p2, points.p3),
                    vector: calculateVector(points.p2, points.p3)
                },
                {
                    length: calculateDistance(points.p3, points.p4),
                    vector: calculateVector(points.p3, points.p4)
                },
                {
                    length: calculateDistance(points.p4, points.p1),
                    vector: calculateVector(points.p4, points.p1)
                }
            ];
            
            // Â∞çÈÇäÊáâË©≤Áõ∏Á≠âÔºå‰ΩÜÁõ∏ÈÑ∞ÈÇäÂèØËÉΩ‰∏çÁ≠â
            const tolerance = 0.1; // Â∞çÈÇäÁõ∏Á≠âÁöÑÂÆπÂ∑Æ
            
            // Ê™¢Êü•Â∞çÈÇäÊòØÂê¶Áõ∏Á≠âÔºàÁ¨¨1„ÄÅ3ÈÇäÁõ∏Á≠âÔºåÁ¨¨2„ÄÅ4ÈÇäÁõ∏Á≠âÔºâ
            const ratio13 = Math.abs(edges[0].length - edges[2].length) / Math.max(edges[0].length, edges[2].length);
            const ratio24 = Math.abs(edges[1].length - edges[3].length) / Math.max(edges[1].length, edges[3].length);
            
            const oppositeSidesEqual = ratio13 < tolerance && ratio24 < tolerance;
            
            if (debugMode) {
                console.log(`Èï∑ÊñπÂΩ¢Ê™¢Ê∏¨ - Â∞çÈÇäÊØîÁéá: ${ratio13.toFixed(4)}, ${ratio24.toFixed(4)}, ÈñæÂÄº: ${tolerance}`);
            }
            
            // Ë®àÁÆóÂ∞çËßíÁ∑ö
            const diag1 = calculateDistance(points.p1, points.p3);
            const diag2 = calculateDistance(points.p2, points.p4);
            
            // Ê™¢Êü•Â∞çËßíÁ∑öÊòØÂê¶Áõ∏Á≠â
            const diagRatio = Math.abs(diag1 - diag2) / Math.max(diag1, diag2);
            const diagEqual = diagRatio < tolerance;
            
            if (debugMode) {
                console.log(`Èï∑ÊñπÂΩ¢Ê™¢Ê∏¨ - Â∞çËßíÁ∑öÊØîÁéá: ${diagRatio.toFixed(4)}, ÈñæÂÄº: ${tolerance}`);
            }
            
            // Ê™¢Êü•ÊòØÂê¶ÊúâÁõ¥Ëßí
            const anglesTolerance = 0.08; // Êõ¥Âö¥Ê†ºÁöÑËßíÂ∫¶ÂÆπÂ∑Æ
            const angles = [
                Math.abs(Math.PI/2 - calculateAngle(
                    {x: -edges[0].vector.x, y: -edges[0].vector.y}, 
                    edges[3].vector
                )),
                Math.abs(Math.PI/2 - calculateAngle(
                    {x: -edges[1].vector.x, y: -edges[1].vector.y}, 
                    edges[0].vector
                )),
                Math.abs(Math.PI/2 - calculateAngle(
                    {x: -edges[2].vector.x, y: -edges[2].vector.y}, 
                    edges[1].vector
                )),
                Math.abs(Math.PI/2 - calculateAngle(
                    {x: -edges[3].vector.x, y: -edges[3].vector.y}, 
                    edges[2].vector
                ))
            ];
            
            const maxAngleDeviation = Math.max(...angles);
            const hasRightAngles = maxAngleDeviation < anglesTolerance;
            
            if (debugMode) {
                console.log(`Èï∑ÊñπÂΩ¢Ê™¢Ê∏¨ - ÊúÄÂ§ßËßíÂ∫¶ÂÅèÂ∑Æ: ${(maxAngleDeviation * 180 / Math.PI).toFixed(2)}Â∫¶, ÈñæÂÄº: ${(anglesTolerance * 180 / Math.PI).toFixed(2)}Â∫¶`);
            }
            
            // È°çÂ§ñÊ™¢Êü•ÔºöÁ¢∫‰øù‰∏çÊòØÊ≠£ÊñπÂΩ¢
            // Ê™¢Êü•Áõ∏ÈÑ∞ÈÇäÊòØÂê¶‰∏çÁ≠âÔºàËá≥Â∞ëÊúâ‰∏ÄÁµÑÁõ∏ÈÑ∞ÈÇäÂ∑ÆÁï∞ËºÉÂ§ßÔºâ
            const adjacentRatio12 = Math.abs(edges[0].length - edges[1].length) / Math.max(edges[0].length, edges[1].length);
            const adjacentRatio23 = Math.abs(edges[1].length - edges[2].length) / Math.max(edges[1].length, edges[2].length);
            const adjacentRatio34 = Math.abs(edges[2].length - edges[3].length) / Math.max(edges[2].length, edges[3].length);
            const adjacentRatio41 = Math.abs(edges[3].length - edges[0].length) / Math.max(edges[3].length, edges[0].length);
            
            // Ëá≥Â∞ëÊúâ‰∏ÄÁµÑÁõ∏ÈÑ∞ÈÇäÂ∑ÆÁï∞ËºÉÂ§ßÔºà‰∏çÊòØÊ≠£ÊñπÂΩ¢Ôºâ
            const squareTolerance = 0.06; // ËàáÊ≠£ÊñπÂΩ¢Âà§Êñ∑‰∏ÄËá¥
            const notSquare = adjacentRatio12 > squareTolerance || 
                              adjacentRatio23 > squareTolerance ||
                              adjacentRatio34 > squareTolerance ||
                              adjacentRatio41 > squareTolerance;
            
            if (debugMode) {
                console.log(`Èï∑ÊñπÂΩ¢Ê™¢Ê∏¨ - ÈùûÊ≠£ÊñπÂΩ¢Ê™¢Êü•: ${notSquare}, Áõ∏ÈÑ∞ÈÇäÊØîÁéá: ${adjacentRatio12.toFixed(4)}, ${adjacentRatio23.toFixed(4)}, ${adjacentRatio34.toFixed(4)}, ${adjacentRatio41.toFixed(4)}`);
            }
            
            // Èï∑ÊñπÂΩ¢Ê¢ù‰ª∂ÔºöÂ∞çÈÇäÁõ∏Á≠â„ÄÅÂ∞çËßíÁ∑öÁõ∏Á≠â„ÄÅÊúâÁõ¥ËßíÔºå‰ΩÜ‰∏çÊòØÊ≠£ÊñπÂΩ¢
            return oppositeSidesEqual && diagEqual && hasRightAngles && notSquare;
        }
        
        // Ê™¢Êü•ÊòØÂê¶ÁÇ∫Âπ≥Ë°åÂõõÈÇäÂΩ¢
        function isParallelogram() {
            const points = getQuadrilateralPoints();
            if (!points) return false;
            
            // Áç≤ÂèñÂõõÈÇä
            const edges = [
                {
                    length: calculateDistance(points.p1, points.p2),
                    vector: calculateVector(points.p1, points.p2)
                },
                {
                    length: calculateDistance(points.p2, points.p3),
                    vector: calculateVector(points.p2, points.p3)
                },
                {
                    length: calculateDistance(points.p3, points.p4),
                    vector: calculateVector(points.p3, points.p4)
                },
                {
                    length: calculateDistance(points.p4, points.p1),
                    vector: calculateVector(points.p4, points.p1)
                }
            ];
            
            // Ê™¢Êü•Â∞çÈÇäÊòØÂê¶Âπ≥Ë°åÂíåÁõ∏Á≠â
            const tolerance = 0.15; // ‰ΩøÁî®ËºÉÂØ¨È¨ÜÁöÑÂÆπÂ∑Æ
            
            // Ê™¢Êü•Â∞çÈÇäÊòØÂê¶Áõ∏Á≠â
            const oppositeSidesEqual = 
                Math.abs(edges[0].length - edges[2].length) / Math.max(edges[0].length, edges[2].length) < tolerance &&
                Math.abs(edges[1].length - edges[3].length) / Math.max(edges[1].length, edges[3].length) < tolerance;
            
            // Ê™¢Êü•Â∞çÈÇäÊòØÂê¶Âπ≥Ë°å
            const parallelCheck1 = areLinesParallel(
                points.p1, points.p2,
                points.p3, points.p4
            );
            
            const parallelCheck2 = areLinesParallel(
                points.p2, points.p3,
                points.p4, points.p1
            );
            
            if (debugMode) {
                console.log(`Âπ≥Ë°åÂõõÈÇäÂΩ¢Ê™¢Ê∏¨: Â∞çÈÇäÁõ∏Á≠â ${oppositeSidesEqual}, Âπ≥Ë°åÊ™¢Êü•1 ${parallelCheck1}, Âπ≥Ë°åÊ™¢Êü•2 ${parallelCheck2}`);
                console.log(`ÈÇäÈï∑: ${edges.map(e => e.length.toFixed(2)).join(', ')}`);
            }
            
            // Ê™¢Êü•ÊòØÂê¶ÊòØÈï∑ÊñπÂΩ¢ÊàñÊ≠£ÊñπÂΩ¢
            const isRect = isRectangle();
            const isSq = isSquare();
            
            // ÊòØÂπ≥Ë°åÂõõÈÇäÂΩ¢‰ΩÜ‰∏çÊòØÈï∑ÊñπÂΩ¢ÊàñÊ≠£ÊñπÂΩ¢
            return oppositeSidesEqual && parallelCheck1 && parallelCheck2 && !isRect && !isSq;
        }
        
        // ÊªëÈº†‰∫ã‰ª∂ËôïÁêÜ
        function handleMouseMove(e) {
            if (!isGameActive) return;
            
            const rect = canvas.getBoundingClientRect();
            const x = e.clientX - rect.left;
            const y = e.clientY - rect.top;
            
            // Êõ¥Êñ∞Êá∏ÂÅúÈªû
            const previousHovered = hoveredPoint;
            hoveredPoint = findGridPoint(x, y);
            
            // Â¶ÇÊûúÊá∏ÂÅúÈªûÁôºÁîüËÆäÂåñÔºåÊ∑ªÂä†ÊòüÊòüÈñÉÁàçÂãïÁï´
            if (hoveredPoint && (!previousHovered || 
                previousHovered.row !== hoveredPoint.row || 
                previousHovered.col !== hoveredPoint.col)) {
                playSound('click');
                
                // Áï∂Êá∏ÂÅúÂà∞Êñ∞ÈªûÊôÇÔºåÂèØ‰ª•Ê∑ªÂä†Á≤íÂ≠êÊïàÊûú
                const gridRatio = (canvas.width - 2 * offsetX) / (numCols * gridSize);
                const pointX = offsetX + hoveredPoint.col * gridSize * gridRatio;
                const pointY = offsetY + hoveredPoint.row * gridSize * gridRatio;
                
                // Ê∑ªÂä†ÂæÆÂº±ÁöÑÁ≤íÂ≠êÊïàÊûú
                for (let i = 0; i < 3; i++) {
                    setTimeout(() => {
                        const angle = Math.random() * Math.PI * 2;
                        const distance = Math.random() * 15;
                        createParticle(
                            rect.left + pointX + Math.cos(angle) * distance, 
                            rect.top + pointY + Math.sin(angle) * distance
                        );
                    }, i * 50);
                }
            }
            
            // Êõ¥Êñ∞ÊãñÂãïÁ∑öÁöÑÁµÇÈªû
            if (selectedPoint !== null) {
                lastMouseX = x;
                lastMouseY = y;
            }
            
            // Êõ¥Êñ∞Â∑•ÂÖ∑ÊèêÁ§∫
            updateTooltip(e);
            
            drawGame();
        }
        
        function updateTooltip(e) {
            if (hoveredPoint) {
                tooltip.style.display = 'block';
                tooltip.style.left = (e.clientX + 10) + 'px';
                tooltip.style.top = (e.clientY + 10) + 'px';
                
                if (selectedPoint === null) {
                    tooltip.textContent = 'Click this star to start connecting';
                } else if (hoveredPoint.row === selectedPoint.row && hoveredPoint.col === selectedPoint.col) {
                    tooltip.textContent = 'Cancel selection of this star';
                } else if (canConnectPoints(selectedPoint, hoveredPoint)) {
                    tooltip.textContent = 'Connect to this star';
                } else {
                    tooltip.textContent = 'These two points are already connected';
                }
                
                // Êº∏ËÆäÂá∫ÁèæÊïàÊûú
                tooltip.style.opacity = 0;
                tooltip.style.transition = 'opacity 0.3s';
                setTimeout(() => {
                    tooltip.style.opacity = 1;
                }, 10);
            } else {
                tooltip.style.opacity = 0;
                setTimeout(() => {
                    tooltip.style.display = 'none';
                }, 300);
            }
        }
        
        function handleMouseDown(e) {
            if (!isGameActive || isComplete) return;
            
            const rect = canvas.getBoundingClientRect();
            const x = e.clientX - rect.left;
            const y = e.clientY - rect.top;
            
            const gridPoint = findGridPoint(x, y);
            
            if (gridPoint) {
                if (selectedPoint && selectedPoint.row === gridPoint.row && selectedPoint.col === gridPoint.col) {
                    // ÂèñÊ∂àÈÅ∏Êìá
                    selectedPoint = null;
                    playSound('click');
                } else if (selectedPoint === null) {
                    // ÈÅ∏ÊìáÁ¨¨‰∏ÄÂÄãÈªû
                    selectedPoint = gridPoint;
                    playSound('click');
                    
                    // Áç≤ÂèñCanvasÁõ∏Â∞çÊñºË¶ñÁ™óÁöÑ‰ΩçÁΩÆÂíåÂ∫ßÊ®ô
                    const gridRatio = (canvas.width - 2 * offsetX) / (numCols * gridSize);
                    const pointX = offsetX + selectedPoint.col * gridSize * gridRatio;
                    const pointY = offsetY + selectedPoint.row * gridSize * gridRatio;
                    
                    // ÈÅ∏ÊìáÈªûÊôÇÁöÑÁ≤íÂ≠êÊïàÊûú
                    for (let i = 0; i < 8; i++) {
                        setTimeout(() => {
                            const angle = Math.random() * Math.PI * 2;
                            const distance = Math.random() * 20;
                            createParticle(
                                rect.left + pointX + Math.cos(angle) * distance, 
                                rect.top + pointY + Math.sin(angle) * distance,
                                'rgba(255, 215, 0, 0.8)'
                            );
                        }, i * 30);
                    }
                } else if (canConnectPoints(selectedPoint, gridPoint)) {
                    // ÈÄ£Êé•Âà∞Á¨¨‰∫åÂÄãÈªû
                    userLines.push({
                        from: selectedPoint,
                        to: gridPoint
                    });
                    
                    // Áç≤ÂèñÈªûÂ∫ßÊ®ô
                    const gridRatio = (canvas.width - 2 * offsetX) / (numCols * gridSize);
                    const fromX = offsetX + selectedPoint.col * gridSize * gridRatio;
                    const fromY = offsetY + selectedPoint.row * gridSize * gridRatio;
                    const toX = offsetX + gridPoint.col * gridSize * gridRatio;
                    const toY = offsetY + gridPoint.row * gridSize * gridRatio;
                    
                    // ÂâµÂª∫ÈÄ£Êé•ÊïàÊûú
                    createConnectionLine(selectedPoint, gridPoint);
                    
                    selectedPoint = null;
                    playSound('connect');
                    
                    // Áç≤ÂèñÁï∂ÂâçÈóúÂç°ÊâÄÈúÄÁöÑÁ∑öÊ¢ùÊï∏
                    const requiredLines = levels[currentLevelIndex].requiredLines || 2;
                    
                    // Ëá™ÂãïÊ™¢Ê∏¨ - Â¶ÇÊûúÂÆåÊàêÊâÄÈúÄÁ∑öÊ¢ùÊï∏
                    if (userLines.length === requiredLines) {
                        // Áü≠Êö´Âª∂ÈÅ≤ËÆìÁî®Êà∂ÁúãÂà∞ÂÆåÊàêÁöÑÂΩ¢ÁãÄ
                        setTimeout(() => checkShape(), 300);
                    }
                }
            }
            
            lastMouseX = x;
            lastMouseY = y;
            
            drawGame();
        }
        
        function handleMouseUp(e) {
            if (!isGameActive || !selectedPoint || isComplete) return;
            
            const rect = canvas.getBoundingClientRect();
            const x = e.clientX - rect.left;
            const y = e.clientY - rect.top;
            
            const gridPoint = findGridPoint(x, y);
            
            if (gridPoint && canConnectPoints(selectedPoint, gridPoint)) {
                // ÈÄ£Êé•Âà∞Á¨¨‰∫åÂÄãÈªû
                userLines.push({
                    from: selectedPoint,
                    to: gridPoint
                });
                
                // ÂâµÂª∫ÈÄ£Êé•ÊïàÊûú
                createConnectionLine(selectedPoint, gridPoint);
                
                playSound('connect');
                
                // Áç≤ÂèñÁï∂ÂâçÈóúÂç°ÊâÄÈúÄÁöÑÁ∑öÊ¢ùÊï∏
                const requiredLines = levels[currentLevelIndex].requiredLines || 2;
                
                // Ëá™ÂãïÊ™¢Ê∏¨ - Â¶ÇÊûúÂÆåÊàêÊâÄÈúÄÁ∑öÊ¢ùÊï∏
                if (userLines.length === requiredLines) {
                    // Áü≠Êö´Âª∂ÈÅ≤ËÆìÁî®Êà∂ÁúãÂà∞ÂÆåÊàêÁöÑÂΩ¢ÁãÄ
                    setTimeout(() => checkShape(), 300);
                }
            }
            
            selectedPoint = null;
            drawGame();
        }
        
        // Ëß∏Êéß‰∫ã‰ª∂ËôïÁêÜ
        function handleTouchStart(e) {
            if (!isGameActive || isComplete) return;
            
            e.preventDefault();
            const rect = canvas.getBoundingClientRect();
            const touch = e.touches[0];
            const x = touch.clientX - rect.left;
            const y = touch.clientY - rect.top;
            
            const gridPoint = findGridPoint(x, y);
            
            if (gridPoint) {
                if (selectedPoint && selectedPoint.row === gridPoint.row && selectedPoint.col === gridPoint.col) {
                    // ÂèñÊ∂àÈÅ∏Êìá
                    selectedPoint = null;
                    playSound('click');
                } else if (selectedPoint === null) {
                    // ÈÅ∏ÊìáÁ¨¨‰∏ÄÂÄãÈªû
                    selectedPoint = gridPoint;
                    playSound('click');
                    
                    // Áç≤ÂèñCanvasÁõ∏Â∞çÊñºË¶ñÁ™óÁöÑ‰ΩçÁΩÆÂíåÂ∫ßÊ®ô
                    const gridRatio = (canvas.width - 2 * offsetX) / (numCols * gridSize);
                    const pointX = offsetX + selectedPoint.col * gridSize * gridRatio;
                    const pointY = offsetY + selectedPoint.row * gridSize * gridRatio;
                    
                    // ÈÅ∏ÊìáÈªûÊôÇÁöÑÁ≤íÂ≠êÊïàÊûú
                    for (let i = 0; i < 8; i++) {
                        setTimeout(() => {
                            const angle = Math.random() * Math.PI * 2;
                            const distance = Math.random() * 20;
                            createParticle(
                                rect.left + pointX + Math.cos(angle) * distance, 
                                rect.top + pointY + Math.sin(angle) * distance,
                                'rgba(255, 215, 0, 0.8)'
                            );
                        }, i * 30);
                    }
                } else if (canConnectPoints(selectedPoint, gridPoint)) {
                    // ÈÄ£Êé•Âà∞Á¨¨‰∫åÂÄãÈªû
                    userLines.push({
                        from: selectedPoint,
                        to: gridPoint
                    });
                    
                    // ÂâµÂª∫ÈÄ£Êé•ÊïàÊûú
                    createConnectionLine(selectedPoint, gridPoint);
                    
                    selectedPoint = null;
                    playSound('connect');
                    
                    // Áç≤ÂèñÁï∂ÂâçÈóúÂç°ÊâÄÈúÄÁöÑÁ∑öÊ¢ùÊï∏
                    const requiredLines = levels[currentLevelIndex].requiredLines || 2;
                    
                    // Ëá™ÂãïÊ™¢Ê∏¨ - Â¶ÇÊûúÂÆåÊàêÊâÄÈúÄÁ∑öÊ¢ùÊï∏
                    if (userLines.length === requiredLines) {
                        // Áü≠Êö´Âª∂ÈÅ≤ËÆìÁî®Êà∂ÁúãÂà∞ÂÆåÊàêÁöÑÂΩ¢ÁãÄ
                        setTimeout(() => checkShape(), 300);
                    }
                }
            }
            
            lastMouseX = x;
            lastMouseY = y;
            
            drawGame();
        }
        
        function handleTouchMove(e) {
            if (!isGameActive || selectedPoint === null || isComplete) return;
            
            e.preventDefault();
            const rect = canvas.getBoundingClientRect();
            const touch = e.touches[0];
            lastMouseX = touch.clientX - rect.left;
            lastMouseY = touch.clientY - rect.top;
            
            // Êõ¥Êñ∞Êá∏ÂÅúÈªû
            hoveredPoint = findGridPoint(lastMouseX, lastMouseY);
            
            drawGame();
        }
        
        function handleTouchEnd(e) {
            if (!isGameActive || !selectedPoint || isComplete) return;
            
            const rect = canvas.getBoundingClientRect();
            let x, y;
            
            if (e.changedTouches && e.changedTouches.length > 0) {
                const touch = e.changedTouches[0];
                x = touch.clientX - rect.left;
                y = touch.clientY - rect.top;
            } else {
                x = lastMouseX;
                y = lastMouseY;
            }
            
            const gridPoint = findGridPoint(x, y);
            
            if (gridPoint && canConnectPoints(selectedPoint, gridPoint)) {
                // ÈÄ£Êé•Âà∞Á¨¨‰∫åÂÄãÈªû
                userLines.push({
                    from: selectedPoint,
                    to: gridPoint
                });
                
                // ÂâµÂª∫ÈÄ£Êé•ÊïàÊûú
                createConnectionLine(selectedPoint, gridPoint);
                
                playSound('connect');
                
                // Áç≤ÂèñÁï∂ÂâçÈóúÂç°ÊâÄÈúÄÁöÑÁ∑öÊ¢ùÊï∏
                const requiredLines = levels[currentLevelIndex].requiredLines || 2;
                
                // Ëá™ÂãïÊ™¢Ê∏¨ - Â¶ÇÊûúÂÆåÊàêÊâÄÈúÄÁ∑öÊ¢ùÊï∏
                if (userLines.length === requiredLines) {
                    // Áü≠Êö´Âª∂ÈÅ≤ËÆìÁî®Êà∂ÁúãÂà∞ÂÆåÊàêÁöÑÂΩ¢ÁãÄ
                    setTimeout(() => checkShape(), 300);
                }
            }
            
            selectedPoint = null;
            drawGame();
        }
        
        // Âú®ÊéßÂà∂Âè∞ÂïüÁî®debugÊ®°ÂºèÁöÑÊñπÊ≥ï
        window.enableDebug = function() {
            debugMode = true;
            console.log("Ë™øË©¶Ê®°ÂºèÂ∑≤ÂïüÁî®");
        };
        
        window.disableDebug = function() {
            debugMode = false;
            console.log("Ë™øË©¶Ê®°ÂºèÂ∑≤Á¶ÅÁî®");
        };
        
        // PWA Service Worker Ë®ªÂÜäÂíåÂÆâË£ùÊèêÁ§∫
        if ('serviceWorker' in navigator) {
            window.addEventListener('load', () => {
                // Service Worker ‰ª£Á¢º
                const serviceWorkerCode = `
                    const CACHE_NAME = 'stellar-explorer-v1.0.0';
                    const urlsToCache = ['./'];

                    self.addEventListener('install', event => {
                        event.waitUntil(
                            caches.open(CACHE_NAME)
                                .then(cache => {
                                    console.log('üöÄ PWA Cache opened');
                                    return cache.addAll(urlsToCache);
                                })
                        );
                        self.skipWaiting();
                    });

                    self.addEventListener('activate', event => {
                        console.log('‚úÖ PWA Service Worker activated');
                        event.waitUntil(
                            caches.keys().then(cacheNames => {
                                return Promise.all(
                                    cacheNames.map(cacheName => {
                                        if (cacheName !== CACHE_NAME) {
                                            return caches.delete(cacheName);
                                        }
                                    })
                                );
                            })
                        );
                        self.clients.claim();
                    });

                    self.addEventListener('fetch', event => {
                        if (event.request.url.startsWith('http')) {
                            event.respondWith(
                                caches.match(event.request)
                                    .then(response => {
                                        if (response) {
                                            return response;
                                        }
                                        return fetch(event.request).then(response => {
                                            if (!response || response.status !== 200 || response.type !== 'basic') {
                                                return response;
                                            }
                                            const responseToCache = response.clone();
                                            caches.open(CACHE_NAME)
                                                .then(cache => {
                                                    cache.put(event.request, responseToCache);
                                                });
                                            return response;
                                        }).catch(() => {
                                            if (event.request.headers.get('accept').includes('text/html')) {
                                                return caches.match('./');
                                            }
                                        });
                                    })
                            );
                        }
                    });
                `;

                const blob = new Blob([serviceWorkerCode], { type: 'application/javascript' });
                const swUrl = URL.createObjectURL(blob);

                navigator.serviceWorker.register(swUrl)
                    .then(registration => {
                        console.log('üåü PWA Service Worker registered:', registration.scope);
                    })
                    .catch(error => {
                        console.warn('‚ùå PWA Service Worker registration failed:', error);
                    });
            });
        }

        // PWA ÂÆâË£ùÊèêÁ§∫
        let deferredPrompt;
        let installPromptShown = false;

        window.addEventListener('beforeinstallprompt', (e) => {
            e.preventDefault();
            deferredPrompt = e;
            setTimeout(() => {
                showInstallPrompt();
            }, 5000);
        });

        function showInstallPrompt() {
            if (installPromptShown || !deferredPrompt) return;
            installPromptShown = true;

            const installBanner = document.createElement('div');
            installBanner.style.position = 'fixed';
            installBanner.style.top = '20px';
            installBanner.style.left = '50%';
            installBanner.style.transform = 'translateX(-50%)';
            installBanner.style.background = 'linear-gradient(135deg, rgba(93, 92, 222, 0.95), rgba(66, 64, 179, 0.95))';
            installBanner.style.color = 'white';
            installBanner.style.padding = '15px 25px';
            installBanner.style.borderRadius = '15px';
            installBanner.style.boxShadow = '0 8px 32px rgba(0, 0, 0, 0.3)';
            installBanner.style.border = '1px solid rgba(100, 255, 218, 0.3)';
            installBanner.style.zIndex = '10000';
            installBanner.style.maxWidth = '350px';
            installBanner.style.textAlign = 'center';
            installBanner.style.backdropFilter = 'blur(10px)';

            installBanner.innerHTML = 
                '<div style="margin-bottom: 10px;">' +
                    '<span style="font-size: 24px;">üì±</span>' +
                    '<div style="font-size: 16px; font-weight: bold; margin: 5px 0;">Install Stellar Explorer</div>' +
                    '<div style="font-size: 13px; opacity: 0.9;">Add to your home screen for the best experience!</div>' +
                '</div>' +
                '<div>' +
                    '<button id="installBtn" style="background: linear-gradient(135deg, #64FFDA, #00D0B6); color: #0A0B2F; border: none; padding: 8px 20px; border-radius: 20px; margin: 5px; cursor: pointer; font-weight: bold; font-size: 14px;">Install App</button>' +
                    '<button id="dismissBtn" style="background: rgba(255, 255, 255, 0.2); color: white; border: 1px solid rgba(255, 255, 255, 0.3); padding: 8px 20px; border-radius: 20px; margin: 5px; cursor: pointer; font-size: 14px;">Later</button>' +
                '</div>';

            document.body.appendChild(installBanner);

            document.getElementById('installBtn').addEventListener('click', () => {
                installBanner.remove();
                deferredPrompt.prompt();
                deferredPrompt.userChoice.then((choiceResult) => {
                    if (choiceResult.outcome === 'accepted') {
                        console.log('üì± User accepted the PWA install prompt');
                    } else {
                        console.log('‚ùå User dismissed the PWA install prompt');
                    }
                    deferredPrompt = null;
                });
            });

            document.getElementById('dismissBtn').addEventListener('click', () => {
                installBanner.remove();
            });

            setTimeout(() => {
                if (document.body.contains(installBanner)) {
                    installBanner.remove();
                }
            }, 10000);
        }

        window.addEventListener('appinstalled', (evt) => {
            console.log('üéâ PWA was installed successfully');
        });

        function isPWA() {
            return window.matchMedia('(display-mode: standalone)').matches ||
                   window.navigator.standalone ||
                   document.referrer.includes('android-app://');
        }

        if (isPWA()) {
            console.log('üöÄ Running as PWA!');
        }

        // ÂàùÂßãÂåñÈÅäÊà≤
        window.onload = init;
    </script>
    <!-- MindCrafter ÁΩ≤Âêç -->
    <div style="text-align: center; margin-top: 15px; margin-bottom: 10px; font-size: 14px; opacity: 0.7;">
        <span style="color: #64FFDA;">@ MindCrafter</span>
    </div>
</body>
</html>

